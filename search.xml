<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenFeign基础知识</title>
      <link href="/post/38.html"/>
      <url>/post/38.html</url>
      
        <content type="html"><![CDATA[<h1 id="OpenFeign替代RestTemplate"><a href="#OpenFeign替代RestTemplate" class="headerlink" title="OpenFeign替代RestTemplate"></a>OpenFeign替代RestTemplate</h1><p>将 Feign 的 Client 抽取为独立模块，并且把默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将 UserClient、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714214041796.png" alt="image-20210714214041796"></p><h2 id="新增公共模块feign-api"><a href="#新增公共模块feign-api" class="headerlink" title="新增公共模块feign-api"></a>新增公共模块feign-api</h2><p>在服务提供方的项目里，新增模块 feign-api，并导入 openfeign 依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入实体类模块--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lyf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新增 FeignClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span> <span class="comment">//user-service 是服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span> <span class="comment">// 服务请求路径</span></span><br><span class="line">    User <span class="title function_">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改order-service模块"><a href="#修改order-service模块" class="headerlink" title="修改order-service模块"></a>修改order-service模块</h2><p>1）引入依赖</p><p>我们在 order-service 服务的 pom 文件中引入 openfeign 的依赖，和 feignClient 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--自己定义的 FeignClient 模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lyf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）添加注解</p><p>在 order-service 的启动类添加注解开启 Feign 的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.lyf.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span> <span class="comment">// 指定加载哪个 FeignClient 到 Spring 容器中</span></span><br><span class="line"><span class="comment">// @EnableFeignClients(basePackages = &quot;com.lyf.feign.clients&quot;) // 指定 Feign 应该扫描的包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>OpenFeign 扫描 Client 有两种方式：</p><ol><li>指定需要加载的 Client 接口：<code>@EnableFeignClients(clients = &#123;UserClient.class&#125;)</code></li><li>指定 Feign 应该扫描的包：<code>@EnableFeignClients(basePackages = &quot;com.lyf.feign.clients&quot;)</code></li></ol><p>推荐使用第 1 种方式，用多少加载多少。</p></blockquote><p>3）编写测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectById(orderId);</span><br><span class="line">        <span class="comment">// String url = &quot;http://user-service/user/&quot; + order.getUserId();</span></span><br><span class="line">        <span class="comment">// User user = restTemplate.getForObject(url, User.class);</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.queryById(order.getUserId());</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="OpenFeign的自定义配置"><a href="#OpenFeign的自定义配置" class="headerlink" title="OpenFeign的自定义配置"></a>OpenFeign的自定义配置</h1><p>OpenFeign 可以支持很多的自定义配置，如下表所示：</p><div class="table-container"><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table></div><blockquote><p>一般情况下，<strong>默认值就能满足我们使用</strong>，如果要自定义时，只需要创建自定义的 @Bean 覆盖默认 Bean 即可。</p></blockquote><p>下面以日志为例来演示如何自定义配置。</p><h2 id="1-配置文件方式"><a href="#1-配置文件方式" class="headerlink" title="1)配置文件方式"></a>1)配置文件方式</h2><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">user-service:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL 以及响应状态码和执行时间</li><li>HEADERS：在 BASIC 的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h2 id="2-Java代码方式"><a href="#2-Java代码方式" class="headerlink" title="2)Java代码方式"></a>2)Java代码方式</h2><p>也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的 @EnableFeignClients 这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的 @FeignClient 这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><h1 id="OpenFeign使用优化"><a href="#OpenFeign使用优化" class="headerlink" title="OpenFeign使用优化"></a>OpenFeign使用优化</h1><p>OpenFeign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高 Feign 的性能主要手段就是使用<strong>连接池</strong>代替默认的 URLConnection。</p><p>这里我们用 Apache 的 HttpClient 来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置连接池</p><p>在 order-service 的 application.yml 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><p>接下来，在 FeignClientFactoryBean 中的 loadBalance 方法中打断点：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714185925910.png" alt="image-20210714185925910"></p><p>Debug 方式启动 order-service 服务，可以看到这里的 client，底层就是 Apache HttpClient：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714190041542.png" alt="image-20210714190041542"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos基础知识</title>
      <link href="/post/37.html"/>
      <url>/post/37.html</url>
      
        <content type="html"><![CDATA[<h1 id="nacos注册发现中心"><a href="#nacos注册发现中心" class="headerlink" title="nacos注册发现中心"></a>nacos注册发现中心</h1><h2 id="导入坐标与配置"><a href="#导入坐标与配置" class="headerlink" title="导入坐标与配置"></a>导入坐标与配置</h2><p>在父工程的 pom 文件中的 <code>&lt;dependencyManagement&gt;</code> 中引入 SpringCloudAlibaba 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子工程中的 pom 文件中引入 nacos <strong>注册发现中心</strong>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos 注册发现中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注册发现中心配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><blockquote><p>如果父工程pom爆红了，不要慌，过一段时间再刷新，可能是网络问题或者是镜像源的问题。</p></blockquote><h2 id="服务集群的使用⭐"><a href="#服务集群的使用⭐" class="headerlink" title="服务集群的使用⭐"></a>服务集群的使用⭐</h2><blockquote><p>order-service 是服务调用方，user-service 是服务提供方。</p><p>order-service ===&gt; “SZ” 集群</p><p>user-service1  ===&gt; “SZ” 集群</p><p>user-service2  ===&gt; “SZ” 集群</p><p>user-service3  ===&gt; “HZ” 集群</p></blockquote><p>配置 order-service 和 user-service1 和 user-service2 为 “SZ” 集群</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">SZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>配置 user-service3 为 “HZ”  集群</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>在nacos 上查看 user-service 的 3 个实例集群分布</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230528123913533.png" alt="image-20230528123913533"></p><h3 id="同集群优先的负载均衡"><a href="#同集群优先的负载均衡" class="headerlink" title="同集群优先的负载均衡"></a>同集群优先的负载均衡</h3><p>默认的 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡</p><p>所以在上面的配置下，order-service 的请求仍然是轮询打到 3 个 user-service 实例上</p><p>因此 Nacos 中提供了一个 <code>NacosRule</code> 的实现，可以优先从同集群中挑选实例。</p><p>在服务调用方 order-service 中配置 nacos 的负载均衡规则。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><blockquote><p>也可配置全局的负载均衡规则，详情参见 <a href="https://leesin9527.github.io/post/36.html">https://leesin9527.github.io/post/36.html</a></p></blockquote><p>重启 order-service 服务并测试，最终位于 “SZ” 集群的 order-service 的实例，请求会在 位于 “SZ” 集群的两个 user-service 实例上 <strong>随机负载均衡</strong> ，而不会访问到 “HZ” 的 user-service 实例。</p><p>如果此时把 “SZ” 的两个服务实例停掉，新请求就只能打到 “HZ” 的实例上了，此时控制台会打印一个警告 <code>A cross-cluster call occurs...</code></p><h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210713235133225.png" alt="image-20210713235133225"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问。</p><p>​    ==<strong>可以实现分批上线功能</strong>==</p></blockquote><h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li>nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见</li></ul><h3 id="创建namespace"><a href="#创建namespace" class="headerlink" title="创建namespace"></a>创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714000414781.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714000440143.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714000505928.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714000522913.png" alt="image-20210714000522913"></p><h3 id="给微服务配置namespace"><a href="#给微服务配置namespace" class="headerlink" title="给微服务配置namespace"></a>给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问 order-service，因为 namespace 不同，会导致找不到 user-service，控制台会报错：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714000941256.png" alt="image-20210714000941256"></p><blockquote><p><strong>注意：</strong>实际工作中，online、dev、test 环境是分开的，分别有自己的 nacos。</p></blockquote><h2 id="nacos临时实例（建议不要改）"><a href="#nacos临时实例（建议不要改）" class="headerlink" title="nacos临时实例（建议不要改）"></a>nacos临时实例（建议不要改）</h2><p>Nacos的服务实例分为两种类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，<strong>默认的类型</strong>。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure><blockquote><p>首先需要了解的背景是：当一个<strong>以前是</strong>临时实例的实例，直接修改为非临时实例，在 nacos 中，是<strong>不允许</strong>的。也就是说，nacos 发现你的这些 ip 和端口信息什么都和以前一样，现在想直接注册为非临时实例：</p><p>nacos：欸你以前是临时实例，不给进不给进！（当场抓获）</p></blockquote><p>此时的解决方法：</p><p>1.停掉nacos</p><p>2.找到你在临时实例下的前科记录，将其销毁——来到 nacos 目录下 \data\protocol\raft，里面有你应用实例的元数据信息，像</p><p><img src="https://pic3.zhimg.com/80/v2-4a530fa2b50eca226e62b1e126deadf2_720w.webp" alt="img"></p><p>将这里的文件清空</p><p>3.重启 nacos 和应用</p><blockquote><p>解决办法出处：<a href="https://zhuanlan.zhihu.com/p/571875080">https://zhuanlan.zhihu.com/p/571875080</a></p></blockquote><h2 id="Nacos与Eureka的区别"><a href="#Nacos与Eureka的区别" class="headerlink" title="Nacos与Eureka的区别"></a>Nacos与Eureka的区别</h2><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>==<strong>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</strong>==</li></ul></li></ul><h1 id="nacos配置中心"><a href="#nacos配置中心" class="headerlink" title="nacos配置中心"></a>nacos配置中心</h1><h2 id="导入坐标与配置-1"><a href="#导入坐标与配置-1" class="headerlink" title="导入坐标与配置"></a>导入坐标与配置</h2><p>在父工程的 pom 文件中的 <code>&lt;dependencyManagement&gt;</code> 中引入 SpringCloudAlibaba 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子工程中的 pom 文件中引入 nacos <strong>配置中心</strong>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置中心配置，在bootstrap.yml中配：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">online</span> <span class="comment"># 线上环境</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>user-service-online.yaml</code></p><p>然后在 nacos 上新增相应的配置文件即可：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230528162525366.png" alt="image-20230528162525366"></p><p>编写测试接口并测试成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件加载顺序⭐"><a href="#配置文件加载顺序⭐" class="headerlink" title="配置文件加载顺序⭐"></a>配置文件加载顺序⭐</h2><p>微服务要拉取 nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。</p><p>但如果尚未读取 application.yml，又如何得知 nacos 地址呢？</p><p>因此 spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在 application.yml 之前被读取，流程如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/L0iFYNF.png" alt="img"></p><h2 id="配置热更新⭐"><a href="#配置热更新⭐" class="headerlink" title="配置热更新⭐"></a>配置热更新⭐</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>在 @Value 注入的变量所在类上添加注解 <code>@RefreshScope</code>：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714171036335.png" alt="image-20210714171036335"></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用 <code>@ConfigurationProperties</code> 注解。</p><p>在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 UserController 中使用这个类代替 @Value：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714171316124.png" alt="image-20210714171316124"></p><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>其实微服务启动时，会去 nacos 读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：user-service-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：user-service.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><blockquote><p><strong>注意：</strong>实际工作中，online、dev、test 环境是分开的，分别有自己的 nacos。所以通常一个服务只有一个 nacos 配置文件，如 user-service.yaml</p></blockquote><h2 id="配置共享的优先级"><a href="#配置共享的优先级" class="headerlink" title="配置共享的优先级"></a>配置共享的优先级</h2><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210714174623557.png" alt="image-20210714174623557"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ribbon基础知识</title>
      <link href="/post/36.html"/>
      <url>/post/36.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h1><h2 id="order-service模块"><a href="#order-service模块" class="headerlink" title="order-service模块"></a>order-service模块</h2><p>给 restTemplate 加上 <code>@LoadBalanced</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>order-service 模块调用 user-service 模块就能实现负载均衡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectById(orderId);</span><br><span class="line">        <span class="comment">// String url = &quot;http://localhost:8081/user/&quot; + order.getUserId();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://user-service/user/&quot;</span> + order.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下默认 order-service 是服务调用方，user-service 是服务提供方</p><h1 id="2-Ribbon负载均衡原理"><a href="#2-Ribbon负载均衡原理" class="headerlink" title="2.Ribbon负载均衡原理"></a>2.Ribbon负载均衡原理</h1><h2 id="负载均衡原理"><a href="#负载均衡原理" class="headerlink" title="负载均衡原理"></a>负载均衡原理</h2><p>SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210713224517686.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是 <a href="http://user-service/user/1，怎么变成了">http://user-service/user/1，怎么变成了</a> <a href="http://localhost:8081">http://localhost:8081</a> 的呢？</p><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么只输入 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p><p>其实是有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是 <code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求 uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取 uri 路径的主机名，其实就是服务 id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务 id，和用户请求。</li></ul><p>这里的 <code>this.loadBalancer</code>是 <code>LoadBalancerClient</code> 类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入 execute 方法：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1525620787090.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务 id 获取 ILoadBalancer，且会拿着 serviceId 去 eureka 中获取服务列表并保存到 ILoadBalancer 中。</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/Snipaste_2023-05-27_23-15-43.png" alt="Snipaste_2023-05-27_23-15-43"></p><ul><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p> <img src="http://cdn.leesin.fun/typora/s3/img/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个 <code>getServer</code> 方法来做负载均衡:</p><p> <img src="http://cdn.leesin.fun/typora/s3/img/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码 chooseServer 方法，发现这么一段代码：</p><p> <img src="http://cdn.leesin.fun/typora/s3/img/1525622652849.png" alt="1525622652849"></p><p>我们看看这个 rule 是谁：</p><p> <img src="http://cdn.leesin.fun/typora/s3/img/1525622699666.png" alt="1525622699666"></p><p>这里的 rule 默认值是一个 <code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="http://cdn.leesin.fun/typora/s3/img/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloud Ribbon 的底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的 RestTemplate 请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient 会从请求 url 中获取服务名称，也就是 user-service</li><li>DynamicServerListLoadBalancer 根据 user-service 到 eureka拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li>IRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li>RibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1，发起真实请求">http://localhost:8081/user/1，发起真实请求</a></li></ul><h1 id="3-负载均衡策略"><a href="#3-负载均衡策略" class="headerlink" title="3.负载均衡策略"></a>3.负载均衡策略</h1><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><div class="table-container"><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</clientConfigNameSpace></clientName></td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table></div><p>默认的实现就是 ZoneAvoidanceRule，是一种轮询方案</p><h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在 order-service（服务调用方）中的 RestConfig 配置类中，定义一个新的 IRule：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//随机的负载均衡策略</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是 user-service 服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>@Bean方式是全局设置的，即对所有的服务的请求都统一都用 RandomRule 策略</p></li><li><p>而配置文件方式是指定服务的，即只对 user-service 服务用 RandomRule 策略</p></li></ul><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h1 id="4-饥饿加载"><a href="#4-饥饿加载" class="headerlink" title="4.饥饿加载"></a>4.饥饿加载</h1><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，所以第一次请求的时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，可以通过配置开启饥饿加载。例如在 order-service（服务调用方）中配置对user-service（服务提供方）饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">user-service</span> <span class="comment"># 对 user-service 饥饿加载</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">other-service</span> <span class="comment"># 对 other-service 饥饿加载</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clound </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring事务</title>
      <link href="/post/35.html"/>
      <url>/post/35.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述（不重要）"><a href="#概述（不重要）" class="headerlink" title="概述（不重要）"></a>概述（不重要）</h1><p>事务是开发中必不可少的东西，使用 JDBC 开发时，我们使用 connnection 对事务进行控制，使用 MyBatis 时，我们 使用 SqlSession 对事务进行控制，缺点显而易见，当我们切换数据库访问技术时，事务控制的方式总会变化， Spring 就将这些技术基础上，提供了统一的控制事务的接口。Spring 的事务分为：<strong>编程式事务控制</strong> 和 <strong>声明式事务控制</strong></p><div class="table-container"><table><thead><tr><th>事务控制方式</th><th>解释</th></tr></thead><tbody><tr><td>编程式事务控制</td><td>Spring 提供了事务控制的类和方法，使用编码的方式对业务代码进行事务控制，事务控制代码和业务操作代码耦合到了一起，开发中不使用</td></tr><tr><td>声明式事务控制</td><td>Spring 将事务控制的代码封装，对外提供了 Xml 和 注解配置 方式，通过配置的方式完成事务的控制， 可以达到事务控制与业务操作代码解耦合，开发中推荐使用</td></tr></tbody></table></div><h1 id="Spring-事务编程"><a href="#Spring-事务编程" class="headerlink" title="Spring 事务编程"></a>Spring 事务编程</h1><p>Spring 事务编程相关的类主要有如下三个</p><div class="table-container"><table><thead><tr><th>事务控制相关类</th><th>解释</th></tr></thead><tbody><tr><td>平台事务管理器 PlatformTransactionManager</td><td>是一个接口标准，实现类都具备事务提交、回滚和获得事务对象的功能，不同持久层框架可能会有不同实现方案</td></tr><tr><td>事务定义 TransactionDefinition</td><td>封装事务的隔离级别、传播行为、过期时间等属性信息</td></tr><tr><td>事务状态 TransactionStatus</td><td>存储当前事务的状态信息，如果事务是否提交、是否回滚、是否有回滚点等</td></tr></tbody></table></div><h1 id="基于注解的声明式事务"><a href="#基于注解的声明式事务" class="headerlink" title="基于注解的声明式事务"></a>基于注解的声明式事务</h1><ol><li>导坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--spring-context--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mybatis-spring--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--spring-jdbc--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--druid--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--aspectj--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><!--spring-jdbc--> 依赖包含了事务的依赖</p></blockquote><ol><li>搭环境</li></ol><p>建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_account` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `money` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tb_account` (`id`, `money`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">3000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tb_account` (`id`, `money`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">6000</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>创建实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><p>mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountMapper</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">incrMoney</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decrMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lyf.mapper.AccountMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;incrMoney&quot;</span> &gt;</span></span><br><span class="line">        update tb_account set money = money - 500 where id = 1;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;decrMoney&quot;</span> &gt;</span></span><br><span class="line">        update tb_account set money = money + 500 where id = 2;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        accountMapper.incrMoney();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        accountMapper.decrMoney();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lyf&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mybatis</p><p>查看<a href="https://leesin9527.github.io/post/31.html">https://leesin9527.github.io/post/31.html</a></p><p>事务配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">  <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> app.getBean(AccountService.class);</span><br><span class="line">  accountService.transferMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h1><h2 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a>isolation 属性</h2><p>指定事务的隔离级别，事务并发存在三大问题（脏读、不可重复读、幻读）。可以通过设置事务的隔离级别来保证并发问题的出现，常用的是 READ_COMMITTED 和 REPEATABLE_READ</p><div class="table-container"><table><thead><tr><th>isolation属性</th><th>解释</th></tr></thead><tbody><tr><td>DEFAULT</td><td>默认隔离级别，取决于当前数据库隔离级别，例如MySQL默认隔离级别是REPEATABLE_READ</td></tr><tr><td>READ_UNCOMMITTED</td><td>A事务可以读取到B事务尚未提交的事务记录，不能解决任何并发问题，安全性最低，性能最高</td></tr><tr><td>READ_COMMITTED</td><td>A事务只能读取到其他事务已经提交的记录，不能读取到未提交的记录。可以解决脏读问题，但是不能解决不可重复读和幻读</td></tr><tr><td>REPEATABLE_READ</td><td>A事务多次从数据库读取某条记录结果一致，可以解决不可重复读，不可以解决幻读</td></tr><tr><td>SERIALIZABLE</td><td>串行化，可以解决任何并发问题，安全性最高，但是性能最低</td></tr></tbody></table></div><h2 id="read-only-属性"><a href="#read-only-属性" class="headerlink" title="read-only 属性"></a>read-only 属性</h2><p>设置当前的只读状态，如果是查询则设置为 true，可以提高查询性能，如果是更新(增删改)操作则设置为 false</p><h2 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a>timeout 属性</h2><p>设置事务执行的超时时间，单位是<strong>秒</strong>，如果超过该时间限制但事务还没有完成，则自动回滚事务 ，不再继续执行。默认值是-1，即没有超时时间限制。</p><h2 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a>propagation属性</h2><p>设置事务的传播行为，主要解决是 A 方法调用 B 方法时，事务的传播方式问题的，例如:使用单方的事务，还是 A 和 B 都使用自己的事务等。事务的传播行为有如下七种属性值可配置：</p><div class="table-container"><table><thead><tr><th>事务传播行为</th><th>解释</th></tr></thead><tbody><tr><td>REQUIRED(默认值)</td><td>A调用B，B需要事务，如果A有事务B就加入A的事务中，如果A没有事务，B就自己创建一个事务</td></tr><tr><td>REQUIRED_NEW</td><td>A调用B，B需要新事务，如果A有事务就挂起，B自己创建一个新的事务</td></tr><tr><td>SUPPORTS</td><td>A调用B，B有无事务无所谓，A有事务就加入到A事务中，A无事务B就以非事务方式执行</td></tr><tr><td>NOT_SUPPORTS</td><td>A调用B，B以无事务方式执行，A如有事务则挂起</td></tr><tr><td>NEVER</td><td>A调用B，B以无事务方式执行，A如有事务则抛出异常</td></tr><tr><td>MANDATORY</td><td>A调用B，B要加入A的事务中，如果A无事务就抛出异常</td></tr><tr><td>NESTED</td><td>A调用B，B创建一个新事务，A有事务就作为嵌套事务存在，A没事务就以创建的新事务执行</td></tr></tbody></table></div><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫描@Component的原理</title>
      <link href="/post/34.html"/>
      <url>/post/34.html</url>
      
        <content type="html"><![CDATA[<h1 id="XML方式的原理"><a href="#XML方式的原理" class="headerlink" title="XML方式的原理"></a>XML方式的原理</h1><p>xml 配置的方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lyf&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本质上的原理就是自定义命名空间的解析流程。</p><blockquote><p><a href="https://leesin9527.github.io/post/33.html">https://leesin9527.github.io/post/33.html</a> 这篇文章已经写清楚了大概流程</p></blockquote><p>自己阅读的入口</p><p><img src="http://cdn.leesin.fun/typora/macpro/img/image-20230511181302072.png" alt="image-20230511181302072"></p><blockquote><p>核心源码路径：ContextNamespaceHandler -&gt; ComponentScanBeanDefinitionParser -&gt; parse() -&gt; scanner.doScan(basePackages) </p></blockquote><p>在 ClassPathBeanDefinitionScanner 的 doScan 方法里找到以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line"><span class="built_in">this</span>.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br></pre></td></tr></table></figure><p>其实就是将带有 @Component 注解的类，注册进 BeanDefinitionMap</p><blockquote><p>跟前面自己写的 @Component 注解如出一辙：<a href="https://leesin9527.github.io/post/27.html">https://leesin9527.github.io/post/27.html</a></p></blockquote><h1 id="注解方式的原理"><a href="#注解方式的原理" class="headerlink" title="注解方式的原理"></a>注解方式的原理</h1><p>注解 配置的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.lyf&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理略。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://cdn.leesin.fun/typora/macpro/img/image-20230511183028804.png" alt="image-20230511183028804"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring自定义命名空间</title>
      <link href="/post/33.html"/>
      <url>/post/33.html</url>
      
        <content type="html"><![CDATA[<h1 id="以context命名空间为例"><a href="#以context命名空间为例" class="headerlink" title="以context命名空间为例"></a>以context命名空间为例</h1><p>applicationContext.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--加载 properties 文件--&gt;</span><br><span class="line">    &lt;context:property-placeholder location=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/tmpdb?serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h1 id="自定义命名空间解析的原理"><a href="#自定义命名空间解析的原理" class="headerlink" title="自定义命名空间解析的原理"></a>自定义命名空间解析的原理</h1><p>spring 解析 applicationContext.xml 时，会去依赖的 META-INF/spring.handlers 中，加载命名空间处理器到 <code>Map&lt;String, Object&gt; handlerMappings</code> 中去</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230510233503453.png" alt="image-20230510233503453"></p><p>加载的时候，会调用handler.init方法，目的是为该命名空间下的所有的标签都注入相应的解析器parser</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230510234018392.png" alt="image-20230510234018392"></p><p>当解析到 <code>&lt;context:property-placeholder&gt;</code> 时，Spring 根据命名空间 context 会得到它的 handler，然后调用它的 handler.parse方法，该方法内部最终会调用到 相应标签的doParse方法，最终完成解析。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230510234127550.png" alt="image-20230510234127550"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述分析，我们清楚的了解了外部命名空间标签的执行流程，如下：</p><ul><li>将自定义标签的约束 与 物理约束文件与网络约束名称的约束 以键值对形式存储到一个spring.schemas文件里 ，该文件存储在类加载路径的 META-INF里，Spring会自动加载到</li><li>将自定义命名空间的名称 与 自定义命名空间的处理器映射关系 以键值对形式存在到一个叫spring.handlers文 件里，该文件存储在类加载路径的 META-INF里，Spring会自动加载到</li><li>准备好NamespaceHandler，如果命名空间只有一个标签，那么直接在parse方法中进行解析即可，一般解析结 果就是注册该标签对应的BeanDefinition。如果命名空间里有多个标签，那么可以在init方法中为每个标签都注 册一个BeanDefinitionParser，在执行NamespaceHandler的parse方法时在分流给不同的 BeanDefinitionParser进行解析(重写doParse方法即可)。</li></ul><h1 id="自己写一个自定义命名空间"><a href="#自己写一个自定义命名空间" class="headerlink" title="自己写一个自定义命名空间"></a>自己写一个自定义命名空间</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>设想自己是一名架构师，进行某一个框架与 Spring 的集成开发，效果是通过一个指示标签，向 Spring 容器中自动注入一个 BeanPostProcessor</p><h2 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h2><ol><li>确定命名空间名称、schema虚拟路径、标签名称； </li><li>编写schema约束文件haohao-annotation.xsd</li><li>在类加载路径下创建META目录，编写约束映射文件spring.schemas和处理器映射文件spring.handlers</li><li>编写命名空间处理器 HaohaoNamespaceHandler，在init方法中注册HaohaoBeanDefinitionParser</li><li>编写标签的解析器 HaohaoBeanDefinitionParser，在parse方法中注册HaohaoBeanPostProcessor</li><li>编写HaohaoBeanPostProcessor </li></ol><p>———————————以上五步是框架开发者写的，以下是框架使用者写的———————————</p><ol><li>在 applicationContext.xml 配置文件中引入命名空间</li><li>在 applicationContext.xml 配置文件中使用自定义的标签</li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol><li>在类加载路径下创建 com/lyf/haohao/config 目录，编写 schema 约束文件 haohao-annotation.xsd</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.lyf.com/haohao&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.lyf.com/haohao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;annotation-driven&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在类加载路径下创建 META-INF 目录，编写约束映射文件 spring.schemas 和处理器映射文件 spring.handlers</li></ol><p>spring.schemas</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http\://www.lyf.com/haohao/haohao-annotation.xsd</span> =<span class="string">com/lyf/haohao/config/haohao-annotation.xsd</span></span><br></pre></td></tr></table></figure><p>spring.handlers</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http\://www.lyf.com/haohao</span> =<span class="string">com.lyf.haohao.handler.HaohaoNamespaceHandler</span></span><br></pre></td></tr></table></figure><ol><li>编写命名空间处理器 HaohaoNamespaceHandler，在 init 方法中注册 HaohaoBeanDefinitionParser</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaohaoNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> <span class="title class_">HaohaoBeanDefinitionParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写标签的解析器 HaohaoBeanDefinitionParser，在 parse 方法中注册 MyBeanPostProcessor</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaohaoBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionParser</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 HaohaoBeanPostProcessor 的 BeanDefinition</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClass(HaohaoBeanPostProcessor.class);</span><br><span class="line">        <span class="comment">// 注册 myBeanPostProcessor</span></span><br><span class="line">        parserContext.getRegistry().registerBeanDefinition(<span class="string">&quot;myBeanPostProcessor&quot;</span>,beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写 MyBeanPostProcessor</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自动注入 MyBeanPostProcessor 成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写配置文件 applicationContext.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:haohao</span>=<span class="string">&quot;http://www.lyf.com/haohao&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.lyf.com/haohao http://www.lyf.com/haohao/haohao-annotation.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.entity.User&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">haohao:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>测试代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>控制台输出</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动注入HaohaoBeanPostProcessor成功</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230511130509491.png" alt="image-20230511130509491"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Import注解</title>
      <link href="/post/32.html"/>
      <url>/post/32.html</url>
      
        <content type="html"><![CDATA[<p>Spring 与 MyBatis 注解方式整合有个重要的技术点就是 @Import。第三方框架与 Spring 整合 xml 方式很多是凭借自定义标签完成的，而第三方框架与 Spring 整合注解方式很多是靠 @Import 注解完成的。</p><h1 id="Import-可以导入的类"><a href="#Import-可以导入的类" class="headerlink" title="@Import 可以导入的类"></a>@Import 可以导入的类</h1><p>@Import 可以导入如下三种类:</p><ul><li>普通的配置类</li><li>实现 ImportSelector 接口的类</li><li>实现 ImportBeanDefinitionRegistrar 接口的类</li></ul><h1 id="普通的配置类"><a href="#普通的配置类" class="headerlink" title="普通的配置类"></a>普通的配置类</h1><p>其他的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherBean</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OtherBean <span class="title function_">otherBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OtherBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(OtherConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    <span class="type">OtherConfig</span> <span class="variable">otherConfig</span> <span class="operator">=</span> context.getBean(OtherConfig.class);</span><br><span class="line">    System.out.println(otherConfig);<span class="comment">// 能获取到</span></span><br><span class="line">    <span class="type">OtherBean</span> <span class="variable">otherBean</span> <span class="operator">=</span> context.getBean(OtherBean.class);</span><br><span class="line">    System.out.println(otherBean);<span class="comment">// 能获取到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现-ImportSelector-接口的类"><a href="#实现-ImportSelector-接口的类" class="headerlink" title="实现 ImportSelector 接口的类"></a>实现 ImportSelector 接口的类</h1><p>其他的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherBean</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的 ImportSelector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// 返回要进行注册的 Bean 的全限定名数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.lyf.other.OtherBean&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.lyf&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    <span class="type">OtherBean</span> <span class="variable">otherBean</span> <span class="operator">=</span> context.getBean(OtherBean.class);</span><br><span class="line">    System.out.println(otherBean);<span class="comment">// 能获取到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—————分割线————-</p><p>ImportSelector 接口 selectImports 方法的参数 AnnotationMetadata 代表注解的元数据，可以获得当前注解修饰的类的元信息，例如:获得组件扫描的包名。</p><p>修改 MyImportSelector.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// 获得指定类型注解的全部元信息</span></span><br><span class="line">        Map&lt;String, Object&gt; annotationAttributes =</span><br><span class="line">                annotationMetadata.getAnnotationAttributes(ComponentScan.class.getName());</span><br><span class="line">        <span class="comment">// 获得 basePackages 信息</span></span><br><span class="line">        String[] basePackages = (String[]) annotationAttributes.get(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印结果是 com.lyf</span></span><br><span class="line">        System.out.println(basePackages[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.lyf.other.OtherBean&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行测试类，控制台输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.lyf</span><br></pre></td></tr></table></figure><h1 id="实现-ImportBeanDefinitionRegistrar-接口的类"><a href="#实现-ImportBeanDefinitionRegistrar-接口的类" class="headerlink" title="实现 ImportBeanDefinitionRegistrar 接口的类"></a>实现 ImportBeanDefinitionRegistrar 接口的类</h1><p>其他的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherBean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的 ImportBeanDefinitionRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 BeanDefinition</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beandefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        beandefinition.setBeanClassName(<span class="string">&quot;com.lyf.other.OtherBean2&quot;</span>);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;otherBean2&quot;</span>, beandefinition);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.lyf&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">    <span class="type">OtherBean2</span> <span class="variable">otherBean2</span> <span class="operator">=</span> context.getBean(OtherBean2.class);</span><br><span class="line">    System.out.println(otherBean2);<span class="comment">// 能获取到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模仿-MyBatis-的-MapperScan"><a href="#模仿-MyBatis-的-MapperScan" class="headerlink" title="模仿 MyBatis 的 MapperScan"></a>模仿 MyBatis 的 MapperScan</h2><p>编写 MyMapperScan </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MyMapperScannerRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMapperScan &#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 MyMapperScannerRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获得指定类型注解的全部元信息</span></span><br><span class="line">        Map&lt;String, Object&gt; annotationAttributes =</span><br><span class="line">                importingClassMetadata.getAnnotationAttributes(MyMapperScan.class.getName());</span><br><span class="line">      <span class="comment">// 获得 basePackages 信息</span></span><br><span class="line">        String[] basePackages = (String[]) annotationAttributes.get(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">      <span class="comment">// 打印结果是 com.lyf</span></span><br><span class="line">        System.out.println(basePackages[<span class="number">0</span>]);</span><br><span class="line">      <span class="comment">// 将 MapperScannerConfigurer 注册进 BeanDefinitionMap 中......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 配置类里使用 @MyMapperScan，并指定 basePackages</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MyMapperScan(basePackages = &#123;&quot;com.lyf&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台打印：com.lyf</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring整合MyBatis</title>
      <link href="/post/31.html"/>
      <url>/post/31.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>spring xml 整合第三方框架有两种整合方案：</p><ul><li>不需要自定义名空间，不需要使用Spring的配置文件配置第三方框架本身内容，例如：MyBatis</li><li>需要引入第三方框架命名空间，需要使用 Spring 的配置文件配置第三方框架本身内容，例如：Dubbo</li></ul><h1 id="MyBatis原始操作"><a href="#MyBatis原始操作" class="headerlink" title="MyBatis原始操作"></a>MyBatis原始操作</h1><ol><li>导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>数据库创表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user <span class="keyword">values</span> (<span class="number">1</span>, &quot;zhangsan&quot;, &quot;zz&quot;), (<span class="number">2</span>, &quot;lisi&quot;, &quot;zz&quot;);</span><br></pre></td></tr></table></figure><ol><li>准备实体类User，UserMapper.java，UserMapper.xml</li></ol><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lyf.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.lyf.entity.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>MyBatis 配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--扫描 Mapper --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lyf.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>编写主类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> builder.build(in);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; users = mapper.findAll();</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">      System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-整合-MyBatis【xml】"><a href="#Spring-整合-MyBatis【xml】" class="headerlink" title="Spring 整合 MyBatis【xml】"></a>Spring 整合 MyBatis【xml】</h1><p>MyBatis 提供了 mybatis-spring.jar 专门用于两大框架的整合。</p><p>Spring 整合 MyBatis 的步骤如下：</p><ul><li>导入 MyBatis 整合 Spring 的相关坐标</li><li>编写 Mapper 和 Mapper.xml</li><li>配置 SqlSessionFactoryBean 和 MapperScannerConfigurer</li><li>编写测试代码</li></ul><ol><li>在上面的基础上，导入额外的包</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-context--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!--mybatis-spring--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring-jdbc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--druid--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>编写 Mapper 和 Mapper.xml</li></ol><blockquote><p>和上面一样</p></blockquote><ol><li>配置 SqlSessionFactoryBean 和 MapperScannerConfigurer</li></ol><p>application-context.xml 取代原来的 mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;datasource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;rootroot&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置 SqlSessionFactoryBean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;datasource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置 Mapper 包扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.lyf.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>编写测试代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application-context.xml&quot;</span>);</span><br><span class="line">  <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> context.getBean(UserMapper.class);</span><br><span class="line">  List&lt;User&gt; users = userMapper.findAll();</span><br><span class="line">  <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整合原理【xml】"><a href="#整合原理【xml】" class="headerlink" title="整合原理【xml】"></a>整合原理【xml】</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1rt4y1u7q5?p=60">https://www.bilibili.com/video/BV1rt4y1u7q5?p=60</a></p><p><a href="https://www.bilibili.com/video/BV1rt4y1u7q5?p=61">https://www.bilibili.com/video/BV1rt4y1u7q5?p=61</a></p></blockquote><p>整合包里提供了一个 SqlSessionFactoryBean 和一个扫描 Mapper 的配置对象，SqlSessionFactoryBean 一旦被实例化，就开始扫描 Mapper 并通过动态代理产生 Mapper 的实现类存储到 Spring 容器中。</p><p>相关的有如下四个类：</p><ul><li>SqlSessionFactoryBean：需要进行配置，用于提供 SqlSessionFactory</li><li>MapperScannerConfigurer：需要进行配置，用于扫描指定 mapper 注册 BeanDefinition</li><li>MapperFactoryBean：Mapper 的 FactoryBean，获得指定 Mapper 时调用 getObject 方法</li><li>ClassPathMapperScanner：definition.setAutowireMode(2) 修改了自动注入状态，所以 MapperFactoryBean 中的 setSqlSessionFactory 会自动注入进去。</li></ul><h2 id="SqlSessionFactoryBean-源码精简"><a href="#SqlSessionFactoryBean-源码精简" class="headerlink" title="SqlSessionFactoryBean 源码精简"></a>SqlSessionFactoryBean 源码精简</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;SqlSessionFactory&gt;, InitializingBean&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="comment">// 这个是我们在配置文件中注入调用的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="built_in">this</span>.sqlSessionFactory = <span class="built_in">this</span>.buildSqlSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> SqlSessionFactory <span class="title function_">buildSqlSessionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        targetConfiguration.setDataSource(<span class="built_in">this</span>.dataSource);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>复习一下 Bean 生命周期：Bean 实例化 -&gt; 属性填充 -&gt; Aware接口 -&gt; BeanPostProcessor 的 before() -&gt; InitializingBean 的 afterPropertiesSet() -&gt; 自定义初始化方法 init() -&gt; BeanPostProcessor 的 after()</p><p>所以 SqlSessionFactoryBean 的调用顺序：</p><p>setDataSource() -&gt; afterPropertiesSet() -&gt; buildSqlSessionFactory() -&gt; 产生sqlSessionFactory</p><p>然后如果有人调用 context.getBean(SqlSessionFactory.class) 时，Spring 就会调用 SqlSessionFactoryBean 的 getObject() 方法，将 sqlSessionFactory 返回给调用者。</p></blockquote><h2 id="MapperScannerConfigurer-源码精简"><a href="#MapperScannerConfigurer-源码精简" class="headerlink" title="MapperScannerConfigurer 源码精简"></a>MapperScannerConfigurer 源码精简</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapperScannerConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">        scanner.scan(StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, <span class="string">&quot;,; \t\n&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ClassPathMapperScanner 并没有 scan 方法，所以调用其父类 ClassPathBeanDefinitionScanner 的 scan 方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="built_in">this</span>.doScan(basePackages);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        <span class="comment">//将扫描到的类注册到 beanDefinitionMap 中，此时 beanClass 是当前类全限定名</span></span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>由于是子类调用的 scan 方法，所以 <code>this.doScan(basePackages);</code> 这条语句实际上是执行的子类的 doScan 方法。</p><p>然后子类又调用父类的 doScan 方法：<code>super.doScan(basePackages);</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line">        <span class="keyword">if</span> (!beanDefinitions.isEmpty()) </span><br><span class="line">        <span class="built_in">this</span>.processBeanDefinitions(beanDefinitions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            definition = holder.getBeanDefinition();</span><br><span class="line">            <span class="comment">//设置 Mapper 的 beanClass 是 org.mybatis.spring.mapper.MapperFactoryBean</span></span><br><span class="line">            definition.setBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">            definition.setAutowireMode(<span class="number">2</span>); <span class="comment">//设置 MapperBeanFactory 进行自动注入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总的来说，父类的 doScan 首先将 <code>&lt;beanName,Mapper接口类对象&gt;</code> 的 BeanDefinition 注册进 BeanDefinitionMap 中</p><p>然后，子类再将 BeanDefinition 的全限定类名改为 MapperFactoryBean，因为 Mapper 作为接口不能通过反射创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;<span class="comment">// SqlSessionTemplate 是 SqlSession 的子类</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionTemplate = <span class="built_in">this</span>.createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后 MapperFactoryBean 的 getObject 方法， 就是通过 MyBatis 提供的原始方式来获取 Mapper 的。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SqlSessionFactoryBean 作为一个 FactoryBean，向 Spring 提供 SqlSessionFactory</p><p>MapperScannerConfigurer 作为一个 BeanDefinitionRegistryPostProcessor，对 Spring Bean 的生命周期进行干扰，将扫描到的 mapper 转化为一个个的BeanDefinition: <code>&lt;mapperName, MapperFactoryBean的className&gt;</code>，最后把这些 BeanDefinition 都注册进 BeanDefinitionMap 中。</p><h1 id="Spring整合MyBatis【注解】"><a href="#Spring整合MyBatis【注解】" class="headerlink" title="Spring整合MyBatis【注解】"></a>Spring整合MyBatis【注解】</h1><ol><li>导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--spring-context--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mybatis-spring--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--spring-jdbc--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--druid--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>数据库创表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user <span class="keyword">values</span> (<span class="number">1</span>, &quot;zhangsan&quot;, &quot;zz&quot;), (<span class="number">2</span>, &quot;lisi&quot;, &quot;zz&quot;);</span><br></pre></td></tr></table></figure><ol><li>准备实体类User，UserMapper.java，UserMapper.xml</li></ol><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.lyf.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;findAll&quot;</span> resultType=<span class="string">&quot;com.lyf.entity.User&quot;</span>&gt;</span><br><span class="line">        select * from tb_user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol><li>编写 jdbc.properties 配置文件</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><ol><li>编写 Spring 的配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.lyf&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写 MyBatis 的配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.lyf.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span> String driver,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span> String url,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span> String password)</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DruidDataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">  <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> context.getBean(UserMapper.class);</span><br><span class="line">  List&lt;User&gt; users = userMapper.findAll();</span><br><span class="line">  <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整合原理【注解】"><a href="#整合原理【注解】" class="headerlink" title="整合原理【注解】"></a>整合原理【注解】</h1><p>注解方式，Spring 整合 MyBatis 的原理，关键在于 @MapperScan，@MapperScan 不是 Spring 提供的注解，是 MyBatis 为了整合 Spring，在整合包 org.mybatis.spring.annotation 中提供的注解，源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span> </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="meta">@Import(&#123;MapperScannerRegistrar.class&#125;)</span> </span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass() <span class="keyword">default</span> Annotation.class; </span><br><span class="line">  <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注一下 <code>@Import(&#123;MapperScannerRegistrar.class&#125;)</code> ，当 @MapperScan 被扫描加载时，会解析 @Import 注解，从而加载指定的类，此处就是加载了 MapperScannerRegistrar</p><p>MapperScannerRegistrar 实现了 ImportBeanDefinitionRegistrar 接口，Spring 会自动调用 registerBeanDefinitions 方法，该方法中又注册 MapperScannerConfigurer 类，而 MapperScannerConfigurer 类作用是扫描 Mapper，向容器中注册 Mapper 对应的 MapperFactoryBean，前面讲过，此处不在赘述了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">  <span class="comment">//默认执行registerBeanDefinitions方法</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">    <span class="comment">//... 省略其他代码 ...</span></span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;basePackage&quot;</span>, StringUtils.collectionToCommaDelimitedString(basePackages));</span><br><span class="line">    <span class="comment">//注册BeanDefinition</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, builder.getBeanDefinition()); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的核心就是将 MapperScannerConfigurer 注册进 Spring 容器中</p></blockquote><h1 id="提个问题"><a href="#提个问题" class="headerlink" title="提个问题"></a>提个问题</h1><p>xml 方式中，是通过配置文件的方式把 basePackage 传给 MapperScannerConfigurer。</p><p>那注解方式呢？ MapperScannerConfigurer 的 basePackage 从哪里来？</p><p>上面已经知道，MapperScannerRegistrar 会将 MapperScannerConfigurer 注册进 BeanDefinitionMap 中，但是细节没细挖。</p><p>通过源码可以看到，MapperScannerRegistrar 还有一行代码，是给 MapperScannerConfigurer 的 BeanDefinition 添加 “basePackage” 属性的。</p><p>然后 MapperScannerConfigurer 在执行 MapperScannerConfigurer 时，就会取出自己的BeanDefinition的 “basePackage” 属性的值。</p><blockquote><p>注：MapperScannerConfigurer 的 postProcessBeanDefinitionRegistry 方法，作用是根据 basePackage 来扫描 mapper，把扫描到的 mapper 封装成 BeanDefinition ，然后注册进 BeanDefinitionMap 中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP入门</title>
      <link href="/post/30.html"/>
      <url>/post/30.html</url>
      
        <content type="html"><![CDATA[<h1 id="AOP-相关概念"><a href="#AOP-相关概念" class="headerlink" title="AOP 相关概念"></a>AOP 相关概念</h1><p><img src="http://cdn.leesin.fun/typora/nana/img/aop相关概念.png" alt="aop相关概念"></p><h1 id="基于-XML-的-AOP"><a href="#基于-XML-的-AOP" class="headerlink" title="基于 XML 的 AOP"></a>基于 XML 的 AOP</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>准备目标类、增强类，并交由 Spring 管理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;show...&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;前置增强...&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;后置增强...&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置切点表达式（哪些方法被增强）</li><li>配置织入（切点被哪些通知方法增强，是哪种增强类型）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.advice.MyAdvice&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切点表达式,对哪些方法进行增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(void com.lyf.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--切面=切点+通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定前置通知方法是beforeMethod--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定后置通知方法是afterMethod--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterMethod&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userService.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>输出</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前置增强...</span><br><span class="line">show...</span><br><span class="line">后置增强...</span><br></pre></td></tr></table></figure><h2 id="切点表达式"><a href="#切点表达式" class="headerlink" title="切点表达式"></a>切点表达式</h2><p>语法如下</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([访问修饰符] 返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure><blockquote><ul><li>访问修饰符可以省略不写</li><li>返回值类型、某一级包名、类名、方法名 可以使用 * 表示任意</li><li>包名与类名之间使用单点 . 表示该包下的类，使用双点 .. 表示该包及其子包下的类</li><li>参数列表可以使用两个点 .. 表示任意参数</li></ul></blockquote><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示访问修饰符为public、无返回值、在com.itheima.aop包下的TargetImpl类的无参方法show</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.aop.TargetImpl.show())</span><br><span class="line"></span><br><span class="line"><span class="comment">//表述com.itheima.aop包下的TargetImpl类的任意方法</span></span><br><span class="line">execution(* com.itheima.aop.TargetImpl.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示com.itheima.aop包下的任意类的任意方法</span></span><br><span class="line">execution(* com.itheima.aop.*.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示com.itheima.aop包及其子包下的任意类的任意方法</span></span><br><span class="line">execution(* com.itheima.aop..*.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示任意包中的任意类的任意方法</span></span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure><h2 id="AspectJ的五种通知类型"><a href="#AspectJ的五种通知类型" class="headerlink" title="AspectJ的五种通知类型"></a>AspectJ的五种通知类型</h2><div class="table-container"><table><thead><tr><th>通知名称</th><th>配置方式</th><th>执行时机</th></tr></thead><tbody><tr><td>前置通知</td><td>&lt; aop:before &gt;</td><td>目标方法执行之前执行</td></tr><tr><td>后置通知</td><td>&lt; aop:after-returning &gt;</td><td>目标方法执行之后执行。当目标方法异常时，不执行</td></tr><tr><td>环绕通知</td><td>&lt; aop:around &gt;</td><td>目标方法执行前后执行。当目标方法异常时，不执行</td></tr><tr><td>异常通知</td><td>&lt; aop:after-throwing &gt;</td><td>目标方法抛出异常时执行</td></tr><tr><td>最终通知</td><td>&lt; aop:after &gt;</td><td>不管目标方法是否有异常，最终都会执行</td></tr></tbody></table></div><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 MyAdvice 类里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//环绕前</span></span><br><span class="line">    System.out.println(<span class="string">&quot;环绕前通知&quot;</span>);</span><br><span class="line">    <span class="comment">//目标方法</span></span><br><span class="line">    joinPoint.proceed();</span><br><span class="line">    <span class="comment">///环绕后</span></span><br><span class="line">    System.out.println(<span class="string">&quot;环绕后通知&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其他代码和前面的一样</p></blockquote><h3 id="异常通知1"><a href="#异常通知1" class="headerlink" title="异常通知1"></a>异常通知1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show...&quot;</span>);</span><br><span class="line">        <span class="comment">// 制造异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 MyAdvice 类里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;目标方法抛出异常了，后置通知和环绕后通知不在执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show1...</span><br><span class="line">目标方法抛出异常了，后置通知和环绕后通知不在执行</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="异常通知2"><a href="#异常通知2" class="headerlink" title="异常通知2"></a>异常通知2</h3><blockquote><p>如果想要在 afterThrowing 通知方法里拿到 Throwable 参数，需要在配置文件中加一点配置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;目标方法抛出异常了，后置通知和环绕后通知不在执行&quot;</span>);</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;e&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>通知方法在被调用时，Spring 可以为其传递一些必要的参数</p><div class="table-container"><table><thead><tr><th>参数类型</th><th>作用</th></tr></thead><tbody><tr><td>JoinPoint</td><td>连接点对象，任何通知都可使用，可以获得当前目标对象、目标方法参数等信息</td></tr><tr><td>ProceedingJoinPoint</td><td>JoinPoint 子类对象，主要是在环绕通知中执行 proceed() ，进而执行目标方法</td></tr><tr><td>Throwable</td><td>异常对象，使用在异常通知中，需要在配置文件中指出异常对象名称</td></tr></tbody></table></div><h3 id="JoinPoint对象"><a href="#JoinPoint对象" class="headerlink" title="JoinPoint对象"></a>JoinPoint对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 通知方法名称(JoinPoint joinPoint) &#123;</span><br><span class="line">    <span class="comment">//获得目标方法的参数</span></span><br><span class="line">    System.out.println(joinPoint.getArgs());</span><br><span class="line">    <span class="comment">//获得目标对象</span></span><br><span class="line">    System.out.println(joinPoint.getTarget());</span><br><span class="line">    <span class="comment">//获得精确的切点表达式信息</span></span><br><span class="line">    System.out.println(joinPoint.getStaticPart());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ProceedingJoinPoint对象"><a href="#ProceedingJoinPoint对象" class="headerlink" title="ProceedingJoinPoint对象"></a>ProceedingJoinPoint对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(joinPoint.getArgs());<span class="comment">//获得目标方法的参数</span></span><br><span class="line">    System.out.println(joinPoint.getTarget());<span class="comment">//获得目标对象</span></span><br><span class="line">    System.out.println(joinPoint.getStaticPart());<span class="comment">//获得精确的切点表达式信息</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();<span class="comment">//执行目标方法</span></span><br><span class="line">    <span class="keyword">return</span> result;<span class="comment">//返回目标方法返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Throwable对象"><a href="#Throwable对象" class="headerlink" title="Throwable对象"></a>Throwable对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint,Throwable th)</span>&#123;</span><br><span class="line">    <span class="comment">//获得异常信息</span></span><br><span class="line">System.out.println(<span class="string">&quot;异常对象是：&quot;</span>+th+<span class="string">&quot;异常信息是：&quot;</span>+th.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;th&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="基于注解方式的-AOP"><a href="#基于注解方式的-AOP" class="headerlink" title="基于注解方式的 AOP"></a>基于注解方式的 AOP</h1><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li>导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>准备目标类、增强类，并交由 Spring 管理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;show...&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>切面类：编写切点、编写通知方法、配置织入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 切点表达式的抽取</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.lyf.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;myPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前置通知...&quot;</span>);</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后置通知...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置类：开启 spring 的自动代理，开启组件扫描</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lyf&quot;)</span> <span class="comment">//用于组件扫描</span></span><br><span class="line"><span class="comment">//@PropertySource(&quot;classpath:jdbc.properties&quot;) //用于加载配置文件</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//开启spring自动代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不重要的知识点：如果是new ClassPathXmlApplicationContext()，需要在配置文件中加入配置<code>&lt;aop:aspectj-autoproxy&gt;</code> ，来开启spring的自动代理。</p><ol><li>测试类</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userService.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>输出</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">环绕前置通知...</span><br><span class="line">show...</span><br><span class="line">环绕后置通知...</span><br></pre></td></tr></table></figure><h1 id="统一日志处理⭐"><a href="#统一日志处理⭐" class="headerlink" title="统一日志处理⭐"></a>统一日志处理⭐</h1><ol><li>坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>编写统一日志注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写日志切面类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.lyf.log.MyLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;logPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pjp.getTarget().getClass().getSimpleName();</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) pjp.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> methodSignature.getMethod().getName();</span><br><span class="line">        System.out.println(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;======耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写配置类，并开启 spring 自动代理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lyf&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写目标类和目标方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@MyLog</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;say1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;say2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编写测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> context.getBean(UserDao.class);</span><br><span class="line">        userDao.say1();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        userDao.say2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>输出</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">say1...</span><br><span class="line">UserDaoImpl.say1======耗时：1006ms</span><br><span class="line">-----------</span><br><span class="line">say2...</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，在 say1 方法上加了统一日志注解，所以say1被增强了。say2 正常执行。</p></blockquote><h2 id="AOP的另一种配置方式——-Advice"><a href="#AOP的另一种配置方式——-Advice" class="headerlink" title="AOP的另一种配置方式——-Advice"></a>AOP的另一种配置方式——-Advice</h2><p>AOP 的另一种配置方式，该方式需要通知类实现 Advice 的子功能接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Advice</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>Advice 的子功能接口</p><p><img src="http://cdn.leesin.fun/typora/macpro/img/image-20230511183755898.png" alt="image-20230511183755898"></p><p>例如：通知类实现了前置通知和后置通知接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span>, AfterReturningAdvice &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面使用 advisor 标签配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--织入：将通知和切点进行结合--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.lyf.dao.impl.UserDaoImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>又例如：通知类实现了方法拦截器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice2</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前置...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span></span><br><span class="line">                methodInvocation.getMethod().invoke(methodInvocation.getThis(), methodInvocation.getArguments());</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后置...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面使用 advisor 标签配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">  &lt;!--织入：将通知和切点进行结合--&gt;</span><br><span class="line">  &lt;aop:advisor advice-ref=<span class="string">&quot;myAdvice2&quot;</span> pointcut=<span class="string">&quot;execution(* com.lyf.dao.impl.UserDaoImpl.*(..))&quot;</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li>实际开发中，自定义 aop 功能的配置大多使用 aspect 的配置方式，</li><li>学习 advisor 是为了后面学习 Spring 声明式事务控制做铺垫。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解开发</title>
      <link href="/post/29.html"/>
      <url>/post/29.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a>Spring注解开发</h1><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取方式:applicationContext.getBean(&quot;userDao&quot;); </span></span><br><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方式:applicationContext.getBean(&quot;userDaoImpl&quot;); </span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bean标签的属性对应关系"><a href="#bean标签的属性对应关系" class="headerlink" title="bean标签的属性对应关系"></a>bean标签的属性对应关系</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>xml配置</th><th>注解</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;bean scope=&quot;&quot;&gt;</code></td><td>@Scope</td><td>在类上或使用了@Bean标注的方法上，标注Bean的作用范围，取值为 singleton或prototype</td></tr><tr><td><code>&lt;bean lazy-init=&quot;&quot;&gt;</code></td><td>@Lazy</td><td>在类上或使用了@Bean标注的方法上，标注Bean是否延迟加载，取值为 true和false</td></tr><tr><td><code>&lt;bean init-method=&quot;&quot;&gt;</code></td><td>@PostConstruct</td><td>在方法上使用，标注Bean的实例化后执行的方法</td></tr><tr><td><code>&lt;bean destroy-method=&quot;&quot;&gt;</code></td><td>@PreDestroy</td><td>在方法上使用，标注Bean的销毁前执行方法</td></tr></tbody></table></div><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="meta">@Lazy(true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PostConstruct</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@PreDestroy</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bean标签的字标签对应关系"><a href="#bean标签的字标签对应关系" class="headerlink" title="bean标签的字标签对应关系"></a>bean标签的字标签对应关系</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>属性注入注解</th><th>描述</th></tr></thead><tbody><tr><td>@Value</td><td>使用在字段或方法上，用于注入普通数据</td></tr><tr><td>@Autowired</td><td>使用在字段或方法上，用于根据类型(byType)注入引用数据</td></tr><tr><td>@Qualifier</td><td>使用在字段或方法上，结合@Autowired，根据名称注入</td></tr><tr><td>@Resource</td><td>使用在字段或方法上，根据类型或名称进行注入</td></tr></tbody></table></div><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;haohao&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还支持一些 SpEL 表达式</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure><blockquote><p>@Autowired 默认 ByType 注入。但是如果类型有多个，就会 ByName 注入，默认根据属性名称注入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里有两个 UserDao 类型，</span></span><br><span class="line">    <span class="comment">// 所以根据 BeanName=&quot;userDao1&quot; 来注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;com.lyf&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        ((UserServiceImpl)userService).getUserDao1().say(); <span class="comment">// 我是1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果当有多个 UserDao 类型的对象，且又不想用默认的 以属性名作为 BeanName 的 ByName 方式注入。</p><p>那么可以配合 @Qualifier 来指定 BeanName，这里就不演示了。</p><p>也可以用@Resource，此注解如果不指定name属性，默认name=属性名，如果指定了name属性的值，那就按照指定值来注入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;userDao2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非自定义-Bean-的注入"><a href="#非自定义-Bean-的注入" class="headerlink" title="非自定义 Bean 的注入"></a>非自定义 Bean 的注入</h2><p>如果 @Bean 工厂方法需要<strong>参数</strong>的话，则有如下几种注入方式:</p><ul><li>使用 @Autowired 根据类型自动进行Bean的匹配，<strong>@Autowired 可以省略</strong> </li><li>使用 @Qualifier 根据名称进行 Bean 的匹配</li><li>使用 @Value 注入基本数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 交由 spring 管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherBeanConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 不指定值，默认就是方法名，即 otherBean</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">otherBean</span><span class="params">(UserDao userDao, // 根据类型注入，省略了 <span class="meta">@Autowired</span></span></span><br><span class="line"><span class="params">                               <span class="meta">@Qualifier(&quot;userService&quot;)</span> UserService userService, // 根据 beanName 进行注入</span></span><br><span class="line"><span class="params">                               <span class="meta">@Value(&quot;zhangsan&quot;)</span> String username)</span>&#123; <span class="comment">// 注入基本类型</span></span><br><span class="line">        System.out.println(userDao);</span><br><span class="line">        System.out.println(userService);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>xml方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载properties文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入其他xml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:beans.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启spring自动代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置类注解方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lyf&quot;)</span> <span class="comment">// &lt;context:component-scan base-package=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span>  <span class="comment">//&lt;context:property-placeholder location=“”/&gt;</span></span><br><span class="line"><span class="meta">@Import(OtherConfig.class)</span> <span class="comment">// &lt;import resource=“classpath:beans.xml”/&gt;</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// &lt;aop:aspectj-autoproxy&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>base-package的配置方式:</p><ul><li>指定一个或多个包名：扫描指定包及其子包下使用注解的类</li><li>不配置包名：扫描当前 @componentScan 注解配置类所在包及其子包下的类</li></ul><h2 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h2><h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">userDao01</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">userDao02</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl2</span>();&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Primary 注解用于标注相同类型的 Bean 优先被使用权，与 @Component 和 @Bean 一起使用，标注该 Bean 的优先级更高，则在通过类型获取 Bean 或通过 @Autowired 根据类型进行注入时， 会选用优先级更高的。</p></blockquote><h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p>扩展：@Profile 注解的作用同于 xml 配置时学习 profile 属性，是进行环境切换使用的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注解  @Profile  标注在类或方法上，标注当前产生的 Bean 从属于哪个环境，只有激活了当前环境，被标注的 Bean 才能被注册到 Spring 容器里，不指定环境的 Bean，任何环境下都能注册到 Spring 容器里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以使用以下两种方式指定被激活的环境：</p><ul><li>使用命令行动态参数，虚拟机参数位置加载 <code>-Dspring.profiles.active=test</code></li><li>使用代码的方式设置环境变量 <code>System.setProperty(&quot;spring.profiles.active&quot;,&quot;test&quot;);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/post/28.html"/>
      <url>/post/28.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Bean的生命周期⭐⭐⭐"><a href="#Spring-Bean的生命周期⭐⭐⭐" class="headerlink" title="Spring Bean的生命周期⭐⭐⭐"></a>Spring Bean的生命周期⭐⭐⭐</h1><p>Spring Bean 的生命周期是从 Bean 实例化之后，即通过反射创建出对象之后，到 Bean 成为一个完整对象，最终存储到单例池中，这个过程被称为 Spring Bean 的生命周期。Spring Bean 的生命周期大体上分为三个阶段:</p><ol><li>Bean 的实例化阶段：Spring 框架会取出 BeanDefinition 的信息进行判断当前 Bean 的范围是否是 singleton 的， 是否不是延迟加载的，是否不是 FactoryBean 等，最终将一个普通的 singleton 的 Bean 通过反射进行实例化;</li><li>Bean 的初始化阶段：Bean 创建之后还仅仅是个”半成品”，还需要对 Bean 实例的属性进行填充、执行一些 Aware 接口方法、执行 BeanPostProcessor 方法、执行 InitializingBean 接口的初始化方法、执行自定义初始化 init 方法等。该阶段是 Spring 最具技术含量和复杂度的阶段，Aop增强功能，后面要学习的 Spring 的注解功能等、 spring 高频面试题 Bean 的循环引用问题都是在这个阶段体现的;</li><li>Bean 的完成阶段：经过初始化阶段，Bean 就成为了一个完整的 Spring Bean，被存储到单例池 singletonObjects 中去了，即完成了 Spring Bean 的整个生命周期。</li></ol><h2 id="Bean-的初始化阶段"><a href="#Bean-的初始化阶段" class="headerlink" title="Bean 的初始化阶段"></a>Bean 的初始化阶段</h2><p>由于 Bean 的初始化阶段的步骤比较复杂，所以着重研究Bean的初始化阶段。</p><p>Spring Bean 的初始化过程涉及如下几个过程: </p><ul><li>Bean 实例的属性填充</li><li>Aware 接口属性注入</li><li>BeanPostProcessor 的 before() 方法回调</li><li>InitializingBean 接口的初始化方法回调</li><li>自定义初始化方法 init 回调</li><li>BeanPostProcessor 的 after() 方法回调</li></ul><p>PS:通过代码验证上述初始化顺序… …</p><h3 id="Bean-实例属性填充"><a href="#Bean-实例属性填充" class="headerlink" title="Bean 实例属性填充"></a>Bean 实例属性填充</h3><p><img src="http://cdn.leesin.fun/typora/macpro/img/Bean%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85.png" alt="Bean属性填充"></p><p>Spring 在进行属性注入时，会分为如下几种情况：</p><ul><li>注入普通属性，String、int 或存储基本类型的集合时，直接通过 set 方法的反射设置进去</li><li>注入单向对象引用属性时，从容器中 getBean 获取后通过 set 方法反射设置进去，如果容器中没有，则先创建被注入对象 Bean 实例(完成整个生命周期)后，再进行注入操作</li><li>注入双向对象引用属性时，就比较复杂了，涉及了循环引用(循环依赖)问题。</li></ul><h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>Spring 提供了<strong>三级缓存</strong>存储 ==完整Bean实例== 和 ==半成品Bean实例== ，用于解决循环引用问题</p><p>在 DefaultListableBeanFactory 的上四级父类 DefaultSingletonBeanRegistry 中提供如下三个 Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> ... &#123; </span><br><span class="line">  <span class="comment">//1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，称之为&quot;一级缓存&quot;</span></span><br><span class="line">Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>); </span><br><span class="line">  <span class="comment">//2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，称之为&quot;二级缓存&quot; </span></span><br><span class="line">  Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>); </span><br><span class="line">  <span class="comment">//3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，称之为&quot;三级缓存&quot; </span></span><br><span class="line">  Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环依赖举例说明"><a href="#循环依赖举例说明" class="headerlink" title="循环依赖举例说明"></a>循环依赖举例说明</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>UserService 与 UserDao 实例化与初始化的顺序如下：</p><p><img src="http://cdn.leesin.fun/typora/macpro/img/Snipaste_2023-05-05_11-51-24.png" alt="Snipaste_2023-05-05_11-51-24"></p><p>UserService 和 UserDao 循环依赖的过程结合上述三级缓存描述一下：</p><ol><li>UserService 实例化对象，但尚未初始化，将 UserService 存储到三级缓存;</li><li>UserService 属性注入，需要 UserDao，从缓存中获取，但是缓存没有 UserDao，所以先执行UserDao的生命周期;<br>   2.1. UserDao 实例化对象，但尚未初始化，将 UserDao 存储到到三级缓存;<br> 2.2. UserDao 属性注入，需要 UserService，从三级缓存获取 UserService，UserService 从三级缓存移入二级缓存;<br> 2.3. UserDao 执行其他生命周期过程，最终成为一个完成 Bean，存储到一级缓存，删除二三级缓存;</li><li>UserService 注入 UserDao;</li><li>UserService执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存。</li></ol><h3 id="常用的Aware接口"><a href="#常用的Aware接口" class="headerlink" title="常用的Aware接口"></a>常用的Aware接口</h3><p>Aware 接口是一种框架辅助属性注入的一种思想，其他框架中也可以看到类似的接口。框架具备高度封装性，我们接触到的一般都是业务代码，一个底层功能 API 不能轻易的获取到，但是这不意味着永远用不到这些对象，如果用到了 ，就可以使用框架提供的类似 Aware 的接口，让框架给我们注入该对象。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Aware接口</th><th style="text-align:center">回调方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">ServletContextAware</td><td style="text-align:center">setServletContext(ServletContext context)</td><td style="text-align:center">Spring框架回调方法注入ServletContext对象 web环境下才生效</td></tr><tr><td style="text-align:center">BeanFactoryAware</td><td style="text-align:center">setBeanFactory(BeanFactory factory)</td><td style="text-align:center">Spring框架回调方法注入beanFactory对象</td></tr><tr><td style="text-align:center">BeanNameAware</td><td style="text-align:center">setBeanName(String beanName)</td><td style="text-align:center">Spring框架回调方法注入当前Bean在容器中 的beanName</td></tr><tr><td style="text-align:center">ApplicationContextAware</td><td style="text-align:center">setApplicationContext(ApplicationContext applicationContext)</td><td style="text-align:center">Spring框架回调方法注入applicationContext 对象</td></tr></tbody></table></div><p>举例如下：</p><p>自定义一个 Pig 类，实现 Aware 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pig</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, BeanNameAware, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        System.out.println(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 Pig</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myPigPig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.domain.Pig&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPigPig</span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory@6b2fad11: defining beans [myPigPig]; root of factory hierarchy</span><br><span class="line">org.springframework.context.support.ClassPathXmlApplicationContext@4fca772d, started on Fri May 05 13:57:07 CST 2023</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring后处理器</title>
      <link href="/post/27.html"/>
      <url>/post/27.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring的后处理器⭐⭐⭐"><a href="#Spring的后处理器⭐⭐⭐" class="headerlink" title="Spring的后处理器⭐⭐⭐"></a>Spring的后处理器⭐⭐⭐</h1><p>Spring 的后处理器是 Spring 对外开发的重要扩展点，允许我们介入到 Bean 的整个实例化流程中来，以达到==动态注册  BeanDefinition==，==动态修改 BeanDefinition==，以及==动态修改 Bean== 的作用。Spring 主要有两种后处理器：</p><ul><li>BeanFactoryPostProcessor：Bean 工厂后处理器，在 BeanDefinitionMap 填充完毕，Bean 实例化之前执行； </li><li>BeanPostProcessor：Bean 后处理器，一般在 Bean 实例化之后，填充到单例池 singletonObjects 之前执行。</li></ul><h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>Bean 工厂后处理器：BeanFactoryPostProcessor 是一个接口规范，实现了该接口的类只要交由 Spring 管理，Spring 就会回调该接口的方法。通常用于==对 BeanDefinition 进行注册/修改==。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123; </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-BeanDefinition-练习"><a href="#修改-BeanDefinition-练习" class="headerlink" title="修改 BeanDefinition 练习"></a>修改 BeanDefinition 练习</h3><p>目的：修改 BeanDefinition ，将 Cat 改为 Dog</p><p>Cat.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dog.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只注入 Cat --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.animal.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入自定义的 Bean 工厂后处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.processor.MyBeanFactoryPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>自定义的 Bean 工厂后处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 通过 beanFactory 拿到 Cat 的 beanDefinition</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        <span class="comment">// 将 beanDefinition 的 ClassName 修改为 Dog 的</span></span><br><span class="line">        beanDefinition.setBeanClassName(<span class="string">&quot;com.lyf.animal.Dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cat</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        System.out.println(cat);<span class="comment">//控制台打印：com.lyf.animal.Dog@59494225</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册-BeanDefinition-练习1"><a href="#注册-BeanDefinition-练习1" class="headerlink" title="注册 BeanDefinition 练习1"></a>注册 BeanDefinition 练习1</h3><p>目的：配置文件不注入 Dog ，而是通过 Bean 工厂后处理器来注册一个 BeanDefiniton，最终实现 Spring 帮我们管理 Dog</p><p>Dog.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注入自定义的 Bean 工厂后处理器--&gt;</span><br><span class="line">&lt;bean class=<span class="string">&quot;com.lyf.processor.MyBeanFactoryPostProcessor&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>自定义的 Bean 工厂后处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// beanFactory 的实现类其实是 DefaultListableBeanFactory</span></span><br><span class="line">        System.out.println(beanFactory.getClass().getSimpleName());<span class="comment">// 控制台输出 DefaultListableBeanFactory</span></span><br><span class="line">        <span class="comment">// 生成一个 BeanDefinition</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">dogDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        dogDefinition.setBeanClassName(<span class="string">&quot;com.lyf.animal.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 进行注册操作</span></span><br><span class="line">        ((DefaultListableBeanFactory)beanFactory).registerBeanDefinition(<span class="string">&quot;dog&quot;</span>, dogDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> context.getBean(Dog.class);</span><br><span class="line">        System.out.println(dog); <span class="comment">// 控制台输出 com.lyf.animal.Dog@cb644e</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>Spring 提供了一个 BeanFactoryPostProcessor 的子接口 BeanDefinitionRegistryPostProcessor 专门用于注册  BeanDefinition 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册-BeanDefinition-练习2"><a href="#注册-BeanDefinition-练习2" class="headerlink" title="注册 BeanDefinition 练习2"></a>注册 BeanDefinition 练习2</h3><p>目的：和上一个练习的一样</p><p>Dog.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注入自定义的 Bean 工厂后处理器--&gt;</span><br><span class="line">&lt;bean class=<span class="string">&quot;com.lyf.processor.MyBeanFactoryPostProcessor2&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>自定义的 Bean 工厂后处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor2</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">dogDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(<span class="string">&quot;com.lyf.animal.Dog&quot;</span>);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;dog&quot;</span>, dogDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> context.getBean(Dog.class);</span><br><span class="line">        System.out.println(dog); <span class="comment">// 控制台输出 com.lyf.animal.Dog@56ef9176</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="探讨执行顺序"><a href="#探讨执行顺序" class="headerlink" title="探讨执行顺序"></a>探讨执行顺序</h3><p>如果同时配置了 BeanFactoryPostProcessor 和它的子接口 BeanDefinitionRegistryPostProcessor，那么它们被调用顺序是怎样的？下面给出测试代码</p><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.processor.MyBeanFactoryPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.processor.MyBeanFactoryPostProcessor2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>实现父接口 BeanFactoryPostProcessor 的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父接口 BeanFactoryPostProcessor 的 postProcessBeanFactory方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现子接口 BeanDefinitionRegistryPostProcessor 的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor2</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子接口 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子接口 BeanDefinitionRegistryPostProcessor 的 postProcessBeanFactory 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><blockquote><p>子接口 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法<br>子接口 BeanDefinitionRegistryPostProcessor 的 postProcessBeanFactory 方法<br>父接口 BeanFactoryPostProcessor 的 postProcessBeanFactory方法</p></blockquote><p>总结调用顺序：</p><blockquote><ol><li>调用子接口中特有的方法</li><li>调用子接口中继承父接口的方法</li><li>调用父接口的方法</li></ol></blockquote><h2 id="模拟-Component注解的实现"><a href="#模拟-Component注解的实现" class="headerlink" title="模拟@Component注解的实现"></a>模拟@Component注解的实现</h2><p>使用 Spring 的 BeanFactoryPostProcessor 扩展点完成自定义注解扫描，要求如下：</p><ul><li>自定义 @MyComponent 注解，使用在类上</li><li>使用资料中提供好的包扫描器工具 BaseClassScanUtils 完成指定包的类扫描</li><li>自定义 BeanFactoryPostProcessor 完成注解 @MyComponent 的解析，解析后最终被 Spring 管理。</li></ul><ol><li>MyComponent.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyComponent &#123;</span><br><span class="line">    <span class="comment">// 显示地指定 beanName</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>BaseClassScanUtils.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseClassScanUtils</span> &#123;</span><br><span class="line">    <span class="comment">//设置资源规则</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RESOURCE_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Class&gt; <span class="title function_">scanMyComponentAnnotation</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line">        <span class="comment">//创建容器存储使用了指定注解的Bean字节码对象</span></span><br><span class="line">        Map&lt;String, Class&gt; annotationClassMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//spring工具类，可以获取指定路径下的全部类</span></span><br><span class="line">        <span class="type">ResourcePatternResolver</span> <span class="variable">resourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">                    ClassUtils.convertClassNameToResourcePath(basePackage) + RESOURCE_PATTERN;</span><br><span class="line">            Resource[] resources = resourcePatternResolver.getResources(pattern);</span><br><span class="line">            <span class="comment">//MetadataReader 的工厂类</span></span><br><span class="line">            <span class="type">MetadataReaderFactory</span> <span class="variable">refractory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>(resourcePatternResolver);</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                <span class="comment">//用于读取类信息</span></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> refractory.getMetadataReader(resource);</span><br><span class="line">                <span class="comment">//扫描到的class</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> reader.getClassMetadata().getClassName();</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(classname);</span><br><span class="line">                <span class="comment">//判断是否属于指定的注解类型</span></span><br><span class="line">                <span class="keyword">if</span>(clazz.isAnnotationPresent(MyComponent.class))&#123;</span><br><span class="line">                    <span class="comment">//获得注解对象</span></span><br><span class="line">                    <span class="type">MyComponent</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(MyComponent.class);</span><br><span class="line">                    <span class="comment">//获得属value属性值</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">                    <span class="comment">//判断是否为&quot;&quot;</span></span><br><span class="line">                    <span class="keyword">if</span>(beanName!=<span class="literal">null</span>&amp;&amp;!beanName.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                        <span class="comment">//存储到Map中去</span></span><br><span class="line">                        annotationClassMap.put(beanName,clazz);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果没有为&quot;&quot;,那就把当前类的类名作为beanName</span></span><br><span class="line">                    annotationClassMap.put(clazz.getSimpleName(),clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotationClassMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Class&gt; stringClassMap = scanMyComponentAnnotation(<span class="string">&quot;com.lyf&quot;</span>);</span><br><span class="line">        System.out.println(stringClassMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>自定义的 Bean 工厂后处理器，继承 BeanDefinitionRegistryPostProcessor ，实现方法如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> <span class="string">&quot;com.lyf&quot;</span>;</span><br><span class="line">    Map&lt;String, Class&gt; map = BaseClassScanUtils.scanMyComponentAnnotation(basePackage);</span><br><span class="line">    <span class="keyword">for</span> (String beanName : map.keySet()) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(map.get(beanName));</span><br><span class="line">        registry.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置文件</li></ol><p>注入自定义的 Bean 工厂后处理器</p><ol><li>测试：给 Dog 类，Cat 类加上自定义注解 @MyComponent </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> context.getBean(Dog.class);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> context.getBean(Cat.class);</span><br><span class="line">        System.out.println(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>Bean 被实例化后，到最终缓存到名为 singletonObjects 单例池之前，中间会经过 Bean 的初始化过程，例如：属性的填充、初始方法 init 的执行等，其中有一个对外进行扩展的点 BeanPostProcessor，我们称为 Bean 后处理。跟上面的 Bean 工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的 BeanPostProcessor，会在流程节点上被 Spring 自动调用。</p><p>BeanPostProcessor 的接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">// 在属性注入完毕，init 初始化方法执行之前被回调</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">// 在初始化方法执行之后，被添加到单例池 singletonObjects 之前被回调</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接口方法执行时机"><a href="#接口方法执行时机" class="headerlink" title="接口方法执行时机"></a>接口方法执行时机</h3><p>UserDao.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao属性填充了...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao实例化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserDao初始化方法执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBeanPostProcessor.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanPostProcessor 的 before 方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanPostProcessor 的 after 方法执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;leesin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.processor.MyBeanPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UserDao实例化...</span><br><span class="line">UserDao属性填充了...</span><br><span class="line">BeanPostProcessor 的 before 方法执行了...</span><br><span class="line">UserDao初始化方法执行...</span><br><span class="line">BeanPostProcessor 的 after 方法执行了...</span><br></pre></td></tr></table></figure><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>要求如下:</p><ul><li>Bean的方法执行之前控制台打印当前时间</li><li>Bean的方法执行之后控制台打印当前时间。</li></ul><p>分析:</p><ul><li>对方法进行增强主要就是代理设计模式和包装设计模式</li><li>由于Bean方法不确定，所以使用动态代理在运行期间执行增强操作</li><li>在Bean实例创建完毕后，进入到单例池之前，使用Proxy代替真实的目标Bean</li></ul><p>UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDaoImpl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;haha...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间日志处理的BeanPostProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeLogPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">//对Bean进行动态代理，返回的是Proxy代理对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxyBean</span> <span class="operator">=</span> Proxy.newProxyInstance(bean.getClass().getClassLoader(),</span><br><span class="line">                bean.getClass().getInterfaces(),</span><br><span class="line">                (Object proxy, Method method, Object[] args) -&gt; &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始时间:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(start));</span><br><span class="line">                    <span class="comment">//执行目标方法</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(bean, args);</span><br><span class="line">                    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                    System.out.println(<span class="string">&quot;结束时间:&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(end));</span><br><span class="line">                    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> proxyBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.processor.TimeLogPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始时间:Fri May 05 10:43:54 CST 2023</span><br><span class="line">haha...</span><br><span class="line">结束时间:Fri May 05 10:43:57 CST 2023</span><br><span class="line">耗时：2017ms</span><br></pre></td></tr></table></figure><blockquote><p>注意：代理的目标Bean只能是实现了接口的对象，因为jdk提供的动态代理就是只支持这样的类型的对象的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean实例化流程</title>
      <link href="/post/26.html"/>
      <url>/post/26.html</url>
      
        <content type="html"><![CDATA[<h1 id="Bean实例化的基本流程⭐⭐⭐"><a href="#Bean实例化的基本流程⭐⭐⭐" class="headerlink" title="Bean实例化的基本流程⭐⭐⭐"></a>Bean实例化的基本流程⭐⭐⭐</h1><p>Spring 容器在进行初始化时，会将 xml 配置的的信息封装成一个 BeanDefinition 对象，所有的 BeanDefinition 存储到一个名为 beanDefinitionMap 的 Map 集合中去，Spring 框架在对该 Map 进行遍历，使用反射创建 Bean 实例对象，创建好的Bean 对象存储在一个名为 singletonObjects 的 Map 集合中，当调用 getBean 方法时，则最终从该 Map 集合中取出 Bean 实例对象返回。</p><blockquote><p>所以只要想办法将 BeanDefinition 注册到 beanDefinitionMap 中，Spring 就会进行对应的 Bean 的实例化操作</p></blockquote><p>总结基本流程：</p><ol><li>加载 xml 配置文件，解析获取配置中的每个的信息，封装成一个个的 BeanDefinition 对象; </li><li>将 BeanDefinition 存储在 beanDefinitionMap 中</li><li>ApplicationContext 底层遍历 beanDefinitionMap，创建 Bean 实例对象;</li><li>创建好的 Bean 实例对象，被存储到一个名为 singletonObjects 的 Map 中;</li><li>当执行 applicationContext.getBean(beanName) 时，从 singletonObjects 去匹配 Bean 实例返回。</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/Bean实例化的基本流程.png" alt="Bean实例化的基本流程"></p><blockquote><p>更详细/细节的流程图 请看下面的图 </p></blockquote><h2 id="流程细节升级1"><a href="#流程细节升级1" class="headerlink" title="流程细节升级1"></a>流程细节升级1</h2><p>BeanFactoryPostProcessor 在 SpringBean 的实例化过程中的体现：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/Bean实例化的基本流程2.png" alt="Bean实例化的基本流程2"></p><h2 id="流程细节升级2"><a href="#流程细节升级2" class="headerlink" title="流程细节升级2"></a>流程细节升级2</h2><p>BeanPostProcessor 在 SpringBean 的实例化过程中的体现：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/Bean实例化的基本流程3.png" alt="Bean实例化的基本流程3"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/Spring IoC整体流程.png" alt="Spring IoC整体流程"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于xml的Spring应用</title>
      <link href="/post/25.html"/>
      <url>/post/25.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBean-的配置详解"><a href="#SpringBean-的配置详解" class="headerlink" title="SpringBean 的配置详解"></a>SpringBean 的配置详解</h1><div class="table-container"><table><thead><tr><th style="text-align:center">Xml配置方式</th><th style="text-align:center">功能描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</code></td><td style="text-align:center">Bean的id和全限定名配置</td></tr><tr><td style="text-align:center"><code>&lt;bean name=&quot;alias1,alias2&quot;&gt;</code></td><td style="text-align:center">通过name设置Bean的别名，通过别名也能直接获取到Bean实例。别名可以有多个，用逗号隔开</td></tr><tr><td style="text-align:center"><code>&lt;bean scope=&quot;&quot;&gt;</code></td><td style="text-align:center">Bean的作用范围，BeanFactory作为容器时取值singleton和prototype。<strong>默认值singleton</strong></td></tr><tr><td style="text-align:center"><code>&lt;bean lazy-init=&quot;&quot;&gt;</code></td><td style="text-align:center">Bean的实例化时机，是否延迟加载。BeanFactory作为容器时无效</td></tr><tr><td style="text-align:center"><code>&lt;bean init-method=&quot;&quot;&gt;</code></td><td style="text-align:center">Bean实例化后自动执行的初始化方法，method指定方法名</td></tr><tr><td style="text-align:center"><code>&lt;bean destroy-method=&quot;&quot;&gt;</code></td><td style="text-align:center">Bean实例销毁前的方法，method指定方法名</td></tr><tr><td style="text-align:center"><code>&lt;bean autowire=&quot;byType&quot;&gt;</code></td><td style="text-align:center">设置自动注入模式，常用的有按照类型byType，按照名字byName</td></tr><tr><td style="text-align:center"><code>&lt;bean factory-bean=&quot;&quot; factory-method=&quot;&quot;/&gt;</code></td><td style="text-align:center">指定哪个工厂Bean的哪个方法完成Bean的创建</td></tr></tbody></table></div><h2 id="Bean的id和name"><a href="#Bean的id和name" class="headerlink" title="Bean的id和name"></a>Bean的id和name</h2><h3 id="情况1：配置了-Bean-的-id，那么-beanName-就为-id"><a href="#情况1：配置了-Bean-的-id，那么-beanName-就为-id" class="headerlink" title="情况1：配置了 Bean 的 id，那么 beanName 就为 id"></a>情况1：配置了 Bean 的 id，那么 beanName 就为 id</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面这段代码是可以拿到 Bean 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(userService); <span class="comment">// 拿得到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/beanName1.png" alt="beanName1"></p><h3 id="情况2：没配置-Bean-的-id，那么-BeanName-默认为类的全限定名，即-com-lyf-service-impl-UserServiceImpl"><a href="#情况2：没配置-Bean-的-id，那么-BeanName-默认为类的全限定名，即-com-lyf-service-impl-UserServiceImpl" class="headerlink" title="情况2：没配置 Bean 的 id，那么 BeanName 默认为类的全限定名，即 com.lyf.service.impl.UserServiceImpl"></a>情况2：没配置 Bean 的 id，那么 BeanName 默认为类的全限定名，即 com.lyf.service.impl.UserServiceImpl</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面这段代码是可以拿到 Bean 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// System.out.println(context.getBean(&quot;userService&quot;)); // 拿不到</span></span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span>)); <span class="comment">// 拿得到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/beanName2.png" alt="beanName2"></p><h4 id="情况3：可以为当前-Bean-指定多个别名，根据别名也可以获得-Bean-对象"><a href="#情况3：可以为当前-Bean-指定多个别名，根据别名也可以获得-Bean-对象" class="headerlink" title="情况3：可以为当前 Bean 指定多个别名，根据别名也可以获得 Bean 对象"></a>情况3：可以为当前 Bean 指定多个别名，根据别名也可以获得 Bean 对象</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;aaa,bbb,ccc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面这段代码是都可以拿到 Bean 的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;userService&quot;</span>)); <span class="comment">// 拿得到</span></span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;aaa&quot;</span>)); <span class="comment">// 拿得到</span></span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;bbb&quot;</span>)); <span class="comment">// 拿得到</span></span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;ccc&quot;</span>)); <span class="comment">// 拿得到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/beanName3.png" alt="beanName3"></p><blockquote><p>Debug模式下，寻找BeanName和Bean的键值对。</p><p>applicationContext -&gt; beanFactory -&gt; singleonObjects -&gt; table</p><p>applicationContext -&gt; beanFactory -&gt; aliasMap -&gt; table</p></blockquote><h2 id="Bean的范围"><a href="#Bean的范围" class="headerlink" title="Bean的范围"></a>Bean的范围</h2><p>默认情况下，单纯的 Spring 环境 Bean 的作用范围有两个：Singleton和Prototype </p><ul><li>singleton：单例，默认值，Spring 容器创建的时候，就会进行 Bean 的实例化，并存储到容器内部的单例池中 ，每次 getBean 时都是从单例池中获取相同的 Bean 实例。</li><li>prototype：原型，Spring 容器初始化时不会创建Bean实例，当调用 getBean 时才会实例化 Bean，每次 getBean 都会创建一个新的 Bean 实例。</li></ul><h2 id="Bean的延迟加载"><a href="#Bean的延迟加载" class="headerlink" title="Bean的延迟加载"></a>Bean的延迟加载</h2><p>lazy-init 默认值 false</p><p>当 lazy-init 设置为 true 时为延迟加载，也就是当 Spring 容器创建的时候，不会立即创建 Bean 实例，等待用到时在创建 Bean 实例并存储到单例池中去，后续在使用该 Bean 直接从单例池获取即可，本质上该 Bean 还是单例的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在《【Spring基础】BeanFactory与ApplicationContext》的《2.3.BeanFactory与ApplicationContext的关系》中已经证明了</p><blockquote><p><strong>Bean的初始化时机不同</strong>，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好。</p></blockquote><p>所以 lazy-init 属性是针对 ApplicationContext 的，并不会对 BeanFactory 生效。</p><p>（测试在之前的文章写的比较详细，这里就不再debug测试）</p></blockquote><h2 id="Bean的init-method和destroy-method"><a href="#Bean的init-method和destroy-method" class="headerlink" title="Bean的init-method和destroy-method"></a>Bean的init-method和destroy-method</h2><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;实例化...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;init...&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;destroy...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        ((ClassPathXmlApplicationContext)context).close();<span class="comment">// 显式关闭容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例化…<br>init…<br>destroy…</p></blockquote><h2 id="Bean的实例化配置⭐⭐⭐"><a href="#Bean的实例化配置⭐⭐⭐" class="headerlink" title="Bean的实例化配置⭐⭐⭐"></a>Bean的实例化配置⭐⭐⭐</h2><p>Spring的实例化方式主要如下两种： </p><ol><li>构造方式实例化：底层通过构造方法对Bean进行实例化</li><li>工厂方式实例化：底层通过调用自定义的工厂方法对Bean进行实例化</li></ol><h3 id="构造方式实例化"><a href="#构造方式实例化" class="headerlink" title="构造方式实例化"></a>构造方式实例化</h3><p>构造方式实例化 Bean 又分为无参构造方法实例化和有参构造方法实例化，Spring 中配置的几乎都是无参构造该方式，此处不在赘述。下面举例有参构造方法实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(String userName)</span> &#123;<span class="comment">//有参构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户名是&quot;</span> + userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有参构造在实例化 Bean 时，需要参数的注入，通过<code>&lt;constructor-arg&gt;</code>标签，嵌入在<code>&lt;bean&gt;</code>标签内部提供构造参数，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="工厂方式实例化"><a href="#工厂方式实例化" class="headerlink" title="工厂方式实例化"></a>工厂方式实例化</h3><p>工厂方式实例化Bean，又分为如下三种：</p><ol><li>静态工厂方法实例化Bean</li><li>实例工厂方法实例化Bean</li><li>实现FactoryBean规范延迟实例化Bean</li></ol><h4 id="静态工厂方法实例化Bean"><a href="#静态工厂方法实例化Bean" class="headerlink" title="静态工厂方法实例化Bean"></a>静态工厂方法实例化Bean</h4><p>Bean类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.factory.MyBeanFactory1&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;userService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;userService&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例工厂方法实例化Bean"><a href="#实例工厂方法实例化Bean" class="headerlink" title="实例工厂方法实例化Bean"></a>实例工厂方法实例化Bean</h4><p>工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanFactory2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.factory.MyBeanFactory2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;myBeanFactory2&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;userService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;userService&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/实例BeanFactory创建Bean.png" alt="实例BeanFactory创建Bean"></p><blockquote><p>静态工厂方法实例化Bean：不会创建工厂对象</p><p>实例工厂方法实例化Bean：会创建工厂对象，且存在 singletonObjects 中</p></blockquote><h4 id="实现FactoryBean规范延迟实例化Bean"><a href="#实现FactoryBean规范延迟实例化Bean" class="headerlink" title="实现FactoryBean规范延迟实例化Bean"></a>实现FactoryBean规范延迟实例化Bean</h4><p>工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory3</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserService&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserServiceImpl被创建了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserService.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lyf.factory.MyBeanFactory3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>继承了Spring的FactoryBean接口，就不用像之前一样了，配置方式有点改动。</p></blockquote><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;userService&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点调试，验证延迟实例化Bean</p><ol><li>当 applicationContext 被创建时，控制台没有任何输出，说明 UserServiceImpl 实例还没被创建。此时，singleObjects 中 userService 对应的值是他的工厂 MyBeanFactory3。</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/MyBeanFactory3调试1.png" alt="MyBeanFactory3调试1"></p><blockquote><p>这种方式下，context -&gt; beanFactory -&gt; singletonObjects -&gt; table 中，userService 对应的居然不是 UserServiceImpl，而是他的工厂类 MyBeanFactory3</p></blockquote><ol><li>当调用了 <code>context.getBean(&quot;userService&quot;)</code> 时，控制台才打印了 <code>UserServiceImpl被创建了...</code> ，说明这种方式真的可以延迟实例化 Bean。</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/MyBeanFactory3调试2.png" alt="MyBeanFactory3调试2"></p><blockquote><p>原来，这种方式下，真正的 UserServiceImpl 实例存储在 context -&gt; beanFactory -&gt; factoryBeanObjectCache -&gt; table 中了</p></blockquote><h2 id="Bean的实例化配置练习⭐⭐⭐"><a href="#Bean的实例化配置练习⭐⭐⭐" class="headerlink" title="Bean的实例化配置练习⭐⭐⭐"></a>Bean的实例化配置练习⭐⭐⭐</h2><h3 id="练习1：构造方式实例化"><a href="#练习1：构造方式实例化" class="headerlink" title="练习1：构造方式实例化"></a>练习1：构造方式实例化</h3><p>配置 Druid 数据源交由 Spring 管理</p><ol><li>导入坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>原来的方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">dataSource.setUrl(<span class="string">&quot;jdbc://localhost:3306/test&quot;</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>spring 管理的方式</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;datasource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        System.out.println(context.getBean(<span class="string">&quot;datasource&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2：静态工厂方法实例化"><a href="#练习2：静态工厂方法实例化" class="headerlink" title="练习2：静态工厂方法实例化"></a>练习2：静态工厂方法实例化</h3><p>配置 Connection 交由 Spring 管理</p><ol><li>导入坐标：和练习1的一样</li><li>原来的方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Connection&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">System.out.println(conn);</span><br></pre></td></tr></table></figure><ol><li>spring 管理的方式</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.Class&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;forName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;className&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Connection&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.sql.DriverManager&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getConnection&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> (Connection) context.getBean(<span class="string">&quot;conn&quot;</span>);</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3：实例工厂方法实例化"><a href="#练习3：实例工厂方法实例化" class="headerlink" title="练习3：实例工厂方法实例化"></a>练习3：实例工厂方法实例化</h3><p>配置日期对象交由Spring管理</p><p>原始代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">currentTimeStr</span> <span class="operator">=</span> <span class="string">&quot;2023-08-27 07:20:00&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> simpleDateFormat.parse(currentTimeStr);</span><br><span class="line">System.out.println(date);</span><br></pre></td></tr></table></figure><p>spring 管理的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sdf相当于是一个工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.text.SimpleDateFormat&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDate&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;sdf&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;parse&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;source&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2023-08-27 07:20:00&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, ParseException &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> context.getBean(Date.class);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习4：综合"><a href="#练习4：综合" class="headerlink" title="练习4：综合"></a>练习4：综合</h3><p>配置MyBatis的SqlSessionFactory交由Spring管理</p><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis框架--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原始代码</p><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载mybatis核心配置文件，使用Spring静态工厂方式</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="comment">//创建SqlSessionFactoryBuilder对象，使用Spring无参构造方式</span></span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="comment">//调用SqlSessionFactoryBuilder的build方法，使用Spring实例工厂方式</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> builder.build(in);</span><br><span class="line">System.out.println(sqlSessionFactory);</span><br></pre></td></tr></table></figure><p>spring 管理方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--静态工厂方法实例化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;in&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.ibatis.io.Resources&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getResourceAsStream&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;resource&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--相当于是一个实例工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;builder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.ibatis.session.SqlSessionFactoryBuilder&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--实例工厂方法实例化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;builder&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;inputStream&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;in&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> context.getBean(SqlSessionFactory.class);</span><br><span class="line">        System.out.println(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的依赖注入配置"><a href="#Bean的依赖注入配置" class="headerlink" title="Bean的依赖注入配置"></a>Bean的依赖注入配置</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanFactory与ApplicationContext</title>
      <link href="/post/24.html"/>
      <url>/post/24.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Framework-技术栈图示"><a href="#Spring-Framework-技术栈图示" class="headerlink" title="Spring Framework 技术栈图示"></a>Spring Framework 技术栈图示</h1><p><img src="http://cdn.leesin.fun/typora/s3/img/Spring Framework 技术栈图示.png" alt="Spring Framework 技术栈图示"></p><p>在maven中导入spring-context坐标，就会自动导入Aop、Beans、Core、SpEl</p><p><img src="http://cdn.leesin.fun/typora/s3/img/引入spring-context包.png" alt="引入spring-context包"></p><h1 id="BeanFactory-和ApplicationContext"><a href="#BeanFactory-和ApplicationContext" class="headerlink" title="BeanFactory 和ApplicationContext"></a>BeanFactory 和ApplicationContext</h1><h2 id="BeanFactory使用示例"><a href="#BeanFactory使用示例" class="headerlink" title="BeanFactory使用示例"></a>BeanFactory使用示例</h2><ol><li>导入Spring的jar包或Maven坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>定义UserService接口及其UserServiceImpl实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建beans.xml配置文件，将UserServiceImpl的信息配置到该xml中</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/新建beans.xml.png" alt="新建beans.xml"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> class=<span class="string">&quot;com.lyf.service.impl.UserServiceImpl&quot;</span>&gt; &lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol><li>编写测试代码，创建BeanFactory，加载配置文件，获取UserService实例对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 BeanFactory</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// 创建读取器</span></span><br><span class="line">    <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    reader.loadBeanDefinitions(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取 Bean 实例对象</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    System.out.println(userService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ApplicationContext使用示例"><a href="#ApplicationContext使用示例" class="headerlink" title="ApplicationContext使用示例"></a>ApplicationContext使用示例</h2><p>ApplicationContext 称为Spring容器，内部封装了BeanFactory，比BeanFactory功能更丰富更强大，使用 ApplicationContext 进行开发时，xml配置文件的名称习惯写成applicationContext.xml</p><p>测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 ApplicationContext ,加载配置文件，实例化容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//根据 beanName 获得容器中的 Bean 实例</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    System.out.println(userService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanFactory与ApplicationContext的关系"><a href="#BeanFactory与ApplicationContext的关系" class="headerlink" title="BeanFactory与ApplicationContext的关系"></a>BeanFactory与ApplicationContext的关系</h2><ol><li><p>BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为 Spring 容器；</p></li><li><p>ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的 API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装； </p></li><li><p>Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且 ApplicationContext内部还维护着BeanFactory的引用，所以，ApplicationContext与BeanFactory既有继承关系，又有融合关系。</p></li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/ApplicationContext继承体系图.png" alt="ApplicationContext继承体系图"></p><ol><li><strong>Bean的初始化时机不同</strong>，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好。</li></ol><p>验证 BeanFactory 和 ApplicationContext 对 Bean 的初始化时机，在 UserServiceImpl 的无参构造内打印一句话，验证构造方法的执行时机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserServiceImpl创建了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点调试，测试 BeanFactory 创建 Bean的时机</p><p><img src="http://cdn.leesin.fun/typora/s3/img/测试BeanFactory创建Bean时机1.png" alt="测试BeanFactory创建Bean时机1"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/测试BeanFactory创建Bean时机2.png" alt="测试BeanFactory创建Bean时机2"></p><p>断点调试，测试 ApplicationContext 创建 Bean的时机</p><p><img src="http://cdn.leesin.fun/typora/s3/img/测试ApplicationContext创建Bean时机.png" alt="测试ApplicationContext创建Bean时机"></p><p>结论：BeanFactory 方式时，当调用getBean方法时才会把需要的 Bean 实例创建，即延迟加载；而 ApplicationContext 是加载配置文件，容器创建时就将所有的Bean实例都创建好了，存储到一个单例池中，当调用 getBean 时直接从单例池中获取Bean实例返回</p><h2 id="BeanFactory的继承体系"><a href="#BeanFactory的继承体系" class="headerlink" title="BeanFactory的继承体系"></a>BeanFactory的继承体系</h2><p>BeanFactory 是核心接口，项目运行过程中肯定有具体实现参与，这个具体实现就是 <strong>DefaultListableBeanFactory</strong> ，而 ApplicationContext 内部维护的 Beanfactory 的实现类也是它</p><p><img src="http://cdn.leesin.fun/typora/s3/img/BeanFactory继承体系图.png" alt="BeanFactory继承体系图"></p><h2 id="ApplicationContext的继承体系"><a href="#ApplicationContext的继承体系" class="headerlink" title="ApplicationContext的继承体系"></a>ApplicationContext的继承体系</h2><p>只在 Spring 基础环境下，即只导入 spring-context 坐标时，此时 ApplicationContext 的继承体系</p><p><img src="http://cdn.leesin.fun/typora/s3/img/ApplicationContext继承体系图2.png" alt="ApplicationContext继承体系图2"></p><p>只在Spring基础环境下，常用的三个ApplicationContext作用如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">实现类</th><th style="text-align:center">功能描述</th></tr></thead><tbody><tr><td style="text-align:center">ClassPathXmlApplicationContext</td><td style="text-align:center">加载类路径下的xml配置的ApplicationContext</td></tr><tr><td style="text-align:center">FileSystemXmlApplicationContext</td><td style="text-align:center">加载磁盘路径下的xml配置的ApplicationContext</td></tr><tr><td style="text-align:center">AnnotationConfigApplicationContext</td><td style="text-align:center">加载注解配置类的ApplicationContext</td></tr></tbody></table></div><p>如果 Spring 基础环境中加入了其他组件解决方案，如 web 层解决方案，即导入 spring-web 坐标，此时 ApplicationContext 的继承体系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/ApplicationContext继承体系图（Web环境）.png" alt="ApplicationContext继承体系图（Web环境）"></p><p>在Spring的web环境下，常用的两个ApplicationContext作用如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">实现类</th><th style="text-align:center">功能描述</th></tr></thead><tbody><tr><td style="text-align:center">XmlWebApplicationContext</td><td style="text-align:center">web环境下，加载类路径下的xml配置的ApplicationContext</td></tr><tr><td style="text-align:center">AnnotationConfigWebApplicationContext</td><td style="text-align:center">web环境下，加载磁盘路径下的xml配置的ApplicationContext</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoC、DI、AOP</title>
      <link href="/post/23.html"/>
      <url>/post/23.html</url>
      
        <content type="html"><![CDATA[<h1 id="IoC、DI和AOP思想提出"><a href="#IoC、DI和AOP思想提出" class="headerlink" title="IoC、DI和AOP思想提出"></a>IoC、DI和AOP思想提出</h1><h2 id="IoC-Inversion-of-Control"><a href="#IoC-Inversion-of-Control" class="headerlink" title="IoC (Inversion of Control)"></a>IoC (Inversion of Control)</h2><p>IoC思想：翻译为“控制反转”或“反转控制”，强调的是原来在程序中创建Bean的权利反转给第三方。</p><p>例如：原来在程序中手动的去 <code>new UserServiceImpl()</code>，手动的去<code>new UserDaoImpl()</code>，而根据IoC思想的指导， 寻求一个第三方去创建UserServiceImpl对象和UserDaoImpl对象。这样程序与具体对象就失去的直接联系。</p><p>谁去充当第三方角色呢？ </p><p>​        <strong>工厂设计模式</strong>，BeanFactory来充当第三方的角色，来产生Bean实例 </p><p>BeanFactory怎么知道产生哪些Bean实例呢？ </p><p>​        可以使用配置文件配置Bean的基本信息，BeanFactory根据配置文件来生产Bean实例</p><p><img src="http://cdn.leesin.fun/typora/s3/img/BeanFactory框架图.png" alt="BeanFactory框架图"></p><p>例如，用IoC思想去反转UserServiceImpl的创建权，由原来程序中创建反转给通过BeanFactory去创建</p><p><img src="http://cdn.leesin.fun/typora/s3/img/IoC 例子.png" alt="IoC 例子"></p><h2 id="DI-Dependency-Injection"><a href="#DI-Dependency-Injection" class="headerlink" title="DI (Dependency Injection)"></a>DI (Dependency Injection)</h2><p>上面使用BeanFactory的方式已经实现的”控制反转”，将Bean的创建权交给了BeanFactory，如果我们想将 UserDao的创建权也反转给BeanFactory，与此同时UserService内部还需要用到UserDao实例对象，那应该怎样操作呢？</p><p>​        1）在程序中，通过BeanFactory获得UserService </p><p>​        2）在程序中，通过BeanFactory获得UserDao</p><p>​        3）在程序中，将UserDao设置给UserService</p><p><img src="http://cdn.leesin.fun/typora/s3/img/依赖注入例子.png" alt="依赖注入例子"></p><h2 id="AOP-Aspect-Oriented-Programming"><a href="#AOP-Aspect-Oriented-Programming" class="headerlink" title="AOP (Aspect Oriented Programming)"></a>AOP (Aspect Oriented Programming)</h2><p>AOP，面向切面编程，是对面向对象编程OOP的升华。</p><p>OOP是纵向对一个事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。</p><p>而AOP是横向的对不同事物的抽象，属性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】力扣101（对称二叉树）</title>
      <link href="/post/22.html"/>
      <url>/post/22.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="对称二叉树示例1"></p><p>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="对称二叉树示例2"></p><p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><p>提示：</p><pre><code>树中节点数目在范围 [1, 1000] 内-100 &lt;= Node.val &lt;= 100</code></pre><h1 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSame(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(TreeNode node1, TreeNode node2)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node1.val != node2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="keyword">return</span> isSame(node1.left, node2.right) &amp;&amp; isSame(node1.right, node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二：层序遍历"><a href="#解法二：层序遍历" class="headerlink" title="解法二：层序遍历"></a>解法二：层序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 因为题目说了：-100 &lt;= Node.val &lt;= 100</span></span><br><span class="line">                    <span class="comment">// 所以这里取巧，让空节点的值为111</span></span><br><span class="line">                    list.add(<span class="number">111</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(cur.val);</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isSymmetric(list)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(low++) != list.get(high--))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】二叉树的最大深度和最小深度</title>
      <link href="/post/21.html"/>
      <url>/post/21.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><blockquote><p>示例：给定二叉树 [3,9,20,null,null,15,7]，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回它的最大深度 3 。</p></blockquote><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            level ++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><blockquote><p>示例：给定二叉树 [3,9,20,null,null,15,7]，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回它的最小深度 2 。</p></blockquote><h2 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left_depth</span> <span class="operator">=</span> Integer.MAX_VALUE, right_depth = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) left_depth = dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) right_depth = dfs(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.min(left_depth, right_depth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 找到叶子节点直接可以返回了</span></span><br><span class="line">                <span class="keyword">if</span> (isLeaf(cur)) <span class="keyword">return</span> level;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此题用BFS可能效率高。不用遍历所有的结点，就能找到答案。只要找到一个叶子节点，就可以返回了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】树的非递归遍历</title>
      <link href="/post/20.html"/>
      <url>/post/20.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>⭐</p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a>⭐</p><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>⭐⭐⭐</p><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) stack.push(cur.right);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) stack.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) stack.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) stack.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】力扣347（前K个高频元素）</title>
      <link href="/post/19.html"/>
      <url>/post/19.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br><span class="line"></span><br><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><h1 id="解法一：小根堆"><a href="#解法一：小根堆" class="headerlink" title="解法一：小根堆"></a>解法一：小根堆</h1><p>小根堆解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用map来计数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 空间O(n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 时间O(n)</span></span><br><span class="line">            countMap.put(nums[i], countMap.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; keySet = countMap.keySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小根堆, 空间O(k)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2) -&gt; pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">for</span> (Integer num : keySet) &#123;<span class="comment">// 时间O(n)</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;key=&quot; + num + &quot; value=&quot; + countMap.get(num));</span></span><br><span class="line">            <span class="keyword">if</span> (q.size() &lt; k) &#123;<span class="comment">// 先将k个元素放入小根堆</span></span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num, countMap.get(num)&#125;); <span class="comment">// 时间O(logk)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (countMap.get(num) &gt; q.peek()[<span class="number">1</span>]) &#123;</span><br><span class="line">                    q.poll();<span class="comment">// 时间O(logk)</span></span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num, countMap.get(num)&#125;);<span class="comment">// 时间O(logk)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] pair : q) &#123;</span><br><span class="line">            res[idx++] = pair[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂性分析"><a href="#复杂性分析" class="headerlink" title="复杂性分析"></a>复杂性分析</h1><blockquote><p>时间复杂度：O(Nlog⁡k)，其中 N 为数组的长度。我们首先遍历原数组，并使用哈希表记录出现次数，每个元素需要 O(1) 的时间，共需 O(N) 的时间。随后，我们遍历「出现次数数组」，由于堆的大小至多为 k，因此每次堆操作需要 O(log⁡k) 的时间，共需 O(Nlog⁡k)的时间。二者之和为 O(Nlogk)。</p><p>空间复杂度：O(N)。哈希表的大小为 O(N)，而堆的大小为 O(k)，共计为 O(N)。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】力扣239（滑动窗口最大值）</title>
      <link href="/post/18.html"/>
      <url>/post/18.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length; <span class="comment">// 原数组的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - k + <span class="number">1</span>; <span class="comment">// 结果数组的长度</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//单调递减队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// =================初始化单调递减队列：先将前k的元素放入队列===============</span></span><br><span class="line">        q.offerLast(nums[<span class="number">0</span>]); <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; nums[i] &gt; q.peekLast()) &#123; <span class="comment">// 如果想要入队的元素比队尾元素还要大</span></span><br><span class="line">                q.pollLast(); <span class="comment">// 那么就让队尾元素出队</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.offerLast(nums[i]); <span class="comment">// 此时可以入队了</span></span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = q.peekFirst(); <span class="comment">// 队首元素一定是最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// =================开始遍历数组===============</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i-k] == q.peekFirst()) &#123; <span class="comment">// 如果上一个窗口的第一个元素与队首元素相同</span></span><br><span class="line">                q.pollFirst(); <span class="comment">// 那么就让他出队</span></span><br><span class="line">            &#125; <span class="comment">// 否则什么也不做，因为上个窗口的第一个元素不是最大值的话，那么肯定已经不再队列中了。</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; nums[i] &gt; q.peekLast()) &#123; <span class="comment">// 如果想要入队的元素比队尾元素还要大</span></span><br><span class="line">                q.pollLast(); <span class="comment">// 那么就让队尾元素出队</span></span><br><span class="line">            &#125;</span><br><span class="line">            q.offerLast(nums[i]); <span class="comment">// 此时可以入队了</span></span><br><span class="line">            res[i - k + <span class="number">1</span>] = q.peekFirst(); <span class="comment">// 队首元素一定是最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上是我自己写的，看了官方题解的代码后，发现和我写的差不多<code>^_^</code></p><p>如果用暴力来解答，时间复杂度是O(n*k)，会超时的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法】力扣142（环形链表II）</title>
      <link href="/post/17.html"/>
      <url>/post/17.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://leetcode.cn/problems/3sum">https://leetcode.cn/problems/3sum</a></p><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p><p>你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><blockquote><p>示例 1：<br>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。</p><p>示例 2：<br>输入：nums = [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。</p><p>示例 3：<br>输入：nums = [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。</p></blockquote><h1 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n-<span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为nums已经有序，如果首个元素已经大于0，直接退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去重1</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">targer</span> <span class="operator">=</span> -nums[i]; <span class="comment">// 两数之和的目标值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> i + <span class="number">1</span>, high = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[low] + nums[high]; </span><br><span class="line">                <span class="keyword">if</span> (sum &gt; targer) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; targer) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[low], nums[high]));</span><br><span class="line">                    low ++;</span><br><span class="line">                    high --;</span><br><span class="line">                    <span class="comment">// 去重2</span></span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == nums[low-<span class="number">1</span>]) low++;</span><br><span class="line">                    <span class="comment">// 去重3</span></span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == nums[high+<span class="number">1</span>]) high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>去重1：</p><p>​    如果输入是[-1,0,1,2,-1,-4]，排序后[-4,-1,-1,0,1,2]，当外层循环遍历到第一个-1时，找到符合条件的三元组[-1,0,1]</p><p>如果遍历到第二个-1时，不执行跳过语句，就会输出重复三元组[-1,0,1]</p><p>去重2和去重3：</p><p>​    如果输入的是[-2,0,0,2,2]，当外层执行到-2，里层的low=1，high=4，此时三元组[-2,0,2]符合条件。</p><p>此时low=2，high=3。如果没有去重2和去重3，那么此时的low和high又符合条件，三元组[-2,0,2]会被重复输出。</p></blockquote><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis哨兵集群</title>
      <link href="/post/15.html"/>
      <url>/post/15.html</url>
      
        <content type="html"><![CDATA[<p>上一节讲到了redis的主从集群，那么思考一个问题：slave节点宕机恢复后可以找master节点同步数据，那master节点宕机怎么办？</p><h1 id="1-集群结构和作用"><a href="#1-集群结构和作用" class="headerlink" title="1.集群结构和作用"></a>1.集群结构和作用</h1><p>哨兵的结构如图：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725154528072.png" alt="image-20210725154528072"></p><p>哨兵的作用如下：</p><ul><li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><h1 id="2-集群监控原理"><a href="#2-集群监控原理" class="headerlink" title="2.集群监控原理"></a>2.集群监控原理</h1><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li><p>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p></li><li><p>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725154632354.png" alt="image-20210725154632354"></p><h1 id="3-集群故障恢复原理"><a href="#3-集群故障恢复原理" class="headerlink" title="3.集群故障恢复原理"></a>3.集群故障恢复原理</h1><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p>当选出一个新的master后，该如何实现切换呢？</p><p>流程如下：</p><ul><li>sentinel给备选的slave1节点发送 <code>slaveof no one</code> 命令，让该节点成为master</li><li>sentinel给所有其它slave发送 <code>slaveof 192.168.10.101 7002</code>  命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725154816841.png" alt="image-20210725154816841"></p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><p>Sentinel的三个作用是什么？</p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先选定一个slave作为新的master，执行slaveof no one</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点配置，添加slaveof 新master</li></ul><h1 id="5-哨兵集群搭建"><a href="#5-哨兵集群搭建" class="headerlink" title="5.哨兵集群搭建"></a>5.哨兵集群搭建</h1><h2 id="5-1-集群结构"><a href="#5-1-集群结构" class="headerlink" title="5.1.集群结构"></a>5.1.集群结构</h2><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：<br><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725154528072.png" alt="image-20210725154528072"></p><p>三个sentinel实例信息如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">IP</th><th style="text-align:center">PORT</th></tr></thead><tbody><tr><td style="text-align:center">s1</td><td style="text-align:center">itachi101</td><td style="text-align:center">27001</td></tr><tr><td style="text-align:center">s2</td><td style="text-align:center">itachi101</td><td style="text-align:center">27002</td></tr><tr><td style="text-align:center">s3</td><td style="text-align:center">itachi101</td><td style="text-align:center">27003</td></tr></tbody></table></div><h2 id="5-2-修改master配置，并启动主从复制集群"><a href="#5-2-修改master配置，并启动主从复制集群" class="headerlink" title="5.2.修改master配置，并启动主从复制集群"></a>5.2.修改master配置，并启动主从复制集群</h2><p>因为我们之前的主从集群中，master节点是没设置其他slave节点的密码的。但是哨兵集群中，master可能变成slave，此时如果他没有其他节点的密码的话，就会无法去新的master节点同步数据。所以我们在 <code>redis.conf</code> 中给master配置其他节点的密码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth yourpassword</span><br></pre></td></tr></table></figure><p>然后启动主从集群，测试</p><h2 id="5-3-准备实例和配置"><a href="#5-3-准备实例和配置" class="headerlink" title="5.3.准备实例和配置"></a>5.3.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> s1 s2 s3</span><br></pre></td></tr></table></figure><p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 27001</span><br><span class="line">sentinel announce-ip 192.168.10.101</span><br><span class="line">sentinel monitor mymaster 192.168.10.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">sentinel auth-pass mymaster y</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/tmp/s1&quot;</span></span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>port 27001</code>：是当前sentinel实例的端口</li><li><code>sentinel monitor mymaster 192.168.10.101 7001 2</code>：指定主节点信息<ul><li><code>mymaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.10.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：选举master时的quorum值</li></ul></li></ul><p>然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中（在/tmp目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s2</span><br><span class="line"><span class="built_in">cp</span> s1/sentinel.conf s3</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> s2 s3 | xargs -t -n 1 <span class="built_in">cp</span> s1/sentinel.conf</span><br></pre></td></tr></table></figure><p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003，工作目录修改为/tmp/s2，/tmp/s1</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim s2/sentinel.conf</span><br><span class="line">port 27002</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/tmp/s2&quot;</span></span><br><span class="line"></span><br><span class="line">vim s3/sentinel.conf</span><br><span class="line">port 27003</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/tmp/s3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5-4-启动"><a href="#5-4-启动" class="headerlink" title="5.4.启动"></a>5.4.启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1个</span></span><br><span class="line">redis-sentinel s1/sentinel.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2个</span></span><br><span class="line">redis-sentinel s2/sentinel.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3个</span></span><br><span class="line">redis-sentinel s3/sentinel.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-5-测试"><a href="#5-5-测试" class="headerlink" title="5.5.测试"></a>5.5.测试</h2><p>尝试让master节点7001宕机，查看sentinel日志：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210701222857997.png" alt="image-20210701222857997"></p><p>查看7003的日志：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210701223025709.png" alt="image-20210701223025709"></p><p>查看7002的日志：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210701223131264.png" alt="image-20210701223131264"></p><p>然后启动7001，可以看到7001变成从节点了</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从复制</title>
      <link href="/post/14.html"/>
      <url>/post/14.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-搭建主从架构"><a href="#1-搭建主从架构" class="headerlink" title="1.搭建主从架构"></a>1.搭建主从架构</h1><h2 id="1-1-集群结构"><a href="#1-1-集群结构" class="headerlink" title="1.1.集群结构"></a>1.1.集群结构</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230330193053327.png" alt="image-20230330193053327"></p><p>共包含三个节点，一个主节点，两个从节点。</p><p>这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">IP</th><th style="text-align:center">PORT</th><th style="text-align:center">角色</th></tr></thead><tbody><tr><td style="text-align:center">192.168.10.101</td><td style="text-align:center">7001</td><td style="text-align:center">master</td></tr><tr><td style="text-align:center">192.168.10.101</td><td style="text-align:center">7002</td><td style="text-align:center">slave</td></tr><tr><td style="text-align:center">192.168.10.101</td><td style="text-align:center">7003</td><td style="text-align:center">slave</td></tr></tbody></table></div><h2 id="1-2-准备实例和配置"><a href="#1-2-准备实例和配置" class="headerlink" title="1.2.准备实例和配置"></a>1.2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>1）创建目录</p><p>我们创建三个文件夹，名字分别叫7001、7002、7003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 7001 7002 7003</span><br></pre></td></tr></table></figure><p>2）把 <code>redis.conf</code> 恢复原始配置</p><p>3）拷贝配置文件到每个实例目录</p><p>然后将redis-6.2.4/redis.conf文件拷贝到三个目录中（在/tmp目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/src/redis-6.2.6/redis.conf.bck 7001</span><br><span class="line"><span class="built_in">cp</span> /usr/local/src/redis-6.2.6/redis.conf.bck 7002</span><br><span class="line"><span class="built_in">cp</span> /usr/local/src/redis-6.2.6/redis.conf.bck 7003</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> /tmp/7001/redis.conf.bck /tmp/7001/redis.conf</span><br><span class="line"><span class="built_in">cp</span> /tmp/7002/redis.conf.bck /tmp/7002/redis.conf</span><br><span class="line"><span class="built_in">cp</span> /tmp/7003/redis.conf.bck /tmp/7003/redis.conf</span><br></pre></td></tr></table></figure><p>4）修改三个配置文件的基本配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 分别修改端口为7001 7002 7003</span></span><br><span class="line">port 7001</span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass yourpassword</span><br><span class="line"><span class="comment"># 注意：vim底行模式，输入/requirepass回车即可搜索。n下一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作目录，三台机器整个有差异，分别为7001 7002 7003文件夹</span></span><br><span class="line"><span class="built_in">dir</span> /tmp/7001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="comment"># 分别为redis7001.log redis7002.log redis7003.log</span></span><br><span class="line">logfile <span class="string">&quot;redis7001.log&quot;</span></span><br></pre></td></tr></table></figure><p>5）修改每个实例的声明IP</p><p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis实例的声明 IP</span></span><br><span class="line"><span class="attr">replica-announce-ip</span> <span class="string">192.168.10.101</span></span><br></pre></td></tr></table></figure><p>每个目录都要改，我们一键完成修改（在/tmp目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐一执行</span></span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.10.101&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.10.101&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.10.101&#x27;</span> 7003/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者一键修改</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;1a replica-announce-ip 192.168.10.101&#x27;</span> &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure><p>6）配置主从关系，这一步只需要修改7002和7003</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim 7002/redis.conf</span><br><span class="line"><span class="comment"># 指定主节点是谁</span></span><br><span class="line">slaveof 192.168.10.101 7001</span><br><span class="line"><span class="comment"># 指定主节点的密码</span></span><br><span class="line">masterauth yourpassword</span><br><span class="line"></span><br><span class="line">vim 7003/redis.conf</span><br><span class="line"><span class="comment"># 指定主节点是谁</span></span><br><span class="line">slaveof 192.168.10.101 7001</span><br><span class="line"><span class="comment"># 指定主节点的密码</span></span><br><span class="line">masterauth yourpassword</span><br></pre></td></tr></table></figure><h2 id="1-3-启动"><a href="#1-3-启动" class="headerlink" title="1.3.启动"></a>1.3.启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1个</span></span><br><span class="line">redis-server 7001/redis.conf</span><br><span class="line"><span class="built_in">tail</span> -f 7001/redis7001.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 第2个</span></span><br><span class="line">redis-server 7002/redis.conf</span><br><span class="line"><span class="built_in">tail</span> -f 7002/redis7002.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 第3个</span></span><br><span class="line">redis-server 7003/redis.conf</span><br><span class="line"><span class="built_in">tail</span> -f 7003/redis7003.<span class="built_in">log</span> </span><br></pre></td></tr></table></figure><p>停止：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 -a yourpassword shutdown </span><br><span class="line">redis-cli -p 7002 -a yourpassword shutdown </span><br><span class="line">redis-cli -p 7003 -a yourpassword shutdown</span><br></pre></td></tr></table></figure><h2 id="1-4-开启主从关系"><a href="#1-4-开启主从关系" class="headerlink" title="1.4.开启主从关系"></a>1.4.开启主从关系</h2><p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure></li></ul><p>我们这里已经在前面使用了第一种方式。</p><p><strong><font color="red">注意</font></strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p><p>然后连接 7001节点，查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7001</span></span><br><span class="line">redis-cli -p 7001 -a yourpassw</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230330193403117.png" alt="image-20230330193403117"></p><h2 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5.测试"></a>1.5.测试</h2><p>执行下列操作以测试：</p><ul><li><p>利用redis-cli连接7001，执行<code>set num 123</code></p></li><li><p>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></p></li><li><p>利用redis-cli连接7003，执行<code>get num</code>，再执行<code>set num 888</code></p></li></ul><p>可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。</p><h1 id="2-主从数据同步原理"><a href="#2-主从数据同步原理" class="headerlink" title="2.主从数据同步原理"></a>2.主从数据同步原理</h1><h2 id="2-1-全量同步"><a href="#2-1-全量同步" class="headerlink" title="2.1.全量同步"></a>2.1.全量同步</h2><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725152222497.png" alt="image-20210725152222497"></p><p>这里有一个问题，master如何得知salve是第一次来连接呢？？</p><p>有两个概念，可以作为判断依据：</p><ul><li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p><p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p><p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><p>如图：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725152700914.png" alt="image-20210725152700914"></p><p>完整流程描述：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><h2 id="2-2-增量同步"><a href="#2-2-增量同步" class="headerlink" title="2.2.增量同步"></a>2.2.增量同步</h2><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725153201086.png" alt="image-20210725153201086"></p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><h2 id="2-3-repl-backlog原理"><a href="#2-3-repl-backlog原理" class="headerlink" title="2.3.repl_backlog原理"></a>2.3.repl_backlog原理</h2><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的repl_baklog文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725153359022.png" alt="image-20210725153359022"> </p><p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725153524190.png" alt="image-20210725153524190"> </p><p>直到数组被填满：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725153715910.png" alt="image-20210725153715910"> </p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： </p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725153937031.png" alt="image-20210725153937031"> </p><p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725154155984.png" alt="image-20210725154155984"> </p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p><blockquote><p>总结：repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步。</p></blockquote><h1 id="3-主从同步优化"><a href="#3-主从同步优化" class="headerlink" title="3.主从同步优化"></a>3.主从同步优化</h1><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从集群：</p><ul><li>在master中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用<strong>主-从-从链式结构</strong>，减少master压力</li></ul><p>主从从架构图：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230330195253244.png" alt="image-20230330195253244"></p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h1><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis持久化</title>
      <link href="/post/13.html"/>
      <url>/post/13.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-RDB持久化"><a href="#1-RDB持久化" class="headerlink" title="1.RDB持久化"></a>1.RDB持久化</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1.概述"></a>1.1.概述</h2><p>RDB全称<strong>R</strong>edis <strong>D</strong>atabase <strong>B</strong>ackup file（Redis数据备份文件），也被叫做<strong>Redis数据快照</strong>。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p>快照文件称为RDB文件，默认是保存在当前运行目录。</p><h2 id="1-2-执行时机"><a href="#1-2-执行时机" class="headerlink" title="1.2.执行时机"></a>1.2.执行时机</h2><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><h3 id="1-2-1-save命令"><a href="#1-2-1-save命令" class="headerlink" title="1.2.1.save命令"></a>1.2.1.save命令</h3><p>执行下面的命令，可以立即执行一次RDB：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725144536958.png" alt="image-20210725144536958"></p><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><h3 id="1-2-2-bgsave命令"><a href="#1-2-2-bgsave命令" class="headerlink" title="1.2.2.bgsave命令"></a>1.2.2.bgsave命令</h3><p>下面的命令可以异步执行RDB：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725144725943.png" alt="image-20210725144725943"></p><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><h3 id="1-2-3-停机时"><a href="#1-2-3-停机时" class="headerlink" title="1.2.3.停机时"></a>1.2.3.停机时</h3><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><h3 id="1-2-4-触发RDB条件"><a href="#1-2-4-触发RDB条件" class="headerlink" title="1.2.4.触发RDB条件"></a>1.2.4.触发RDB条件</h3><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure><h2 id="1-3-RDB原理"><a href="#1-3-RDB原理" class="headerlink" title="1.3.RDB原理"></a>1.3.RDB原理</h2><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230330161440149.png" alt="image-20230330161440149"></p><blockquote><p>主要流程为：</p><ul><li>bgsave 子进程是由主线程 fork 出来的，可以共享主线程的所有内存数据；</li><li>bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件中；</li><li>如果主线程对这些数据都是读操作，例如 A，那么主线程和 bgsave 子进程互不影响；</li><li>如果主线程需要修改一块数据，如 C，这块数据会被复制一份，生成数据的副本，然主线程在这个副本上进行修改；bgsave 子进程可以把原来的数据 C 写入 RDB 文件；</li></ul></blockquote><h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4.小结"></a>1.4.小结</h2><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h1 id="2-AOF持久化"><a href="#2-AOF持久化" class="headerlink" title="2.AOF持久化"></a>2.AOF持久化</h1><h2 id="2-1-AOF原理"><a href="#2-1-AOF原理" class="headerlink" title="2.1.AOF原理"></a>2.1.AOF原理</h2><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725151543640.png" alt="image-20210725151543640"></p><blockquote><p>其中*3 代表当前命令分为三部分，每部分都是通过$+数字开头，其中数字表示该部分的命令、键、值一共有多少字节。</p></blockquote><h2 id="2-2-AOF配置"><a href="#2-2-AOF配置" class="headerlink" title="2.2.AOF配置"></a>2.2.AOF配置</h2><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>三种策略对比：</p><div class="table-container"><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">刷盘时机</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">同步刷盘</td><td style="text-align:center">可靠性高，几乎不丢数据</td><td style="text-align:center">性能影响大</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒刷盘</td><td style="text-align:center">性能适中</td><td style="text-align:center">最多丢失1秒数据</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">操作系统控制</td><td style="text-align:center">性能最好</td><td style="text-align:center">可靠性较差，可能丢失大量数据</td></tr></tbody></table></div><blockquote><p>正常情况使用默认的everysec策略就行了。</p></blockquote><h2 id="2-3-AOF文件重写机制"><a href="#2-3-AOF文件重写机制" class="headerlink" title="2.3.AOF文件重写机制"></a>2.3.AOF文件重写机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行 <code>bgrewriteaof</code> 命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20210725151729118.png" alt="image-20210725151729118"></p><p>如图，AOF原本有三个命令，但是 <code>set num 123</code> 和 <code>set num 666</code> 都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><h3 id="启动bgrewriteaof"><a href="#启动bgrewriteaof" class="headerlink" title="启动bgrewriteaof"></a>启动bgrewriteaof</h3><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BGREWRITEAOF</span><br><span class="line">Backgroud append only file rewriting started</span><br></pre></td></tr></table></figure><h3 id="默认的配置"><a href="#默认的配置" class="headerlink" title="默认的配置"></a>默认的配置</h3><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>AOF 重写的过程是通过主线程 fork 后台的 bgrewriteaof 子进程来实现的，可以避免阻塞主进程导致性能下降，整个过程如下：</p><ul><li>AOF 每次重写，fork 过程会把主线程的内存拷贝一份 bgrewriteaof 子进程，里面包含了数据库的数据，拷贝的是父进程的页表，可以在不影响主进程的情况下逐一把拷贝的数据记入重写日志；</li><li>因为主线程没有阻塞，仍然可以处理新来的操作，如果这时候存在写操作，会先把操作先放入缓冲区，对于正在使用的日志，如果宕机了这个日志也是齐全的，可以用于恢复；对于正在更新的日志，也不会丢失新的操作，等到数据拷贝完成，就可以将缓冲区的数据写入到新的文件中，保证数据库的最新状态。</li></ul><h1 id="3-RDB与AOF对比"><a href="#3-RDB与AOF对比" class="headerlink" title="3.RDB与AOF对比"></a>3.RDB与AOF对比</h1><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">RDB</th><th style="text-align:center">AOF</th></tr></thead><tbody><tr><td style="text-align:center">持久化方式</td><td style="text-align:center">定时对整个内存做快照</td><td style="text-align:center">记录每一次执行的命令</td></tr><tr><td style="text-align:center">数据完整性</td><td style="text-align:center">不完整，两次本分之间会丢失</td><td style="text-align:center">相对完整，取决于刷盘策略</td></tr><tr><td style="text-align:center">文件大小</td><td style="text-align:center">文件体积较小</td><td style="text-align:center">文件体积很大</td></tr><tr><td style="text-align:center">宕机恢复速度</td><td style="text-align:center">很快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">数据恢复优先级</td><td style="text-align:center">低，因为数据完整性不如AOF</td><td style="text-align:center">高，因为数据完整性更高</td></tr><tr><td style="text-align:center">系统资源占用</td><td style="text-align:center">高，大量CPU和内存消耗</td><td style="text-align:center">低，主要是磁盘IO资源。但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">可以容忍数分钟的数据丢失，追求更快的启动速度</td><td style="text-align:center">对数据安全性要求较高场景</td></tr></tbody></table></div><h1 id="4-混合使用-AOF-日志和-RDB-快照"><a href="#4-混合使用-AOF-日志和-RDB-快照" class="headerlink" title="4.混合使用 AOF 日志和 RDB 快照"></a>4.混合使用 AOF 日志和 RDB 快照</h1><p>虽然跟 AOF 相比，RDB 快照的恢复速度快，但快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销，那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？</p><p>在 Redis4.0 提出了<strong>混合使用 AOF 和 RDB 快照</strong>的方法，也就是两次 RDB 快照期间的所有命令操作由 AOF 日志文件进行记录。这样的好处是 RDB 快照不需要很频繁的执行，可以避免频繁 fork 对主线程的影响，而且 AOF 日志也只记录两次快照期间的操作，不用记录所有操作，也不会出现文件过大的情况，避免了重写开销。</p><p>通过上述方法既可以享受 RDB 快速恢复的好处，也可以享受 AOF 记录简单命令的优势。</p><p><strong>对于 AOF 和 RDB 的选择问题：</strong></p><ul><li><p><strong>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</strong></p></li><li><p><strong>如果允许分钟级别的数据丢失，可以只使用 RDB；</strong></p></li><li><p><strong>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【原理】redis数据结构</title>
      <link href="/post/12.html"/>
      <url>/post/12.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-总览"><a href="#1-总览" class="headerlink" title="1.总览"></a>1.总览</h1><div class="table-container"><table><thead><tr><th style="text-align:left">API类型</th><th style="text-align:left">情景</th><th style="text-align:left">编码类型</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">String</td><td style="text-align:left">只有整数，且范围在long的范围内（8字节）</td><td style="text-align:left">INT</td><td>ptr直接存整数</td></tr><tr><td style="text-align:left">String</td><td style="text-align:left">字符串长度小于44字节</td><td style="text-align:left">EMBSTR</td><td>rdisObject尾部直接和SDS物理上相连</td></tr><tr><td style="text-align:left">String</td><td style="text-align:left">不是整数，且字符串大于44字节（即通用情景）</td><td style="text-align:left">RAW</td><td></td></tr><tr><td style="text-align:left">List</td><td style="text-align:left">Redis3.2之前</td><td style="text-align:left">LinkedList+ZipList</td><td></td></tr><tr><td style="text-align:left">List</td><td style="text-align:left">Redis3.2之后</td><td style="text-align:left">QuickList</td><td></td></tr><tr><td style="text-align:left">Set</td><td style="text-align:left">set的元素只有整数</td><td style="text-align:left">IntSet</td><td>节省空间，且效率也不会很低（二分）</td></tr><tr><td style="text-align:left">Set</td><td style="text-align:left">set的元素只有整数但是超过阈值，或者不是只有整数（即通用情景）</td><td style="text-align:left">HT</td><td></td></tr><tr><td style="text-align:left">ZSet</td><td style="text-align:left">数据量小时</td><td style="text-align:left">ZipList</td><td></td></tr><tr><td style="text-align:left">ZSet</td><td style="text-align:left">数据量大时</td><td style="text-align:left">HT+SkipList</td><td></td></tr><tr><td style="text-align:left">Hash</td><td style="text-align:left">数据量小时</td><td style="text-align:left">ZipList</td><td></td></tr><tr><td style="text-align:left">Hash</td><td style="text-align:left">数据量大时</td><td style="text-align:left">HT</td></tr></tbody></table></div><h1 id="2-动态字符串SDS"><a href="#2-动态字符串SDS" class="headerlink" title="2.动态字符串SDS"></a>2.动态字符串SDS</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Redis构建了一种字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name <span class="string">&quot;zhangsan&quot;</span></span><br></pre></td></tr></table></figure><p>Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“zhangsan”的SDS。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329104551453.png" alt="image-20230329104551453"></p><p>例如，一个包含字符串“name”的sds结构如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329104636403.png" alt="image-20230329104636403"></p><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329104703683.png" alt="image-20230329104703683"></p><p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p><ul><li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为<strong>内存预分配</strong>。</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329104752263.png" alt="image-20230329104752263"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态字符串的优点：</p><ul><li>获取字符串长度的时间复杂度为O(1)</li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全</li></ul><h1 id="3-IntSet"><a href="#3-IntSet" class="headerlink" title="3.IntSet"></a>3.IntSet</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。</p><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><p>结构如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653984923322.png" alt="1653984923322"></p><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653984942385.png" alt="1653984942385"></p><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329105017965.png" alt="image-20230329105017965"></p><h2 id="IntSet升级"><a href="#IntSet升级" class="headerlink" title="IntSet升级"></a>IntSet升级</h2><p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：</p><blockquote><p>encoding：4字节<br>length：4字节<br>contents：2字节 * 3  = 6字节</p></blockquote><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329105142575.png" alt="image-20230329105142575"></p><p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动<strong>升级</strong>编码方式到合适的大小。<br>以当前案例来说流程如下：</p><ul><li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li><li>将待添加的元素放入数组末尾</li><li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329105224462.png" alt="image-20230329105224462"></p><h2 id="IntSet新增流程（源码）"><a href="#IntSet新增流程（源码）" class="headerlink" title="IntSet新增流程（源码）"></a>IntSet新增流程（源码）</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329105252842.png" alt="image-20230329105252842"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329105258508.png" alt="image-20230329105258508"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Intset可以看做是特殊的整数数组，具备一些特点：</p><ul><li>Redis会确保Intset中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h1 id="4-Dict"><a href="#4-Dict" class="headerlink" title="4.Dict"></a>4.Dict</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。<br>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。</p><p>我们存储k1=v1，假设k1的哈希值h =1，则1&amp;3 =1，因此k1=v1要存储到数组角标1位置。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653985497735.png" alt="1653985497735"></p><p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653985570612.png" alt="1653985570612"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329105507913.png" alt="image-20230329105507913"></p><h2 id="Dict的扩容"><a href="#Dict的扩容" class="headerlink" title="Dict的扩容"></a>Dict的扩容</h2><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发哈希表扩容：<br>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；<br>哈希表的 LoadFactor &gt; 5 ；</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653985716275.png" alt="1653985716275"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653985743412.png" alt="1653985743412"></p><h2 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h2><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li><p>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</p><ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li><p>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</p></li><li>设置dict.rehashidx = 0，标示开始rehash</li><li>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><p>整个过程可以描述成：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653985824540.png" alt="1653985824540"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>Dict的结构：</p><ul><li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li></ul><p>Dict的伸缩：</p><ul><li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li><li>当LoadFactor小于0.1时，Dict收缩</li><li>扩容大小为第一个大于等于used + 1的2^n</li><li>收缩大小为第一个大于等于used 的2^n</li><li><strong>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</strong></li><li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li></ul><h1 id="5-ZipList"><a href="#5-ZipList" class="headerlink" title="5.ZipList"></a>5.ZipList</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/ZipList结构图.png" alt="ZipList结构图"></p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>属性</strong></th><th style="text-align:center"><strong>类型</strong></th><th style="text-align:center"><strong>长度</strong></th><th style="text-align:center"><strong>用途</strong></th></tr></thead><tbody><tr><td style="text-align:center">zlbytes</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4 字节</td><td style="text-align:center">记录整个压缩列表占用的内存字节数</td></tr><tr><td style="text-align:center">zltail</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4 字节</td><td style="text-align:center">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td></tr><tr><td style="text-align:center">zllen</td><td style="text-align:center">uint16_t</td><td style="text-align:center">2 字节</td><td style="text-align:center">记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td style="text-align:center">entry</td><td style="text-align:center">列表节点</td><td style="text-align:center">不定</td><td style="text-align:center">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td style="text-align:center">zlend</td><td style="text-align:center">uint8_t</td><td style="text-align:center">1 字节</td><td style="text-align:center">特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table></div><h2 id="ZipListEntry"><a href="#ZipListEntry" class="headerlink" title="ZipListEntry"></a>ZipListEntry</h2><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，<strong>因为记录两个指针要占用16个字节，浪费内存</strong>。而是采用了下面的结构：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653986055253.png" alt="1653986055253"></p><ul><li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul></li><li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p></li><li>contents：负责保存节点的数据，可以是字符串或整数</li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><h3 id="Encoding编码"><a href="#Encoding编码" class="headerlink" title="Encoding编码"></a>Encoding编码</h3><p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p><div class="table-container"><table><thead><tr><th><strong>编码</strong></th><th><strong>编码长度</strong></th><th><strong>字符串大小</strong></th></tr></thead><tbody><tr><td>\</td><td>00pppppp\</td><td></td><td>1 bytes</td><td>&lt;= 63 bytes</td></tr><tr><td>\</td><td>01pppppp\</td><td>qqqqqqqq\</td><td></td><td>2 bytes</td><td>&lt;= 16383 bytes</td></tr><tr><td>\</td><td>10000000\</td><td>qqqqqqqq\</td><td>rrrrrrrr\</td><td>ssssssss\</td><td>tttttttt\</td><td></td><td>5 bytes</td><td>&lt;= 4294967295 bytes</td></tr></tbody></table></div><p>例如，我们要保存字符串：“ab”和 “bc”</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329142258967.png" alt="image-20230329142258967"></p><p> ZipListEntry中的encoding编码分为<strong>字符串</strong>和<strong>整数</strong>两种：</p><ul><li>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</li></ul><div class="table-container"><table><thead><tr><th><strong>编码</strong></th><th><strong>编码长度</strong></th><th><strong>整数类型</strong></th></tr></thead><tbody><tr><td>11000000</td><td>1</td><td>int16_t（2 bytes）</td></tr><tr><td>11010000</td><td>1</td><td>int32_t（4 bytes）</td></tr><tr><td>11100000</td><td>1</td><td>int64_t（8 bytes）</td></tr><tr><td>11110000</td><td>1</td><td>24位有符整数(3 bytes)</td></tr><tr><td>11111110</td><td>1</td><td>8位有符整数(1 bytes)</td></tr><tr><td>1111xxxx</td><td>1</td><td>直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td></tr></tbody></table></div><p>例如，一个ZipList中包含两个整数值：“2”和“5” 对应的encoding为“1111 0011”（0xf3）和“1111 0110”(0xf6)，他们是没有content的</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653986282879.png" alt="1653986282879"></p><h2 id="ZipList的连锁更新问题"><a href="#ZipList的连锁更新问题" class="headerlink" title="ZipList的连锁更新问题"></a>ZipList的连锁更新问题</h2><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653986328124.png" alt="1653986328124"></p><p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>ZipList特性：</strong></p><ul><li>压缩列表的可以看做一种连续内存空间的”双向链表”</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题（连锁升级问题）</li></ul><h1 id="6-QuickList"><a href="#6-QuickList" class="headerlink" title="6.QuickList"></a>6.QuickList</h1><h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><p>​    答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p><p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p><p>​    答：我们可以创建多个ZipList来分片存储数据。</p><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><p>​    答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329142805328.png" alt="image-20230329142805328"></p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。</p><ul><li>如果值为正，则代表ZipList的允许的entry个数的最大值</li><li>如果值为负，则代表ZipList的最大内存大小，分5种情况：<ul><li>-1：每个ZipList的内存占用不能超过4kb</li><li>-2：每个ZipList的内存占用不能超过8kb</li><li>-3：每个ZipList的内存占用不能超过16kb</li><li>-4：每个ZipList的内存占用不能超过32kb</li><li>-5：每个ZipList的内存占用不能超过64kb</li></ul></li></ul><p>其默认值为 -2：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329142848293.png" alt="image-20230329142848293"></p><h2 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h2><p>以下是QuickList的和QuickListNode的结构源码：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653986667228.png" alt="1653986667228"></p><p>我们接下来用一段流程图来描述当前的这个结构</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653986718554.png" alt="1653986718554"></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>QuickList的特点：</p><ul><li>是一个节点为ZipList的双端链表</li><li>节点采用ZipList，解决了传统链表的内存占用问题</li><li>控制了ZipList大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ul><h1 id="7-SkipList"><a href="#7-SkipList" class="headerlink" title="7.SkipList"></a>7.SkipList</h1><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p><ul><li>元素按照升序排列存储</li><li>节点可能包含多个指针，指针跨度不同。</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/跳表结构.jpg" alt="跳表结构"></p><h2 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/跳表源码.png" alt="跳表源码"></p><h2 id="一级跳表结构"><a href="#一级跳表结构" class="headerlink" title="一级跳表结构"></a>一级跳表结构</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/1级跳表结构.png" alt="1级跳表结构"></p><h2 id="多级跳表结构"><a href="#多级跳表结构" class="headerlink" title="多级跳表结构"></a>多级跳表结构</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/多级跳表结构.png" alt="多级跳表结构"></p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>SkipList的特点：</p><ul><li>跳跃表是一个双向链表，每个节点都包含score和ele值</li><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul><h1 id="8-RedisObject"><a href="#8-RedisObject" class="headerlink" title="8.RedisObject"></a>8.RedisObject</h1><h2 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329163444988.png" alt="image-20230329163444988"></p><h2 id="Redis的编码方式"><a href="#Redis的编码方式" class="headerlink" title="Redis的编码方式"></a>Redis的编码方式</h2><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><div class="table-container"><table><thead><tr><th><strong>编号</strong></th><th><strong>编码方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>0</td><td>OBJ_ENCODING_RAW</td><td>raw编码动态字符串</td></tr><tr><td>1</td><td>OBJ_ENCODING_INT</td><td>long类型的整数的字符串</td></tr><tr><td>2</td><td>OBJ_ENCODING_HT</td><td>hash表（字典dict）</td></tr><tr><td>3</td><td>OBJ_ENCODING_ZIPMAP</td><td>已废弃</td></tr><tr><td>4</td><td>OBJ_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>5</td><td>OBJ_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>6</td><td>OBJ_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>7</td><td>OBJ_ENCODING_SKIPLIST</td><td>跳表</td></tr><tr><td>8</td><td>OBJ_ENCODING_EMBSTR</td><td>embstr的动态字符串</td></tr><tr><td>9</td><td>OBJ_ENCODING_QUICKLIST</td><td>快速列表</td></tr><tr><td>10</td><td>OBJ_ENCODING_STREAM</td><td>Stream流</td></tr></tbody></table></div><h2 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h2><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><div class="table-container"><table><thead><tr><th><strong>数据类型</strong></th><th><strong>编码方式</strong></th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>int、embstr、raw</td></tr><tr><td>OBJ_LIST</td><td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td>OBJ_SET</td><td>intset、HT</td></tr><tr><td>OBJ_ZSET</td><td>ZipList、HT、SkipList</td></tr><tr><td>OBJ_HASH</td><td>ZipList、HT</td></tr></tbody></table></div><h1 id="9-String"><a href="#9-String" class="headerlink" title="9.String"></a>9.String</h1><p>String是Redis中最常见的数据存储类型：</p><ul><li>RAW编码</li><li>EMBSTR编码</li><li>INT编码</li></ul><h2 id="RAW编码"><a href="#RAW编码" class="headerlink" title="RAW编码"></a>RAW编码</h2><p>String基本的编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329163845339.png" alt="image-20230329163845339"></p><h2 id="EMBSTR编码"><a href="#EMBSTR编码" class="headerlink" title="EMBSTR编码"></a>EMBSTR编码</h2><p>如果存储的SDS长度<strong>小于44字节</strong>，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329164238937.png" alt="image-20230329164238937"></p><p><strong>为什么是44字节？64字节恰好是redis的一个分片大小。</strong></p><h2 id="INT编码"><a href="#INT编码" class="headerlink" title="INT编码"></a>INT编码</h2><p>如果存储的字符串是<strong>整数值</strong>，并且大小在LONG_MAX范围内，则会采用<strong>INT</strong>编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329164434280.png" alt="image-20230329164434280"></p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329164521535.png" alt="image-20230329164521535"></p><h1 id="10-List"><a href="#10-List" class="headerlink" title="10.List"></a>10.List</h1><p>Redis的List类型可以从首、尾操作列表中的元素。哪一个数据结构能满足上述特征？</p><ul><li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li></ul><p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p><p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p><p>在3.2版本之后，Redis统一采用QuickList来实现List：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329164708011.png" alt="image-20230329164708011"></p><h1 id="11-Set"><a href="#11-Set" class="headerlink" title="11.Set"></a>11.Set</h1><p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。</p><ul><li>当存储的所有数据<strong>都是整数</strong>，并且元素数量不超过set-max-intset-entries（配置文件配置）时，Set会采用IntSet编码，以节省内存。<ul><li>例如，一个Set只添加了三个整数元素，结构如下图所示：</li></ul></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329170745910.png" alt="image-20230329170745910"></p><ul><li>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。<ul><li>例如，当上述的Set，添加了一个非整数的元素之后，底层数据结构会从IntSet变成Dict</li></ul></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329171403161.png" alt="image-20230329171403161"></p><h2 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h2><p>Dict和IntSet的选择</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329170924001.png" alt="image-20230329170924001"></p><p>添加元素时的逻辑</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329171002576.png" alt="image-20230329171002576"></p><h1 id="12-ZSet"><a href="#12-ZSet" class="headerlink" title="12.ZSet"></a>12.ZSet</h1><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序后</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此，zset底层数据结构必须满足<strong>键值存储</strong>、<strong>键必须唯一</strong>、<strong>可排序</strong>这几个需求。之前学习的哪种编码结构可以满足？</p><ul><li><strong>SkipList</strong>：可以排序，并且可以同时存储score和ele值（member）</li><li><strong>HT（Dict）</strong>：可以键值存储，并且可以根据key找value</li></ul><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329190449760.png" alt="image-20230329190449760"></p><h3 id="数据量小时：ZipList"><a href="#数据量小时：ZipList" class="headerlink" title="数据量小时：ZipList"></a>数据量小时：ZipList</h3><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329190637447.png" alt="image-20230329190637447"></p><h3 id="数据量大时：HT-SkipList"><a href="#数据量大时：HT-SkipList" class="headerlink" title="数据量大时：HT+SkipList"></a>数据量大时：HT+SkipList</h3><p>结构体声明如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653992121692.png" alt="1653992121692"></p><p>结构图如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653992172526.png" alt="1653992172526"></p><h1 id="13-Hash"><a href="#13-Hash" class="headerlink" title="13.Hash"></a>13.Hash</h1><h2 id="Hash与Zset对比"><a href="#Hash与Zset对比" class="headerlink" title="Hash与Zset对比"></a>Hash与Zset对比</h2><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别如下：</p><ul><li>zset的键是member，值是score；hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ul><p>hash结构如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653992339937.png" alt="1653992339937"></p><p>zset集合如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/1653992360355.png" alt="1653992360355"></p><h2 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h2><h3 id="数据量小时：ZipList-1"><a href="#数据量小时：ZipList-1" class="headerlink" title="数据量小时：ZipList"></a>数据量小时：ZipList</h3><p>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329192017966.png" alt="image-20230329192017966"></p><h3 id="数据量大时：HT"><a href="#数据量大时：HT" class="headerlink" title="数据量大时：HT"></a>数据量大时：HT</h3><p>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个：</p><ol><li>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</li><li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329193327665.png" alt="image-20230329193327665"></p><p>转为HT编码后，Hash的结构如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230329192113560.png" alt="image-20230329192113560"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基础】redis数据结构</title>
      <link href="/post/11.html"/>
      <url>/post/11.html</url>
      
        <content type="html"><![CDATA[<h1 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h1><p>官网教程：<a href="https://redis.io/commands/">https://redis.io/commands/</a></p><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法。以下是执行了help命令的提示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> KEYS</span><br><span class="line">    KEYS pattern</span><br><span class="line">    summary: Find all keys matching the given pattern</span><br><span class="line">    since: 1.0.0</span><br><span class="line">    group: generic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> DEL</span><br><span class="line">    DEL key [key ...]</span><br><span class="line">    summary: Delete a key</span><br><span class="line">    since: 1.0.0</span><br><span class="line">    group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> EXISTS</span><br><span class="line">    EXISTS key [key ...]</span><br><span class="line">    summary: Determine <span class="keyword">if</span> a key exists</span><br><span class="line">    since: 1.0.0</span><br><span class="line">    group: generic</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> EXPIRE</span><br><span class="line">    EXPIRE key seconds</span><br><span class="line">    summary: Set a key<span class="string">&#x27;s time to live in seconds</span></span><br><span class="line"><span class="string">    since: 1.0.0</span></span><br><span class="line"><span class="string">    group: generic</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; help TTL</span></span><br><span class="line"><span class="string">    TTL key</span></span><br><span class="line"><span class="string">    summary: Get the time to live for a key</span></span><br><span class="line"><span class="string">    since: 1.0.0</span></span><br><span class="line"><span class="string">    group: generic</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询以a开头的key</span></span><br><span class="line">127.0.0.1:6379&gt; keys a*</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#批量添加数据</span></span><br><span class="line">127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 </span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; del k1 k2 k3 k4</span><br><span class="line">(<span class="built_in">integer</span>) 3   <span class="comment">#此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exists K1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; expire age 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2  <span class="comment">#当这个key过期了，那么此时查询出来就是-2 </span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 10 <span class="comment">#如果没有设置过期时间</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -1  <span class="comment"># ttl的返回值就是-1</span></span><br></pre></td></tr></table></figure><h1 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h1><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p>String的常见命令有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SET</td><td style="text-align:center">添加或者修改已经存在的一个String类型的键值对</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">根据key获取String类型的value</td></tr><tr><td style="text-align:center">MSET</td><td style="text-align:center">批量添加多个String类型的键值对</td></tr><tr><td style="text-align:center">MGET</td><td style="text-align:center">根据多个key获取多个String类型的value</td></tr><tr><td style="text-align:center">INCR</td><td style="text-align:center">让一个整型的key的值自增1</td></tr><tr><td style="text-align:center">INCRBY</td><td style="text-align:center">让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td></tr><tr><td style="text-align:center">INCRBYFLOAT</td><td style="text-align:center">让一个浮点类型的数字自增并指定步长</td></tr><tr><td style="text-align:center">SETNX</td><td style="text-align:center">添加一个String类型的键值对，前提是这个key不存在，否则不执行</td></tr><tr><td style="text-align:center">SETEX</td><td style="text-align:center">添加一个String类型的键值对，并且指定有效期</td></tr></tbody></table></div><p>INCR和INCRBY和DECY</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get age </span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; incr age <span class="comment"># 增加1</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; get age <span class="comment"># 获得age</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; incrby age 2 <span class="comment"># 一次增加2</span></span><br><span class="line">(<span class="built_in">integer</span>) 13 <span class="comment"># 返回目前的age的值</span></span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; incrby age 2</span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; incrby age -1 <span class="comment"># 也可以增加负数，相当于减</span></span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; incrby age -2 <span class="comment"># 一次减少2个</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; DECR age <span class="comment"># 相当于 incr 负数，减少正常用法</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; get age </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SETNX</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> setnx</span><br><span class="line"></span><br><span class="line">  SETNX key value</span><br><span class="line">  summary: Set the value of a key, only <span class="keyword">if</span> the key does not exist</span><br><span class="line">  since: 1.0.0</span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name Jack  <span class="comment"># 设置名称</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setnx name lisi <span class="comment"># 如果key不存在，则添加成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get name <span class="comment"># 由于name已经存在，所以lisi的操作失败</span></span><br><span class="line"><span class="string">&quot;Jack&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx name2 lisi <span class="comment"># name2 不存在，所以操作成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get name2 </span><br><span class="line"><span class="string">&quot;lisi&quot;</span></span><br></pre></td></tr></table></figure><p>SETEX</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> SETEX</span><br><span class="line"></span><br><span class="line">  SETEX key seconds value</span><br><span class="line">  summary: Set the value and expiration of a key</span><br><span class="line">  since: 2.0.0</span><br><span class="line">  group: string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setex name 10 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h1 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h1><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><div class="table-container"><table><thead><tr><th style="text-align:center">KEY</th><th style="text-align:center">VALUE</th></tr></thead><tbody><tr><td style="text-align:center">user:1</td><td style="text-align:center">{name:”jack”,age:21}</td></tr><tr><td style="text-align:center">user:2</td><td style="text-align:center">{name:”rose”,age:22}</td></tr></tbody></table></div><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/Hash的结构.png" alt="Hash的结构"></p><p>Hash常见命令有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">HSET key field value</td><td style="text-align:center">添加或者修改hash类型key的field的值</td></tr><tr><td style="text-align:center">HGET key field</td><td style="text-align:center">获取一个hash类型key的field的值</td></tr><tr><td style="text-align:center">HMSET</td><td style="text-align:center">批量添加多个hash类型key的field的值</td></tr><tr><td style="text-align:center">HMGET</td><td style="text-align:center">批量获取多个hash类型key的field的值</td></tr><tr><td style="text-align:center">HGETALL</td><td style="text-align:center">获取一个hash类型的key中的所有的field和value</td></tr><tr><td style="text-align:center">HKEYS</td><td style="text-align:center">获取一个hash类型的key中的所有的field</td></tr><tr><td style="text-align:center">HINCRBY</td><td style="text-align:center">让一个hash类型key的字段值自增并指定步长</td></tr><tr><td style="text-align:center">HSETNX</td><td style="text-align:center">添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td></tr></tbody></table></div><p>举例：</p><p>HSET和HGET</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET user:3 name Lucy <span class="comment"># 大key是 user:3 小key是name，小value是Lucy</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET user:3 age 21 <span class="comment"># 如果操作不存在的数据，则是新增</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET user:3 age 17 <span class="comment"># 如果操作存在的数据，则是修改</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; HGET user:3 name </span><br><span class="line"><span class="string">&quot;Lucy&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGET user:3 age</span><br><span class="line"><span class="string">&quot;17&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HMSET和HMGET</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMSET user:4 name LiLei age 20 sex man</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HMGET user:4 name age sex</span><br><span class="line">1) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><p>HGETALL</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:4</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;20&quot;</span></span><br><span class="line">5) <span class="string">&quot;sex&quot;</span></span><br><span class="line">6) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><p>HKEYS和HVALS</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HKEYS user:4</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;sex&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS user:4</span><br><span class="line">1) <span class="string">&quot;LiLei&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;man&quot;</span></span><br></pre></td></tr></table></figure><p>HINCRBY</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HINCRBY user:4 age 2</span><br><span class="line">(<span class="built_in">integer</span>) 22</span><br><span class="line">127.0.0.1:6379&gt; HGET user:4 age</span><br><span class="line">1) <span class="string">&quot;22&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY user:4 age -2</span><br><span class="line">(<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><p>HSETNX</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果本已存在，会失败</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX user:4 sex woman</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; HGET user:4 sex</span><br><span class="line"><span class="string">&quot;man&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果本不存在，会成功</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX user:3 sex woman</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user:3</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;Lucy&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;17&quot;</span></span><br><span class="line">5) <span class="string">&quot;sex&quot;</span></span><br><span class="line">6) <span class="string">&quot;woman&quot;</span></span><br></pre></td></tr></table></figure><h1 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h1><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>==常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。==</p><p>List的常见命令有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">LPUSH key element  …</td><td style="text-align:center">向列表左侧插入一个或多个元素</td></tr><tr><td style="text-align:center">LPOP key</td><td style="text-align:center">移除并返回列表左侧的第一个元素，没有则返回nil</td></tr><tr><td style="text-align:center">RPUSH key element  …</td><td style="text-align:center">向列表右侧插入一个或多个元素</td></tr><tr><td style="text-align:center">RPOP key</td><td style="text-align:center">移除并返回列表右侧的第一个元素</td></tr><tr><td style="text-align:center">LRANGE key start end</td><td style="text-align:center">返回一段角标范围内的所有元素</td></tr><tr><td style="text-align:center">BLPOP key [key …] timeout</td><td style="text-align:center">与LPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr><tr><td style="text-align:center">BRPOP key [key …] timeout</td><td style="text-align:center">与RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr></tbody></table></div><ul><li>LPUSH和RPUSH</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH users <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; RPUSH users <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">(integer) <span class="number">6</span></span><br></pre></td></tr></table></figure><ul><li>LRANGE</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下标从0开始，-1表示末尾</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE <span class="built_in">users</span> 0 -1</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;1&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">5) <span class="string">&quot;5&quot;</span></span><br><span class="line">6) <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE <span class="built_in">users</span> 1 2</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><ul><li>LPOP和RPOP</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPOP <span class="built_in">users</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP <span class="built_in">users</span></span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看链表情况</span></span><br><span class="line">127.0.0.1:6379&gt; lrange <span class="built_in">users</span> 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;4&quot;</span></span><br><span class="line">4) <span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h1><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SADD key member …</td><td style="text-align:center">向set中添加一个或多个元素</td></tr><tr><td style="text-align:center">SREM key member …</td><td style="text-align:center">移除set中的指定元素</td></tr><tr><td style="text-align:center">SCARD key</td><td style="text-align:center">返回set中元素的个数</td></tr><tr><td style="text-align:center">SISMEMBER key member</td><td style="text-align:center">判断一个元素是否存在于set中</td></tr><tr><td style="text-align:center">SMEMBERS</td><td style="text-align:center">获取set中的所有元素</td></tr><tr><td style="text-align:center">SINTER key1 key2 …</td><td style="text-align:center">求key1与key2的交集</td></tr><tr><td style="text-align:center">SDIFF key1 key2 …</td><td style="text-align:center">求key1与key2的差集</td></tr><tr><td style="text-align:center">SUNION key1 key2 …</td><td style="text-align:center">求key1和key2的并集</td></tr></tbody></table></div><p>举例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd s1 a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers s1</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srem s1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER s1 a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER s1 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">    </span><br><span class="line">127.0.0.1:6379&gt; SCARD s1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h1 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h1><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个==跳表（SkipList）加 hash表==。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现==排行榜==这样的功能。</p><p><strong>SortedSet的常见命令有：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ZADD key score member</td><td style="text-align:center">添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td style="text-align:center">ZREM key member</td><td style="text-align:center">删除sorted set中的一个指定元素</td></tr><tr><td style="text-align:center">ZSCORE key member</td><td style="text-align:center">获取sorted set中的指定元素的score值</td></tr><tr><td style="text-align:center">ZRANK key member</td><td style="text-align:center">获取sorted set 中的指定元素的排名（升序）</td></tr><tr><td style="text-align:center">ZREVRANK key memeber</td><td style="text-align:center">获取sorted set 中的指定元素的排名（降序）</td></tr><tr><td style="text-align:center">ZCARD key</td><td style="text-align:center">获取sorted set中的元素个数</td></tr><tr><td style="text-align:center">ZCOUNT key min max</td><td style="text-align:center">统计score值在给定范围内的所有元素的个数</td></tr><tr><td style="text-align:center">ZINCRBY key increment member</td><td style="text-align:center">让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td style="text-align:center">ZRANGE key min max</td><td style="text-align:center">按照score排序后，获取指定==排名范围==内的元素</td></tr><tr><td style="text-align:center">ZRANGEBYSCORE key min max</td><td style="text-align:center">按照score排序后，获取指定==score范围==内的元素</td></tr><tr><td style="text-align:center">ZDIFF numkeys key [key …]</td><td style="text-align:center">求差集</td></tr><tr><td style="text-align:center">ZINTER numkeys key [key …]</td><td style="text-align:center">求交集</td></tr><tr><td style="text-align:center">ZUNION numkeys key [key …]</td><td style="text-align:center">求并集</td></tr></tbody></table></div><p>注意：所有的排名都是==默认升序==，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【解决】chrom访问博客加载图片失败问题</title>
      <link href="/post/10.html"/>
      <url>/post/10.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul><li>谷歌浏览器为了安全，图片无法显示。但“在新标签页打开图片”却能显示，说明图片是存在的。</li><li>如果使用火狐浏览器，也是能正常访问的。</li></ul><h1 id="真实原因"><a href="#真实原因" class="headerlink" title="真实原因"></a>真实原因</h1><p>存在七牛云的图片的链接是http协议的，谷歌浏览器自动将协议变成了https协议，所以访问图片失败。</p><h1 id="解决办法1"><a href="#解决办法1" class="headerlink" title="解决办法1"></a>解决办法1</h1><p>点击网站地址栏左边的锁头图标，进入网站设置</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230327200340841.png" alt="image-20230327200340841"></p><p>把不完全内容修改为“允许”，即可。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230327200513995.png" alt="image-20230327200513995"></p><h1 id="解决办法2"><a href="#解决办法2" class="headerlink" title="解决办法2"></a>解决办法2</h1><p>使用火狐浏览器访问。。。</p><h1 id="解决办法3"><a href="#解决办法3" class="headerlink" title="解决办法3"></a>解决办法3</h1><p>图床升级为https。</p><ol><li>去阿里云购买免费的ssl证书，并等待CA验证</li><li>验证成功后，下载证书，选择 <code>pem/key</code> 证书格式</li><li>登录七牛云，来到ssl证书页面，点击“上传自有证书”。（证书内容：对应下载 SSL 证书中的 pem 文件中的内容）（证书私匙 ：对应key 文件里面的内容）</li><li>部署证书</li><li>等待七牛云升级协议https</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【算法】力扣142（环形链表II）</title>
      <link href="/post/17.html"/>
      <url>/post/17.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p>示例：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h1 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h1><p>【快慢指针解法】slow走一步，fast走两步。</p><p>  判断是否有环：fast遇到了null表示无环。</p><p>  如果有环，slow和fast一定在环内相遇。为什么？因为fast肯定是先比slow进入环内的，当slow也进入环内后，相当于fast走一步，slow原地不动，最后fast一定会追上slow。（fast相对速度为1）</p><p>  那么我们分析第一次相遇的时刻。设a为入环前的链表长度（不包括入口节点），设b为环的链表长度（包括入口节点）。设fast走了f步，slow走了s步，则f=2s。</p><p>  相遇时，f=s+nb （解释：相遇时，fast比slow多走了n圈）</p><p>  两式相减得s=nb （理解：相遇时，slow走了的距离和nb相等）</p><p>  然后，我们这样想，slow走到入口节点的表达式是什么？a+nb！</p><p>  此时，s=nb，slow已经走了nb步骤了，再走a步就能走到入口节点了！</p><p>  想办法让他走a步就完事啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != slow) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">时间复杂度O(n)</span></span><br><span class="line"><span class="comment">空间复杂度O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>当然也可以用set来记录节点，如果重复出现则有环，且重复出现的节点为入口节点。空间复杂度升为O(n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc</title>
      <link href="/post/7.html"/>
      <url>/post/7.html</url>
      
        <content type="html"><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="模拟网站计数器"><a href="#模拟网站计数器" class="headerlink" title="模拟网站计数器"></a>模拟网站计数器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lyf.juc.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="comment">// 总访问量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟访问的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span>&#123; TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="type">int</span> expectValue;</span><br><span class="line">        <span class="keyword">while</span> (!compareAndSet(expectValue = getCount(), expectValue + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getCount() == expectValue) &#123;</span><br><span class="line">            count = newValue;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">// 模拟用户行为，每个用户访问10次网站</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        request();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何使用Java的CAS？"><a href="#如何使用Java的CAS？" class="headerlink" title="如何使用Java的CAS？"></a>如何使用Java的CAS？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 sun.misc.Unsafe中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">var1</td><td style="text-align:center">表示要操作的对象</td></tr><tr><td style="text-align:center">var2</td><td style="text-align:center">表示要操作对象中属性的地址偏移量</td></tr><tr><td style="text-align:center">var4</td><td style="text-align:center">表示要修改的数据期望值</td></tr><tr><td style="text-align:center">var5</td><td style="text-align:center">表示要修改的数据的新值</td></tr></tbody></table></div><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><h2 id="为什么不使用AtomicLong"><a href="#为什么不使用AtomicLong" class="headerlink" title="为什么不使用AtomicLong?"></a>为什么不使用AtomicLong?</h2><p>高并发下，CAS成功率太低，导致CPU开销高，效率也低。</p><p>而使用LongAdder可以减少重试次数，高并发下效率提升很高。但是他的缺点就是弱一致性，只能保证最终一致性。</p><p><img src="http://cdn.leef.fun/typora/s3/img/LongAdder.png" alt="LongAdder"></p><blockquote><p>cell数组还支持动态扩容，最大不超过CPU核心数</p></blockquote><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>线程保留自己的数据</p><p>key采用弱引用</p><p>map的生命周期和当前线程绑定</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗"><a href="#假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗" class="headerlink" title="假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗 ?"></a>假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗 ?</h3><p><img src="http://cdn.leef.fun/typora/s3/img/ThreadLocal内存泄漏.png" alt="ThreadLocal内存泄漏"></p><ol><li>假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了</li><li>但是因为threadLocalMap的Entry强引用了threadLocal，造成threadLocal无法被回收</li><li>在没有手动删除这个Entry以及CurrentThread依然运行的前提下始终有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry，Entry就不会被回收(Entry中包括了ThreadLocal实例和value)，导致Entry内存泄漏，即Entry中的key和value对象都不会再用到了，但是还是存在在内存中。</li></ol><blockquote><p> 结论：也就是说，ThreadLocalMap中的key使用了强引用，是无法完全避免内存泄漏的。</p></blockquote><h3 id="那么ThreadLocalMap中的key使用了弱引用，会出现内存泄漏吗"><a href="#那么ThreadLocalMap中的key使用了弱引用，会出现内存泄漏吗" class="headerlink" title="那么ThreadLocalMap中的key使用了弱引用，会出现内存泄漏吗 ?"></a>那么ThreadLocalMap中的key使用了弱引用，会出现内存泄漏吗 ?</h3><ol><li>同样假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了</li><li>由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadlocal实例，所以threadlocal就可以顺利被gc回收，此时Entry中的key= null.</li><li>但是在没有手动删除这个Entry以及CurrentThread依然运行的前提下，也存在有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry -&gt;value ，value不会被回收 ，而这块value永远不会被访问到了，导致value内存泄漏。</li></ol><blockquote><p> 也就是说，ThreadLocalMap中的key使用了弱引用，也有可能内存泄漏。</p></blockquote><h3 id="出现内存泄漏的真实原因"><a href="#出现内存泄漏的真实原因" class="headerlink" title="出现内存泄漏的真实原因"></a>出现内存泄漏的真实原因</h3><p>比较以上两种情况，我们就会发现，内存泄漏的发生跟ThreadLocalMap中的key是否使用弱引用是没有关系的。</p><p>那么内存泄漏的的真正原因是什么呢 ?<br>在以上两种内存泄漏的情况中，都有两个前提 :</p><ol><li>没有手动删除这个Entry</li><li>CurrentThread依然运行</li></ol><p>第一点很好理解，只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄漏。</p><p>第二点稍微复杂一点，由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread一样长。那么在使用完ThreadLocal的使用，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被gc回收，从根源上避免了内存泄漏。</p><p>综上，ThreadLocal内存泄漏的根源是:由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏</p><blockquote><p>总结，用完ThreadLocal后一定要手动remove</p></blockquote><h3 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h3><p>根据刚才的分析,我们知道了: 无论ThreadLocalMap中的key使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系</p><p>要避免内存泄漏有两种方式:</p><ol><li><p>使用完ThreadLocal，调用其remove方法删除对应的Entry</p></li><li><p>使用完ThreadLocal，当前Thread也,随之运行结束</p></li></ol><p>相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的</p><p>也就是说，只要记得在使用完ThreadLocal及时的调用remove，无论key是强引用还是弱引用都不会有问题，那么为什么key要用弱引用呢 ?</p><p>事实上，在ThreadLocalMap中的set/getEntry方法中，会对key为null( 也即是ThreadLoca为null) 进行判新。如果为null的话，那么是会对value置为null的。<br>这就意味着使用完ThreadLocal，CurrentThread依然运行的前提下，<strong>就算忘记调用remove方法，弱引用比强引用可以多一层保障</strong>：弱引用的ThreadLocal会被回收，对应的value在下一次ThreadLocalMap调用set,get,remove中的任一方法的时候会被清除，从而避免内存泄漏。</p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h1 id="Sychronized原理"><a href="#Sychronized原理" class="headerlink" title="Sychronized原理"></a>Sychronized原理</h1><h2 id="Java对象头（以32位为例）"><a href="#Java对象头（以32位为例）" class="headerlink" title="Java对象头（以32位为例）"></a>Java对象头（以32位为例）</h2><p>32位的普通对象</p><p><img src="32位普通对象.png" alt="32位普通对象"></p><p>32位的数组对象</p><p><img src="32位数组对象.png" alt="32位数组对象"></p><p>32位的 Mark Word 结构为</p><p><img src="32位Mark Word结构.png" alt="32位Mark Word结构"></p><p>64位的 Mark Word 结构为</p><p><img src="64位Mark Word结构.png" alt="64位Mark Word结构"></p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>偏向锁 -&gt; 轻量级锁 -&gt; 重量锁</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p><p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有。</p><h3 id="撤销偏向状态——调用hashCode"><a href="#撤销偏向状态——调用hashCode" class="headerlink" title="撤销偏向状态——调用hashCode"></a>撤销偏向状态——调用hashCode</h3><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被 撤销。（不懂的话就看对象头结构。）</p><blockquote><p>为什么轻量级锁和重量级锁，就不会发生这种情况呢？</p><ul><li>轻量级锁会在锁记录中记录 hashCode</li><li>重量级锁会在 Monitor 中记录 hashCode</li></ul></blockquote><h3 id="撤销偏向状态——其它线程交错使用对象"><a href="#撤销偏向状态——其它线程交错使用对象" class="headerlink" title="撤销偏向状态——其它线程交错使用对象"></a>撤销偏向状态——其它线程交错使用对象</h3><p>此时会升级为轻量级锁</p><h3 id="撤销-调用-wait-notify"><a href="#撤销-调用-wait-notify" class="headerlink" title="撤销 - 调用 wait/notify"></a>撤销 - 调用 wait/notify</h3><p>此时会升级为重量级锁，重量级锁才有wait/notify</p><h2 id="轻量级锁-自旋锁"><a href="#轻量级锁-自旋锁" class="headerlink" title="轻量级锁/自旋锁"></a>轻量级锁/自旋锁</h2><p>如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。</p><ul><li>创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li></ul><p><img src="a1.png" alt="a1"></p><ul><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录</li></ul><p><img src="a2.png" alt="a2"></p><ul><li>如果 cas 替换成功，对象头中存储了 <code>锁记录地址和状态 00</code> ，表示由该线程给对象加锁，这时图示如下</li></ul><p><img src="a3.png" alt="a3"></p><ul><li>如果 cas 失败，有两种情况<ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/a4.png" alt="a4"></p><ul><li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/a5.png" alt="a5"></p><ul><li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 头<ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/b1.png" alt="b1"></p><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 </li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/b2.png" alt="b2"></p><ul><li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h2 id="偏向锁vs轻量级锁"><a href="#偏向锁vs轻量级锁" class="headerlink" title="偏向锁vs轻量级锁"></a>偏向锁vs轻量级锁</h2><p><img src="偏向锁.png" alt="偏向锁"></p><p><img src="轻量级锁.png" alt="轻量级锁"></p><h2 id="Monitor原理"><a href="#Monitor原理" class="headerlink" title="Monitor原理"></a>Monitor原理</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong></p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁==（重量级）==之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针。</p><p>Monitor结构如下：</p><p><img src="Monitor结构.png" alt="Monitor结构"></p><ul><li><p>刚开始 Monitor 中 Owner 为 null </p></li><li><p>当 Thread-2 执行<code>synchronized(obj)</code>就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner </p></li><li><p>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 <code>synchronized(obj)</code>，就会进入 EntryList BLOCKED </p></li><li><p>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的 </p></li><li><p>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</p></li></ul><blockquote><p>注意： </p><ul><li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果 </li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul></blockquote><h2 id="wait-notify-原理"><a href="#wait-notify-原理" class="headerlink" title="wait notify 原理"></a>wait notify 原理</h2><p><img src="Monitor结构.png" alt="Monitor结构"></p><ul><li><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 </p></li><li><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </p></li><li><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒 </p></li><li><p>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，<strong>仍需进入 EntryList 重新竞争</strong></p></li></ul><h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><h2 id="ExecutorService继承体系图"><a href="#ExecutorService继承体系图" class="headerlink" title="ExecutorService继承体系图"></a>ExecutorService继承体系图</h2><p><img src="ExecutorService继承体系图.png" alt="ExecutorService继承体系图"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis安装</title>
      <link href="/post/16.html"/>
      <url>/post/16.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h1><p>安装Redis所需要的gcc依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><p>把<code>redis-6.2.6.tar.gz</code> 上传至 <code>/usr/local/src</code>  上</p><p>解压缩</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p>进入redis目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure><p>运行编译命令，如果没有出错，应该就安装成功了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下</p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h2 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h2><blockquote><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul></blockquote><h3 id="默认启动：在任意目录下执行"><a href="#默认启动：在任意目录下执行" class="headerlink" title="默认启动：在任意目录下执行"></a>默认启动：在任意目录下执行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf</p><p>先备份一下默认的配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span> </span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass yourpassword</span><br><span class="line"><span class="comment"># 注意：vim底行模式，输入/requirepass回车即可搜索。</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="built_in">dir</span> .</span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动redis</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>停止服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -a yourpassword shutdown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用kill</span></span><br><span class="line"><span class="built_in">kill</span> -9 进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>新建一个系统服务文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h2 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h2><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码 </li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/5.html"/>
      <url>/post/5.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h1 id="你好"><a href="#你好" class="headerlink" title="你好"></a>你好</h1><p>哈哈</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录</title>
      <link href="/post/2.html"/>
      <url>/post/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><h4 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4><h4 id="209-长度最小的子数组⭐"><a href="#209-长度最小的子数组⭐" class="headerlink" title="209. 长度最小的子数组⭐"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>⭐</h4><h4 id="59-螺旋矩阵-II⭐⭐"><a href="#59-螺旋矩阵-II⭐⭐" class="headerlink" title="59. 螺旋矩阵 II⭐⭐"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a>⭐⭐</h4><p>题解<a href="https://leetcode.cn/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/">https://leetcode.cn/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/</a></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h4><h4 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h4><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><h4 id="160-相交链表⭐"><a href="#160-相交链表⭐" class="headerlink" title="160. 相交链表⭐"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a>⭐</h4><h4 id="142-环形链表-II⭐"><a href="#142-环形链表-II⭐" class="headerlink" title="142. 环形链表 II⭐"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a>⭐</h4><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h4><h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4><h4 id="202-快乐数⭐⭐"><a href="#202-快乐数⭐⭐" class="headerlink" title="202. 快乐数⭐⭐"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a>⭐⭐</h4><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h4><h4 id="454-四数相加-II⭐"><a href="#454-四数相加-II⭐" class="headerlink" title="454. 四数相加 II⭐"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II⭐</a></h4><h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h4><h4 id="15-三数之和⭐⭐⭐"><a href="#15-三数之和⭐⭐⭐" class="headerlink" title="15. 三数之和⭐⭐⭐"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>⭐⭐⭐</h4><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h4><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><h4 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><h4 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h4><h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h4 id="27-移除元素-1"><a href="#27-移除元素-1" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h4><h4 id="344-反转字符串-1"><a href="#344-反转字符串-1" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h4><h4 id="剑指-Offer-05-替换空格-1"><a href="#剑指-Offer-05-替换空格-1" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><h4 id="151-反转字符串中的单词-1"><a href="#151-反转字符串中的单词-1" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><h4 id="206-反转链表-1"><a href="#206-反转链表-1" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><h4 id="19-删除链表的倒数第-N-个结点-1"><a href="#19-删除链表的倒数第-N-个结点-1" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><h4 id="15-三数之和⭐⭐⭐-1"><a href="#15-三数之和⭐⭐⭐-1" class="headerlink" title="15. 三数之和⭐⭐⭐"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>⭐⭐⭐</h4><h4 id="18-四数之和-1"><a href="#18-四数之和-1" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h4><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><p>232.用栈实现队列</p><ol><li>用队列实现栈</li></ol><ol><li><p>有效的括号</p><ol><li>删除字符串中的所有相邻重复项</li></ol></li><li><p>逆波兰表达式求值</p></li><li><p>滑动窗口最大值</p></li></ol><p>347.前 K 个高频元素</p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树的递归遍历</p><p>二叉树的迭代遍历</p><p>二叉树的统一迭代法</p><p>二叉树层序遍历</p><p>226.翻转二叉树</p><ol><li>对称二叉树</li></ol><p>104.二叉树的最大深度</p><p>111.二叉树的最小深度</p><p>222.完全二叉树的节点个数</p><p>110.平衡二叉树</p><ol><li>二叉树的所有路径<br>404.左叶子之和</li></ol><p>513.找树左下角的值</p><ol><li>路径总和</li></ol><p>106.从中序与后序遍历序列构造二叉树</p><p>654.最大二叉树</p><p>617.合并二叉树</p><p>700.二叉搜索树中的搜索</p><p>98.验证二叉搜索树</p><p>530.二叉搜索树的最小绝对差</p><p>501.二叉搜索树中的众数</p><ol><li><p>二叉树的最近公共祖先</p></li><li><p>二叉搜索树的最近公共祖先</p></li></ol><p>701.二叉搜索树中的插入操作</p><p>450.删除二叉搜索树中的节点</p><ol><li>修剪二叉搜索树</li></ol><p>108.将有序数组转换为二叉搜索树</p><p>538.把二叉搜索树转换为累加树</p><h1 id="单调栈⭐⭐⭐"><a href="#单调栈⭐⭐⭐" class="headerlink" title="单调栈⭐⭐⭐"></a>单调栈⭐⭐⭐</h1><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h4><h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><h4 id="503-下一个更大元素-II⭐"><a href="#503-下一个更大元素-II⭐" class="headerlink" title="503. 下一个更大元素 II⭐"></a><a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a>⭐</h4><h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h4><h1 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h1><h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h4><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4><h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h4 id="679-24-点游戏"><a href="#679-24-点游戏" class="headerlink" title="679. 24 点游戏"></a><a href="https://leetcode.cn/problems/24-game/">679. 24 点游戏</a></h4><h4 id="1262-可被三整除的最大和"><a href="#1262-可被三整除的最大和" class="headerlink" title="1262. 可被三整除的最大和"></a><a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/">1262. 可被三整除的最大和</a></h4><h4 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a><a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></h4><h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/post/8.html"/>
      <url>/post/8.html</url>
      
        <content type="html"><![CDATA[<h1 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h1><h3 id="JVM架构简图"><a href="#JVM架构简图" class="headerlink" title="JVM架构简图"></a>JVM架构简图</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/第02章_JVM架构-简图.jpg" alt="第02章_JVM架构-简图" style="zoom:33%;"></p><h3 id="JVM架构详细图（中文）"><a href="#JVM架构详细图（中文）" class="headerlink" title="JVM架构详细图（中文）"></a>JVM架构详细图（中文）</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/第02章_JVM架构-中.jpg" alt="第02章_JVM架构-中" style="zoom:33%;"></p><h3 id="JVM架构详细图（英文）"><a href="#JVM架构详细图（英文）" class="headerlink" title="JVM架构详细图（英文）"></a>JVM架构详细图（英文）</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/第02章_JVM架构-英.jpg" alt="第02章_JVM架构-英" style="zoom: 33%;"></p><h1 id="Class-Loader-Subsystem"><a href="#Class-Loader-Subsystem" class="headerlink" title="Class Loader Subsystem"></a>Class Loader Subsystem</h1><p><img src="http://cdn.leesin.fun/typora/s3/img/类加载子系统.png" alt="类加载子系统" style="zoom:33%;"></p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/类的加载过程.png" alt="类的加载过程"></p><h5 id="加载loading"><a href="#加载loading" class="headerlink" title="加载loading"></a>加载loading</h5><ol><li>通过一个类的全限定名获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>==在内存中生成一个代表这个类的java.lang.Class对象==，作为方法区这个类的各种数据的访问入口。</li></ol><h5 id="链接Linking-—-验证Verification"><a href="#链接Linking-—-验证Verification" class="headerlink" title="链接Linking — 验证Verification"></a>链接Linking — 验证Verification</h5><ul><li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，保证不会危害虚拟机自身安全。</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul><h5 id="链接Linking-—-准备Prepare"><a href="#链接Linking-—-准备Prepare" class="headerlink" title="链接Linking — 准备Prepare"></a>链接Linking — 准备Prepare</h5><ul><li>为类变量（static）分配内存，并且设置该类变量的默认初始值（即零值）<ul><li>==这里的类变量不包含用final修饰的static。==因为final在编译的时候就会分配了，准备阶段会显示初始化</li></ul></li><li>==准备阶段不会为实例变量分配初始化。==类变量分配在方法区中，而实例变量会随着对象一起分配到Java堆中。</li></ul><h5 id="链接Linking-—-解析Resolve"><a href="#链接Linking-—-解析Resolve" class="headerlink" title="链接Linking — 解析Resolve"></a>链接Linking — 解析Resolve</h5><ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li></ul><h5 id="初始化Initialization"><a href="#初始化Initialization" class="headerlink" title="初始化Initialization"></a>初始化Initialization</h5><ul><li><p>==初始化阶段就是执行类构造器方法 <code>&lt;clinit&gt;()</code> 的过程。==</p></li><li><p>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p></li><li>类构造器方法中指令按语句在源文件中出现的顺序执行。</li><li><code>&lt;clinit&gt;()</code> 不同于类的构造器。（构造器在虚拟机视角下是 <code>&lt;init&gt;()</code> ）</li><li>若该类具有父类，JVM会保证子类的 <code>&lt;clinit&gt;()</code> 执行前，父类的 <code>&lt;clinit&gt;()</code> 已经执行完毕。</li><li>虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程下被同步加锁。</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><p>有两种：==引导类加载器（Bootstrap ClassLoader）==和==自定义类加载器(User-Defined ClassLoader）==</p></li><li><p>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/类加载器的分类.png" alt="类加载器的分类" style="zoom:33%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">    System.out.println(systemClassLoader);</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">       System.out.println(extClassLoader);</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动类加载器（引导类加载器，Boostrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Boostrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Boostrap ClassLoader）"></a>启动类加载器（引导类加载器，Boostrap ClassLoader）</h5><ul><li>这个类加载器使用==C/C++语言实现的==，嵌套在JVM内部</li><li>它用来加载Java的核心库（jAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path 路径下的内容），用于提供JVM自身需要的类</li><li>并不继承 java.lang.ClassLoader ，没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父加载器</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun等开头的类。</li></ul><h5 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h5><ul><li>==Java语言编写==，由 sun.misc.Launcher$ExtClassLoader 实现</li><li>==是 java.lang.ClassLoader 的子类==</li><li>父加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（扩展目录）下加载类库。==如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。==</li></ul><h5 id="应用类加载器（系统类加载器，AppClassLoader）"><a href="#应用类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用类加载器（系统类加载器，AppClassLoader）"></a>应用类加载器（系统类加载器，AppClassLoader）</h5><ul><li>Java语言编写，由 sun.misc.Launcher$AppClassLoader 实现</li><li>==是 java.lang.ClassLoader 的子类==</li><li>父加载器为扩展类加载器</li><li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li><li>它是程序中默认的类加载器，一般来说， Java 应用的类都是由它来完成加载</li><li>通过 <code>ClassLoader.getSystemClassLoader()</code> 方法，可以获取到该类加载器</li></ul><h5 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h5><p>以上的启动类加载器、扩展类加载器、应用类加载器，都是虚拟机自带的加载器。下面我们学习自定义类加载器。</p><p>略，后续补充。</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java 虚拟机对 class 文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 Class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<strong>双亲委派模式</strong>，即把请求交由父类处理，它是一种任务委派模式。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/双亲委派模式-工作原理.png" alt="双亲委派模式-工作原理" style="zoom: 50%;"></p><blockquote><p>双亲委派机制的优点:</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改</li></ul></blockquote><h1 id="运行时数据区Runtime-Data-Area"><a href="#运行时数据区Runtime-Data-Area" class="headerlink" title="运行时数据区Runtime Data Area"></a>运行时数据区Runtime Data Area</h1><p><img src="http://cdn.leesin.fun/typora/s3/img/运行时数据区.png" alt="运行时数据区" style="zoom: 50%;"></p><blockquote><p>红色区域是线程共享的，灰色区域是线程私有的。</p></blockquote><p><img src="http://cdn.leesin.fun/typora/s3/img/运行时数据区-阿里版.png" alt="运行时数据区-阿里版"></p><blockquote><p>元数据区是方法区的落地实现。</p></blockquote><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><ul><li>线程私有</li><li>唯一一个不会OOM的区域</li><li>不用GC</li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul><li><p>线程私有的</p></li><li><p>栈不用GC，但是可能OOM</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss256k <span class="comment">// 设置线程的最大栈空间</span></span><br></pre></td></tr></table></figure><ul><li>线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）</li><li>栈帧内部又包含5个部分，如下图所示：</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/第05章_栈桢内部结构.jpg" alt="第05章_栈桢内部结构"></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ul><li>也叫做本地变量表</li><li>==定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量==，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li><li>由于局部变量表是建立在线程的栈上，是线程私有数据，因此==不存在数据安全问题==。</li><li>==局部变量表所需的容量大小是在编译期确定下来的==，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>main方法有三个变量：args[]、test、num</p><p>故Maximum local variables值为3（如下图）</p></blockquote><p><img src="http://cdn.leesin.fun/typora/s3/img/局部变量表示例1.png" alt="局部变量表示例1" style="zoom: 50%;"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/局部变量表示例2.png" alt="局部变量表示例2"></p><blockquote><p>Start PC：字节码指令行号</p><p>Length：变量有效的长度</p><p>关于槽（slot）的理解</p><ul><li>局部变量表 ==最基本的存储单元是 Slot（变量槽）==</li><li>在局部变量表中，==32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。==<ul><li>byte、short、char在存储前被转换为 int</li><li>boolean 也被转换为 int ，0表示 false，非0表示 true</li><li>long 和 double 则占据两个 slot</li></ul></li><li>如果当前帧是由<strong>构造方法</strong>或者<strong>实例方法</strong>创建的，==那么该对象引用 this 将会存放在 index 为0的 slot 处，==其余的参数按照参数表顺序继续排列。（下面给出示例）</li></ul></blockquote><p><img src="http://cdn.leesin.fun/typora/s3/img/局部变量表示例3.png" alt="局部变量表示例3" style="zoom:33%;"></p><blockquote><ul><li>==栈帧中的局部变量表中的槽位是可以重用的==，如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量就很有可能服用过期的局部变量的槽位，从而达到节省资源的目的。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经销毁的变量i占据的slot的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/局部变量表示例4.png" alt="局部变量表示例4" style="zoom:33%;"></p><blockquote><p>补充说明</p><ul><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① 成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">类变量： linking的prepare阶段：给类变量默认赋值  ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</span><br></pre></td></tr></table></figure></li><li><p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。</p><p>在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>==局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。==</p></li></ul></blockquote><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>略</p><h5 id="动态链接（指向运行时常量池的方法引用）"><a href="#动态链接（指向运行时常量池的方法引用）" class="headerlink" title="动态链接（指向运行时常量池的方法引用）"></a>动态链接（指向运行时常量池的方法引用）</h5><ul><li><p>每一个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接（Dynamic Linking）</strong>。比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</strong></p><p><img src="http://cdn.leesin.fun/typora/s3/img/第09章_方法区与栈的关联结构.jpg" alt="第09章_方法区与栈的关联结构"></p></li></ul><blockquote><p><strong>方法调用</strong></p><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制i有关。</p><ul><li>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li><li>动态链接：如果被调用的方法在编译器无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li></ul><p><strong>方法的调用：虚方法与非虚方法</strong></p><p>非虚方法：</p><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时时不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><p><strong>虚拟机中提供了以下几条方法调用指令：</strong></p><ul><li>普通调用指令：<ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<init>方法、私有方法、父类方法，解析阶段确定唯一方法版本</init></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol></li><li>动态调用指令：<ol><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ol></li></ul><p>前4条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本。<strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lyf.JVM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析调用中非虚方法、虚方法的测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * invokestatic指令和invokespecial指令调用的方法称为非虚方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020 下午 12:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="built_in">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>.showFinal();</span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showCommon();</span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span>&#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">so</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MethodInterface</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="返回地址（return-address）"><a href="#返回地址（return-address）" class="headerlink" title="返回地址（return address）"></a>返回地址（return address）</h5><ul><li>存放调用该方法的pc寄存器的值</li><li>一个方法的结束，有两种方式：<ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li></ul><ol><li>执行引擎遇到任意一个方法返回的字节码指令 (return)，会有返回值传递给上层的方法调用者，简称正常完成出口。</li></ol><blockquote><ul><li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值O的实际数据类型而定。</li><li>在字节码指令中，返回指令包含ireturn (当返回值是boolean、byte、char、short和int类型时使用)、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li></ul></blockquote><ol><li>在方法执行的过程中遇到了异常 (Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</li></ol><h5 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h5><p>略</p><blockquote><p>栈相关的一些面试题</p><ol><li>垃圾回收是否涉及到虚拟机栈？不会。</li><li>方法中定义的局部变量是否线程安全？具体问题具体分析。</li></ol></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="堆空间分布图"><a href="#堆空间分布图" class="headerlink" title="堆空间分布图"></a>堆空间分布图</h4><p><img src="http://cdn.leesin.fun/typora/img/image-20221123101857534.png" alt="image-20221123101857534" style="zoom:50%;"></p><h4 id="对应虚拟机参数一"><a href="#对应虚拟机参数一" class="headerlink" title="对应虚拟机参数一"></a>对应虚拟机参数一</h4><h5 id="1-设置堆空间大小的参数"><a href="#1-设置堆空间大小的参数" class="headerlink" title="1. 设置堆空间大小的参数"></a>1. 设置堆空间大小的参数</h5><ul><li><code>-Xms</code>用来设置堆空间（年轻代+老年代）的初始内存大小，等价于<code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code>用来设置堆空间（年轻代+老年代）的最大内存大小，等价于<code>-XX:MaxHeapSize</code></li></ul><blockquote><p>一旦堆区中的内存大小超过<code>-Xmx</code>所指定的最大内存时，将会抛出 OutOfMemoryError 异常。</p><p>-X 是jvm的运行参数， ms 是memory start</p></blockquote><h5 id="2-默认堆空间大小"><a href="#2-默认堆空间大小" class="headerlink" title="2. 默认堆空间大小"></a>2. 默认堆空间大小</h5><ul><li>初始内存大小：物理电脑内存大小 / 64</li><li>最大内存大小：物理电脑内存大小 / 4</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java虚拟机中的堆内存总量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 方式1需要如下代码</span></span><br><span class="line"><span class="comment">// try&#123;</span></span><br><span class="line"><span class="comment">//     TimeUnit.MILLISECONDS.sleep(1000000);</span></span><br><span class="line"><span class="comment">// &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//     e.printStackTrace();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-Xms : 368M</span></span><br><span class="line"><span class="comment">-Xmx : 5451M</span></span><br><span class="line"><span class="comment">系统内存大小为：23G</span></span><br><span class="line"><span class="comment">系统内存大小为：21G</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="3-手动设置"><a href="#3-手动设置" class="headerlink" title="3. 手动设置"></a>3. 手动设置</h5><p>-Xms600m -Xmx600m</p><p>开发中建议将初始堆内存和最大的堆内存设置成相同的值，目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区大小，从而提高性能。</p><h5 id="4-查看设置的参数"><a href="#4-查看设置的参数" class="headerlink" title="4. 查看设置的参数"></a>4. 查看设置的参数</h5><p>（注：以下两个方式都使用上一个代码块的代码）</p><p>方式一：</p><blockquote><p>虚拟机参数如下：<br><code>-Xms600m -Xmx600m</code></p><p>然后打开cmd：</p><p>第一步：查看java进程，使用命令<code>jps</code></p><p>第二步：<code>jstat -gc 进程id</code></p></blockquote><p><img src="http://cdn.leesin.fun/typora/img/查看栈的内部结构分配1.png" alt="查看栈的内部结构分配1"></p><p>方式二：-XX:+PrintGCDetails</p><blockquote><p>虚拟机参数如下：<br><code>-Xms600m -Xmx600m -XX:+PrintGCDetails</code></p></blockquote><p><img src="http://cdn.leesin.fun/typora/img/查看栈的内部结构分配2.png" alt="查看栈的内部结构分配2"></p><blockquote><p>为什么明明参数设置的是600M，实际输出只有575M呢？</p><p>答：575M = eden区 + survivor0区 + 老年代区</p><p>（surivor0区和surivor1区只算了其中1个）</p></blockquote><h4 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h4><p><img src="http://cdn.leesin.fun/typora/img/年轻代与老年代.png" alt="年轻代与老年代"></p><h5 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h5><ul><li><code>-XX:NewRatio</code>：设置新生代与老年代的比例。默认值是<code>-XX:NewRatio=2</code>，即新生代:老年代=1：2</li><li><code>-XX:SurvivorRatio</code>：设置新生代中Eden区与Survivor区的比例。如<code>-XX:SurvivorRatio=8</code>，表示 Eden区：Survivor1区：Surivivor2区=8：1：1</li></ul><blockquote><ul><li>几乎所有的Java对象都是在 Eden 区被 new 出来的。</li><li>绝大部分的Java对象的销毁都在新生代进行了。</li><li>可以使用选项<code>-Xmn</code>设置新生代最大内存大小。（这个选项一般不进行设置）</li></ul></blockquote><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟机参数为-Xms600m -Xmx600m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从输出结果可以看出来</span></span><br><span class="line"><span class="comment">// 新生代：老年代 = 200M : 400M = 1 ： 2</span></span><br><span class="line"><span class="comment">// Eden区 ： Survivor0区 ： Survivor1区 = 160M : 20M : 20M = 8 : 1 : 1</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/img/参数示例1.png" alt="参数示例1"></p><h5 id="涉及的垃圾回收"><a href="#涉及的垃圾回收" class="headerlink" title="涉及的垃圾回收"></a>涉及的垃圾回收</h5><p><img src="http://cdn.leesin.fun/typora/img/image-20221123102127036.png" alt="image-20221123102127036" style="zoom: 50%;"></p><blockquote><ul><li>对于幸存者s0、s1区的总结：复制之后有交换，谁空谁是to区</li><li>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</li></ul></blockquote><p><img src="http://cdn.leesin.fun/typora/img/对象分配.png" alt="对象分配"></p><h4 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h4><p>JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：部分收集（Partial GC）和整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：只是新生代（Eden,s0,s1）的垃圾收集</li><li>老年代收集（Major GC/Old GC）:只是老年代的垃圾收集。<ul><li>目前，只有CMS的GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，一定要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1的GC会有这种行为。</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li></ul><h5 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h5><ul><li>当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是Eden区满，Survior 区满是不会引发 GC 的。（每次Minor GC 会清理年轻代的内存）</li><li>因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>Minor GC 会引发 STW，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行。</li></ul><h5 id="Major-GC和Full-GC"><a href="#Major-GC和Full-GC" class="headerlink" title="Major GC和Full GC"></a>Major GC和Full GC</h5><p>暂时略</p><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li>优先分配到 Eden</li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</li></ul></li><li>空间分配担保<ul><li><code>-XX:HandlePromotionFailure</code></li></ul></li></ul><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><h3 id="常量池基本概念"><a href="#常量池基本概念" class="headerlink" title="常量池基本概念"></a>常量池基本概念</h3><ul><li>字符串常量池是一个固定大小的 Hashtable，jdk8中默认值大小是60013。如果放进String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，调用 String.intern 时性能会大幅下降。</li><li>使用<code>-XX:StringTableSize</code>可以设置 StringTable 的长度</li></ul><blockquote><ul><li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。为了使这些类型在运行种速度更快、更节省内存，都提供了一种常量池的概念。</li><li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池是系统协调的，<strong>String类型的常量池比较特殊。它主要使用方法有两种：</strong><ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。<ul><li>比如：<code>String str = &quot;abc&quot;;</code></li></ul></li><li>可以使用String提供的intern方法。</li></ul></li></ul></blockquote><h3 id="StringTable的内存分配⭐⭐⭐"><a href="#StringTable的内存分配⭐⭐⭐" class="headerlink" title="StringTable的内存分配⭐⭐⭐"></a>StringTable的内存分配⭐⭐⭐</h3><ul><li>Java 6及以前，字符串常量池存放在永久代。</li><li>==java 7开始，字符串常量池放在java堆内。==⭐⭐⭐</li></ul><blockquote><p>面试题：StringTable为什么这样调整位置？</p><ol><li>永久代空间默认比较小</li><li>永久代回收频率低</li></ol></blockquote><h3 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h3><ol><li>常量与常量的拼接结果在常量池，原理是编译期（生成.class）优化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是test1对应的字节码指令：</p><p><img src="http://cdn.leesin.fun/typora/img/test1的字节码.png" alt="test1的字节码" style="zoom: 80%;"></p><p>下图是字节码文件的反编译结果：</p><p><img src="http://cdn.leesin.fun/typora/img/test1的反编译结果.png" alt="test1的反编译结果"></p><ol><li>常量池中不会存在相同内容的常量。</li><li>只有其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">    ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">    ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test3的字节码如下：</p><p><img src="http://cdn.leesin.fun/typora/img/test3的字节码.png" alt="test3的字节码"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。（后面详细讲）</li></ol><h3 id="字符串拼接与StringBuilder的append操作的效率对比"><a href="#字符串拼接与StringBuilder的append操作的效率对比" class="headerlink" title="字符串拼接与StringBuilder的append操作的效率对比"></a>字符串拼接与StringBuilder的append操作的效率对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method1(100000);// 4014ms</span></span><br><span class="line">    method2(<span class="number">100000</span>);<span class="comment">// 7ms</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">        src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">    <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</p><ol><li><p>StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</p><p>使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</p></li><li><p>使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；</p><p>如果进行GC，需要花费额外的时间。</p></li></ol><p>改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</p></blockquote><h3 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h3><h5 id="如何保证变量s指向的是字符串常量池中的数据呢"><a href="#如何保证变量s指向的是字符串常量池中的数据呢" class="headerlink" title="如何保证变量s指向的是字符串常量池中的数据呢?"></a>如何保证变量s指向的是字符串常量池中的数据呢?</h5><blockquote><p>有两种方式：</p><ol><li><p>字面量定义的方式 <code>String s = &quot;hello&quot;;</code></p></li><li><p>调用intern() <code>String s = new String(&quot;hello&quot;).intern();</code></p><p>或 <code>String s = new StringBuilder(&quot;hello&quot;).toString().intern();</code></p><p>等</p></li></ol></blockquote><h5 id="问题1：-new-String-quot-ab-quot-会创建几个对象呢？⭐⭐⭐"><a href="#问题1：-new-String-quot-ab-quot-会创建几个对象呢？⭐⭐⭐" class="headerlink" title="问题1： new String(&quot;ab&quot;) 会创建几个对象呢？⭐⭐⭐"></a>问题1： <code>new String(&quot;ab&quot;)</code> 会创建几个对象呢？⭐⭐⭐</h5><blockquote><p>答案：2个对象，从字节码知道。</p><ul><li><p>一个对象是：new 关键字在堆空间中创建的</p></li><li><p>另一个对象是：字符串常量池中的对象。字节码指令：ldc</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/img/new String的字节码.png" alt="new String的字节码"></p><h5 id="问题2：-new-String-quot-a-quot-new-String-quot-b-quot-会创建几个对象呢？"><a href="#问题2：-new-String-quot-a-quot-new-String-quot-b-quot-会创建几个对象呢？" class="headerlink" title="问题2： new String(&quot;a&quot;) + new String(&quot;b&quot;) 会创建几个对象呢？"></a>问题2： <code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 会创建几个对象呢？</h5><blockquote><p>答案：6个对象，从字节码知道。</p><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)   在堆中</li><li>对象3：常量池中的”a”</li><li>对象4：new String(“b”)   在堆中</li><li>对象5：常量池中的”b”</li><li>对象6：StringBuilder的toString()<ul><li>new String(“ab”)</li><li>==<strong>强调一下：toString()的调用，在字符串常量池中，没有生成”ab”</strong>==</li></ul></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法的字节码：</p><p><img src="http://cdn.leesin.fun/typora/img/new String + new String 的字节码.png" alt="new String + new String 的字节码"></p><p>StringBuilder的toString()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>StringBuilder的toString()方法的字节码：</p><p><img src="http://cdn.leesin.fun/typora/img/StringBuilder的toString(" alt="StringBuilder的toString()方法的字节码">方法的字节码.png)</p><blockquote><p>可以看到，StringBuilder的toString()方法的字节码并没有ldc指令。</p><p>也就是说，调用StringBuilder的toString()方法，不会在字符串常量池中生成”ab”</p></blockquote><h5 id="一道面试难题的引入"><a href="#一道面试难题的引入" class="headerlink" title="一道面试难题的引入"></a>一道面试难题的引入</h5><p>有了前面两个问题的基础，下面来看这道面试难题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下输出什么？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    s3.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案解析如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    System.out.println(s == s2);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">    s3.intern();<span class="comment">//在字符串常量池中生成&quot;11&quot;。如何理解：此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存图如下：</p><p><img src="http://cdn.leesin.fun/typora/img/面试难题内存图.png" alt="面试难题内存图"></p><h5 id="面试题的拓展"><a href="#面试题的拓展" class="headerlink" title="面试题的拓展"></a>面试题的拓展</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">    <span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;<span class="comment">//在字符串常量池中生成对象&quot;11&quot;</span></span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结intern-的使用"><a href="#总结intern-的使用" class="headerlink" title="总结intern()的使用"></a>总结intern()的使用</h5><blockquote><p><code>字符串对象.intern()</code> 的原理</p><p>jdk7起，将这个字符串对象尝试放入串池。</p><pre><code>1. 如果串池中有，则并不会放入。返回已有的串池中的对象地址。1. 如果没有，则会把==对象的引用地址复制一份==，放入串池，并返回串池中的引用地址。</code></pre></blockquote><h5 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="comment">// 此时串池有&quot;a&quot;和&quot;b&quot;，并没有&quot;ab&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// 串池中没有创建字符串&quot;ab&quot;，而是创建一个引用，值为s。即s2 = s</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/img/练习1内存图.png" alt="练习1内存图"></p><h5 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">X</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 串池中创建了&quot;ab&quot;对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">    System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/img/练习2内存图.png" alt="练习2内存图"></p><h5 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    s1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s1是堆中的对象，s2是串池中的对象</span></span><br></pre></td></tr></table></figure><h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><p>略</p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h2><h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><p>当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p>引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的<strong>引用计数器属性</strong>。<u>用于记录对象被引用的情况。</u></p><blockquote><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1;当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p></blockquote><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li><p>实现简单，垃圾对象便于辨识;</p></li><li><p>判定效率高，回收没有延迟性。</p></li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>它需要单独的字段存储计数器，这样的做法<strong>增加了存储空间的开销</strong>.</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这<strong>增加了时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。<u>这是一条致命缺陷导致在Java的垃圾回收器中没有使用这类算法。</u></li></ul><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h3><p>又叫根搜索算法、追踪性垃圾收集</p><ul><li><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p></li><li><p>所谓”GC Roots”根集合就是一组必须活跃的引用</p></li></ul><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><ul><li>可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链(Reference chain)</strong></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/可达性分析算法.png" alt="可达性分析算法"></p><h5 id="GC-ROOT⭐⭐⭐"><a href="#GC-ROOT⭐⭐⭐" class="headerlink" title="GC ROOT⭐⭐⭐"></a>GC ROOT⭐⭐⭐</h5><p>在Java 语言中， GC Roots 包括以下几类元素:</p><ul><li><p>虚拟机栈中引用的对象</p><ul><li>比如:各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li><p>本地方法栈内JNI(通常说的本地方法)引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p><ul><li>比如: Java类的引用类型静态变量</li></ul></li><li><p>方法区中常量引用的对象</p><ul><li>比如:字符串常量池(string Table)里的引用</li></ul></li><li><p>所有被同步锁synchronized持有的对象</p></li><li><p>Java虚拟机内部的引用。</p><ul><li>基本数据类型对应的class对象，一些常驻的异常对象 (如:NullPointerException、OutOfMemoryError)，系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><h2 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h2><h3 id="1-标记-清除（Mark-sweep）算法"><a href="#1-标记-清除（Mark-sweep）算法" class="headerlink" title="1.标记-清除（Mark-sweep）算法"></a>1.标记-清除（Mark-sweep）算法</h3><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><p>当堆中的有效内存空间 (available memory)被耗尽的时候，就会停止整个程序(也被称为stop the world)，然后进行两项工作，第一项则是标记,第二项则是清除。</p><ul><li>标记: Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li><li>清除: Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/第14章_标记-清除算法.jpg" alt="第14章_标记-清除算法"></p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li><li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表</li></ul><blockquote><p>注意:何为清除?<br>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</p></blockquote><h3 id="2-复制（Copying）算法"><a href="#2-复制（Copying）算法" class="headerlink" title="2.复制（Copying）算法"></a>2.复制（Copying）算法</h3><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/第14章_复制算法.jpg" alt="第14章_复制算法"></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li><li>特别的:如果系统中的垃圾对象很多，复制算法效率不会很理想。</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。（老年代不适合用这个算法）</p><h3 id="3-标记-压缩（Mark-compact）算法-（也叫标记-整理算法）"><a href="#3-标记-压缩（Mark-compact）算法-（也叫标记-整理算法）" class="headerlink" title="3.标记-压缩（Mark-compact）算法  （也叫标记-整理算法）"></a>3.标记-压缩（Mark-compact）算法  （也叫标记-整理算法）</h3><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><ul><li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</li><li>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM 的设计者需要在此基础之上进行改进。标记，压缩 (Mark - Compact)算法由此诞生。</li><li>1970 年前后， G，L.Steele 、C.J，chene 和D.S。wise 等研究者发布标记压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li></ul><h5 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h5><ul><li>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。<br>之后，清理边界外所有的空间</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/第14章_标记-压缩算法.jpg" alt="第14章_标记-压缩算法"></p><blockquote><ul><li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法</li></ul><ul><li>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策.</li></ul><ul><li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li></ul></blockquote><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><ul><li>从效率上来说，标记-整理算法要低于复制算法</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li><li>移动过程中，需要全程暂停用户应用程序。即:STW</li></ul><h3 id="指针碰撞-Bumpthe-Pointer"><a href="#指针碰撞-Bumpthe-Pointer" class="headerlink" title="指针碰撞(Bumpthe Pointer)"></a>指针碰撞(Bumpthe Pointer)</h3><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞 (Bump the Pointer)。</p><h3 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h3><p><strong>目前几乎所有的GC都是采用分代收集 (Generational collecting) 算法执行垃圾回收的</strong><br>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特<br>点</p><h5 id="年轻代-Young-Gen"><a href="#年轻代-Young-Gen" class="headerlink" title="年轻代(Young Gen)"></a>年轻代(Young Gen)</h5><ul><li><p>年轻代特点:区域相对老年代较小，对象生命周期短、存活率低,回收频繁。</p></li><li><p>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于<br>年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。（8：1：1）</p></li></ul><h5 id="老年代-Tenured-Gen"><a href="#老年代-Tenured-Gen" class="headerlink" title="老年代(Tenured Gen)"></a>老年代(Tenured Gen)</h5><ul><li><p>老年代特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p></li><li><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记整理的混合实现。</p></li></ul><blockquote><p>Mark阶段的开销与存活对象的数量成正比<br>sweep阶段的开销与所管理区域的大小成正相关<br>compact阶段的开销与存活对象的数据成正比。</p></blockquote><p>举例</p><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施:当内存回收不佳(碎片导致的concurrent ModeFailure时)，将采用serial old执行Ful1 GC以达到对老年代内存的整理<br>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h2><p>在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Ful1 GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。<br>然而system.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。</p><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>原因：</p><p>(1)Java虚拟机的内存设置不够<br>(2)代码中创建了大量大对象，并且长时间不能被垃圾收器收(存在被引用)</p><p>这里面隐含着一层意思是，在抛出outofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如:在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等</li></ul><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</li></ul><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常导致程序崩溃。<br>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/内存泄漏.png" alt="内存泄漏"></p><p>举例：ThreadLocal</p><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>stop-the-world ，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应有点像卡死的感觉，这个停顿称为STW。</p><ul><li><p>如：可达性分析算法中枚举根节点 (GC Roots)会导致所有Java执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间，整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li></ul></li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h5 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h5><p>并行(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</p><ul><li>如ParNew、Parallel Scavenge、Parallel Old;</li></ul><p>串行 (Serial)</p><ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/垃圾回收器的并行.png" alt="垃圾回收器的并行"></p><h5 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h5><p>并发 (Concurrent):指用户线程与垃圾收集线程同时执行 (但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行。</p><ul><li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上;</li><li>如: CMS、G1</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/垃圾回收器的并发.png" alt="垃圾回收器的并发"></p><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h2 id="强软弱虚引用"><a href="#强软弱虚引用" class="headerlink" title="强软弱虚引用"></a>强软弱虚引用</h2><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用(strongReference)、软引用 (SoftReference)、弱引用 (WeakReference)和虚引用(PhantomReference) 4种，<strong>这4种引用强度依次逐渐减弱。</strong><br>除强引用外，其他3种引用均可以在iava.lang.ref包中找到它们的身影。</p><ul><li>强引用 (strongReference) ：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new object()”这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li><li>软引用 (softReference)：<strong>内存不足就会GC回收软引用</strong>。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。 </li><li>弱引用 (WeakReference)：被弱引用关联的对象只能生存到下一次垃圾收集之前。<strong>当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</strong></li><li>虚引用 (PhantomReference)：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的<strong>唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><p>按<strong>线程</strong>分，分为<u>串行垃圾回收器</u>和<u>并行垃圾回收器</u></p><p><img src="http://cdn.leesin.fun/typora/s3/img/垃圾回收器按线程分类.png" alt="垃圾回收器按线程分类"></p><p>按<strong>工作模式</strong>分，分为<u>独占式垃圾回收器</u>和<u>并发式垃圾回收器</u>。</p><ul><li><p>独占式垃圾回收器(stop the world)一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</p></li><li><p>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</p></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/垃圾回收器按工作模式分类.png" alt="垃圾回收器按工作模式分类"></p><p>按<strong>碎片处理方式</strong>分，分为<u>压缩式垃圾回收器</u>和<u>非压缩式垃圾回收器</u></p><ul><li><p>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p><ul><li>再分配对象空间使用：指针碰撞</li></ul></li><li><p>非压缩式的垃圾回收器不进行这步操作</p><ul><li>再分配对象空间使用：空闲列表</li></ul></li></ul><p>按<strong>工作的内存区间</strong>分，又可分为<u>年轻代垃圾回收器</u>和<u>老年代垃圾回收器</u></p><h2 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h2><ul><li><strong>吞吐量: 运行用户代码的时间占总运行时间的比例</strong><ul><li>(总运行时间:程序的运行时间 + 内存回收的时间)</li></ul></li><li>垃圾收集开销:吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li><li><strong>暂停时间:执行垃圾收集时，程序的工作线程被暂停的时间</strong></li><li>收集频率:相对于应用程序的执行，收集操作发生的频率</li><li><strong>内存占用: java 堆区所占的内存大小。</strong></li><li>快速:一个对象从诞生到被回收所经历的时间.</li></ul><blockquote><p>在设计 (或使用) GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一(即只专注于较大吞吐量或最小暂停时间)，或尝试找到一个二者的折衷。<br>现在标准:在最大吞吐量优先的情况下，降低停顿时间。</p></blockquote><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/第17章_经典的7种GC.jpg" alt="第17章_经典的7种GC"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/第17章_垃圾收集器组合.jpg" alt="第17章_垃圾收集器组合"></p><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><ul><li><p>Serial 收集器采用<strong>复制算法</strong>、<strong>串行回收</strong>和<strong>”stop-the-world”机制</strong>的方式执行内存回收。</p></li><li><p>Serial  Old收集器采用<strong>标记-压缩算法</strong>、<strong>串行回收</strong>和<strong>”stop-the-world”机制</strong>的方式执行内存回收。</p></li><li><p>优势：简单高效</p></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/Serial和Serial Old收集器.png" alt="Serial和Serial Old收集器"></p><p>虚拟机参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line"><span class="comment">// 等价于新生代用Serial，老年代用Serial Old</span></span><br></pre></td></tr></table></figure><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><ul><li><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。</p><ul><li>（Par是Parallel的缩写，New:<strong>只能处理的是新生代</strong>）</li></ul></li><li><p>ParNew收集器采用<strong>复制算法</strong>、<strong>并行回收</strong>和<strong>“stop-the-world”机制</strong>。</p><ul><li>（ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别）</li></ul></li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/ParNew和Serial Old收集器.png" alt="ParNew和Serial Old收集器"></p><p>虚拟机参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC</span><br></pre></td></tr></table></figure><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><ul><li><p>Parallel Scavenge收集器采用<strong>复制算法</strong>、<strong>并行回收</strong>和<strong>”stopthe world”机制</strong>。</p></li><li><p>Parallel old 收集器采用<strong>标记-压缩算法</strong>，<strong>并行回收</strong>和<strong>”stop-the-world”机制</strong>。</p></li><li>==JDK8中默认使用Parallel回收器==</li></ul><blockquote><p>那么Paralle收集器的出现是否多此一举?</p><ul><li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong> (Throughput)，它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别</li></ul><p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<strong>适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行==批量处理、订单处理、工资支付、科学计算==的应用程序。</p></blockquote><p>虚拟机参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"><span class="comment">// 上面两个参数，默认开启一个，另一个也会被开启(互相激活)</span></span><br></pre></td></tr></table></figure><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><ul><li><p>在 JDK 1.5 时期，Hotspot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent-Mark-Sweep)收集器，这款收集器是Hotspot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让<strong>垃圾收集线程与用户线程同时工作</strong>。</p></li><li><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p></li><li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验CMS收集器就非常符合这类应用的需求。</li><li>CMS的垃圾收集算法采用<strong>标记-清除算法</strong>，并且也会<strong>”stop-the-world”</strong></li></ul><blockquote><ul><li>不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4. 中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</li><li>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</li></ul></blockquote><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="http://cdn.leesin.fun/typora/s3/img/CMS收集器.png" alt="CMS收集器"></p><p>CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p><ul><li>初始标记 （Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务==仅仅只是标记出GC Roots能直接关联到的对象。==一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的==速度非常快。==</li><li>并发标记 （Concurrent-Mark） 阶段： 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程<strong>耗时较长</strong>但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。</li><li>重新标记 （Remark）阶段： 由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li>并发清除 （concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</p></li><li><p>G1 GC有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p></li></ul><h4 id="G1回收器的特点（优势）"><a href="#G1回收器的特点（优势）" class="headerlink" title="G1回收器的特点（优势）"></a>G1回收器的特点（优势）</h4><h5 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h5><ul><li><p>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理。</p></li><li><p>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的<strong>Region之间是复制算法</strong>，但整体上实际可看作是 <u>标记-压缩 （Mark-Compact）算法</u> ，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p></li></ul><h5 id="可预测的停顿时间模型（即-软实时soft-real-time）"><a href="#可预测的停顿时间模型（即-软实时soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即: 软实时soft real-time）"></a>可预测的停顿时间模型（即: 软实时soft real-time）</h5><p>这是 G1 相对于 CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过  N 毫秒。</p><ul><li><p>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p></li><li><p>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，==每次根据允许的收集时间，优先回收价值最大的Region==。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p></li><li><p>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p></li></ul><h4 id="G1回收器的缺点"><a href="#G1回收器的缺点" class="headerlink" title="G1回收器的缺点"></a>G1回收器的缺点</h4><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h4 id="G1回收器的参数设置"><a href="#G1回收器的参数设置" class="headerlink" title="G1回收器的参数设置"></a>G1回收器的参数设置</h4><p><code>-XX: +UseG1GC</code>：手动指定使用G1收集器执行内存回收任务。</p><p><code>-XX:G1HeapRegionSize</code>：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</p><p><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms</p><p><code>-XX: ParallelGCThread</code>：设置STW工作线程数的值。最多设置为8</p><p><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。</p><p><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p><blockquote><p>G1的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优:</p><p>第一步:开启G1垃圾收集器</p><p>第二步:设置堆的最大内存</p><p>第三步:设置最大的停顿时间</p><p>G1中提供了三种垃圾回收模式: YoungGc、Mixed GC和Full GC，在不同的条件下被触发。</p></blockquote><h4 id="G1回收器的适用场景"><a href="#G1回收器的适用场景" class="headerlink" title="G1回收器的适用场景"></a>G1回收器的适用场景</h4><ul><li><p>面向服务端应用，针对具有大内存、多处理器的机器。(在普通大小的堆里表现并不惊喜)</p></li><li><p>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案;</p><ul><li>如:在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；(G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长)。</li></ul></li><li><p>用来替换掉JDK1.5中的CMS收集器;</p><ul><li><p>在下面的情况时，使用G1可能比CMS好:</p><ol><li><p>超过50%的Java堆被活动数据占用;</p></li><li><p>对象分配频率或年代提升频率变化很大；</p></li><li><p>GC停顿时间过长(长于0.5至1秒)。</p></li></ol></li></ul></li></ul><blockquote><p>Hotspot 垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</p></blockquote><h4 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h4><p>使用 G1 收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过-XX:G1HeapRegionSize设定。<strong>所有的Region大小相同，且在JVM生命周期内不会被改变。</strong></p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/G1的分区Region.png" alt="G1的分区Region"></p><p>一个 region 有可能属于 Eden，Survivor 或者 old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的 E 表示该region属于Eden内存区域，s表示属于survivor内存区域，o表示属于old内存区域。图中空白的表示未使用的内存空间。</p><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p>设置H的原因:<br>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<strong>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Ful1 GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><h5 id="分区Region的细节：指针碰撞"><a href="#分区Region的细节：指针碰撞" class="headerlink" title="分区Region的细节：指针碰撞"></a>分区Region的细节：指针碰撞</h5><p><img src="http://cdn.leesin.fun/typora/s3/img/分区region的细节.png" alt="分区region的细节"></p><h4 id="Remebered-Set"><a href="#Remebered-Set" class="headerlink" title="Remebered Set"></a>Remebered Set</h4><p><img src="http://cdn.leesin.fun/typora/s3/img/Rset.png" alt="Rset"></p><p>一个对象被不同区域引用的问题：一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用判断对象存活时，是否需要扫描整个Java堆才能保证准确？回收新生代也不得不同时扫描老年代？这样的话会降低minor GC的效率;</p><p>解决方法:</p><ul><li><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p></li><li><p>每个Region都有一个对应的Remembered Set;</p></li><li><p>每次Reference类型数据写操作时，都会产生一个write Barrier暂时中断操作;</p></li><li><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器:检查老年代对象是否引用了新生代对象);</p></li><li><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p></li><li><p>当进行垃圾收集时，==<strong>在GC根节点的枚举范围加入Remembered Set;</strong>== 就可以保证不进行全局扫描，也不会有遗漏。</p></li></ul><h2 id="垃圾回收器总结⭐⭐⭐"><a href="#垃圾回收器总结⭐⭐⭐" class="headerlink" title="垃圾回收器总结⭐⭐⭐"></a>垃圾回收器总结⭐⭐⭐</h2><p>如果你想要最小化地使用内存和并行开销，请选Serial GC;</p><p>如果你想要最大化应用程序的吞吐量，请选Parallel GC</p><p>如果你想要最小化GC的中断或停顿时间，请选CMS GC</p><div class="table-container"><table><thead><tr><th style="text-align:center">垃圾收集器</th><th style="text-align:center">分类</th><th style="text-align:center">作用位置</th><th style="text-align:center">使用算法</th><th style="text-align:center">特点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">Serial</td><td style="text-align:center">串行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单CPU环境下的client模式</td></tr><tr><td style="text-align:center">ParNew</td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">多CPU环境Server模式下与CMS配合使用</td></tr><tr><td style="text-align:center">Parallel</td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">后台运算，不需要太多交互</td></tr><tr><td style="text-align:center">Serial Old</td><td style="text-align:center">串行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-压缩算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单CPU环境下的client模式</td></tr><tr><td style="text-align:center">Parallel Old</td><td style="text-align:center">并行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-压缩算法</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">后台运算，不需要太多交互</td></tr><tr><td style="text-align:center">CMS</td><td style="text-align:center">并发</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-清除算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">互联网或B/S业务</td></tr><tr><td style="text-align:center">G1</td><td style="text-align:center">并发、并行</td><td style="text-align:center">新生代、老年代</td><td style="text-align:center">标记-压缩算法、复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">面向服务端应用</td></tr></tbody></table></div><h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/post/4.html"/>
      <url>/post/4.html</url>
      
        <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名</span><br></pre></td></tr></table></figure><blockquote><p>创建用户成功后，会自动创建和用户同名的家目录。</p><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 home]<span class="comment"># ls</span></span><br><span class="line">itachi</span><br><span class="line">[root@itachi103 home]<span class="comment"># useradd tom</span></span><br><span class="line">[root@itachi103 home]<span class="comment"># ls</span></span><br><span class="line">itachi  tom</span><br></pre></td></tr></table></figure></blockquote><h2 id="指定-修改密码"><a href="#指定-修改密码" class="headerlink" title="指定/修改密码"></a>指定/修改密码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名</span><br></pre></td></tr></table></figure><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><ol><li>删除用户，但是保留了家目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel 用户名</span><br></pre></td></tr></table></figure><ol><li>删除用户以及用户主目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r 用户名</span><br></pre></td></tr></table></figure><h2 id="查询用户信息指令"><a href="#查询用户信息指令" class="headerlink" title="查询用户信息指令"></a>查询用户信息指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> 用户名</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 home]<span class="comment"># id root</span></span><br><span class="line">uid=0(root) gid=0(root) 组=0(root)</span><br><span class="line"></span><br><span class="line">[root@itachi103 home]<span class="comment"># id tom</span></span><br><span class="line">uid=1001(tom) gid=1001(tom) 组=1001(tom)</span><br></pre></td></tr></table></figure><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p>在操作Linux中，如果当前用户的权限不够，可以通过su - 指令，切换到高权限用户，比如root</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - 用户名</span><br></pre></td></tr></table></figure><blockquote><ol><li>从高权限用户切换到低权限用户，不需要输入密码，反之需要。</li><li>当需要返回到原来用户时，使用 <code>exit</code> 或 <code>logout</code> 指令</li></ol></blockquote><h2 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><h2 id="查看登录用用户"><a href="#查看登录用用户" class="headerlink" title="查看登录用用户"></a>查看登录用用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> am i</span><br></pre></td></tr></table></figure><blockquote><p><code>whoami</code> 显示的是当前使用的身份</p><p>而 <code>who am i</code> 显示的是最初登录的身份</p></blockquote><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><h3 id="新增组"><a href="#新增组" class="headerlink" title="新增组"></a>新增组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组名</span><br></pre></td></tr></table></figure><h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><h3 id="添加用户时，给其指定组"><a href="#添加用户时，给其指定组" class="headerlink" title="添加用户时，给其指定组"></a>添加用户时，给其指定组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -g 组名 用户名</span><br></pre></td></tr></table></figure><blockquote><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 home]<span class="comment"># groupadd wudang</span></span><br><span class="line">[root@itachi103 home]<span class="comment"># useradd -g wudang zhangwuji</span></span><br><span class="line">[root@itachi103 home]<span class="comment"># id zhangwuji</span></span><br><span class="line">uid=1002(zhangwuji) gid=1002(wudang) 组=1002(wudang)</span><br></pre></td></tr></table></figure></blockquote><h3 id="添加用户时，未指定指定组"><a href="#添加用户时，未指定指定组" class="headerlink" title="添加用户时，未指定指定组"></a>添加用户时，未指定指定组</h3><p>添加用户时，未指定指定组，则默认会创建一个跟用户名相同的组，并且把该用户放在该组中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 home]<span class="comment"># useradd leesin</span></span><br><span class="line">[root@itachi103 home]<span class="comment"># id leesin</span></span><br><span class="line">uid=1003(leesin) gid=1003(leesin) 组=1003(leesin)</span><br></pre></td></tr></table></figure><h2 id="修改用户的组"><a href="#修改用户的组" class="headerlink" title="修改用户的组"></a>修改用户的组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g 组名 用户名</span><br></pre></td></tr></table></figure><p>举例：将zhangwuji修改组为mojiao</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 home]<span class="comment"># id zhangwuji</span></span><br><span class="line">uid=1002(zhangwuji) gid=1002(wudang) 组=1002(wudang)</span><br><span class="line">[root@itachi103 home]<span class="comment"># groupadd mojiao</span></span><br><span class="line">[root@itachi103 home]<span class="comment"># usermod -g mojiao zhangwuji </span></span><br><span class="line">[root@itachi103 home]<span class="comment"># id zhangwuji</span></span><br><span class="line">uid=1002(zhangwuji) gid=1003(mojiao) 组=1003(mojiao)</span><br></pre></td></tr></table></figure><h2 id="用户和组的相关文件"><a href="#用户和组的相关文件" class="headerlink" title="用户和组的相关文件"></a>用户和组的相关文件</h2><ul><li><code>/etc/passwd</code> 文件</li></ul><p>用户的配置文件，记录用户的各种信息</p><ul><li><code>/etc/shadow</code> 文件</li></ul><p>口令的配置文件，记录了用户加密过后的密码</p><ul><li><code>/etc/group</code> 文件</li></ul><p>组的配置文件，记录Linux包含的组的信息</p><h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><blockquote><p>0：关机</p><p>1：单用户【找回丢失密码】</p><p>2：多用户状态没有网络服务</p><p>3：多用户状态有网络服务，无界面</p><p>4：系统未使用，保留</p><p>5：图形界面</p><p>6：系统重启</p><p>常用的运行级别是3和5，也可以指定默认运行级别</p></blockquote><h3 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a>切换运行级别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init [0/1/2/3/4/5/6]</span><br></pre></td></tr></table></figure><h3 id="查看默认运行级别"><a href="#查看默认运行级别" class="headerlink" title="查看默认运行级别"></a>查看默认运行级别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default </span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 ~]<span class="comment"># systemctl get-default </span></span><br><span class="line">graphical.target</span><br></pre></td></tr></table></figure><h3 id="修改默认运行级别"><a href="#修改默认运行级别" class="headerlink" title="修改默认运行级别"></a>修改默认运行级别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default TARGET.target</span><br></pre></td></tr></table></figure><blockquote><p>TARGET.target可选</p><ul><li>multi-user.target</li><li>graphical.target</li></ul></blockquote><p>示例：将默认运行级别从5改成3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 ~]<span class="comment"># systemctl get-default </span></span><br><span class="line">graphical.target</span><br><span class="line">[root@itachi103 ~]<span class="comment"># systemctl set-default multi-user.target </span></span><br><span class="line">Removed symlink /etc/systemd/system/default.target.</span><br><span class="line">Created symlink from /etc/systemd/system/default.target to /usr/lib/systemd/system/multi-user.target.</span><br><span class="line">[root@itachi103 ~]<span class="comment"># systemctl get-default </span></span><br><span class="line">multi-user.target</span><br><span class="line">[root@itachi103 ~]<span class="comment"># init 6</span></span><br></pre></td></tr></table></figure><p>重启之后，即是无图形化界面的多用户状态有网络服务</p><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man + 指令</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> + 命令</span><br></pre></td></tr></table></figure><h2 id="gt-和-gt-gt-指令"><a href="#gt-和-gt-gt-指令" class="headerlink" title="&gt;和&gt;&gt;指令"></a>&gt;和&gt;&gt;指令</h2><p><code>&gt;</code>是输出重定向</p><p><code>&gt;&gt;</code>是追加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> a.txt &gt; b.txt</span><br><span class="line"><span class="comment"># 将a.txt的内容覆盖到b.txt中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> a.txt &gt;&gt; b.txt</span><br><span class="line"><span class="comment"># 将a.txt的内容追加到b.txt中</span></span><br></pre></td></tr></table></figure><h2 id="ln指令"><a href="#ln指令" class="headerlink" title="ln指令"></a>ln指令</h2><p>软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p>基本语法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s [原文件或目录] [软链接名]</span><br></pre></td></tr></table></figure><p>举例1：在/home目录下创建一个软链接myroot，连接到/root目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /root /home/myroot</span><br></pre></td></tr></table></figure><p>举例2：删除该软链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /home/myroot</span><br></pre></td></tr></table></figure><h2 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h2><p>查看已经执行过的历史命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><p>查看最近使用过的10条历史命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> 10</span><br></pre></td></tr></table></figure><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>查看本机时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><p>查看日历</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal</span><br></pre></td></tr></table></figure><p>设置系统当前时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -s <span class="string">&quot;2020-11-11 20:00:00&quot;</span></span><br></pre></td></tr></table></figure><p>显示2020年日历</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal 2020</span><br></pre></td></tr></table></figure><h2 id="搜索类指令"><a href="#搜索类指令" class="headerlink" title="搜索类指令"></a>搜索类指令</h2><h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h3><blockquote><p> find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [搜索范围] [选项]</span><br></pre></td></tr></table></figure><p>选项说明：</p><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th><th>举例</th></tr></thead><tbody><tr><td>-name &lt;查询方式&gt;</td><td>按照指定的文件名查找模式查找文件</td><td><code>find /etc/ -name yum.conf</code></td></tr><tr><td>-user &lt;用户名&gt;</td><td>查找属于指定用户名的所有文件</td><td><code>find /opt -user root</code></td></tr><tr><td>-size &lt;文件大小&gt;</td><td>按照指定的文件大小查找文件</td><td><code>find / -size +100M</code></td></tr></tbody></table></div><h3 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h3><blockquote><p>locate指令可以快速定位文件路径。locate指令利用实现建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。</p><p>locate无需遍历整个文件系统，查询速度较快。</p><p>为了保证查询结果的准确度，管理员必须定期更新locate数据库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [文件名]</span><br></pre></td></tr></table></figure><p>举例：搜索yum.conf所在路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</span></span><br><span class="line">[root@itachi103 etc]<span class="comment"># updatedb</span></span><br><span class="line"></span><br><span class="line">[root@itachi103 etc]<span class="comment"># locate yum.conf</span></span><br><span class="line">/etc/yum.conf</span><br><span class="line">/usr/share/man/man5/yum.conf.5</span><br></pre></td></tr></table></figure><h3 id="which指令"><a href="#which指令" class="headerlink" title="which指令"></a>which指令</h3><blockquote><p>可以查看某个指令在哪个目录下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> [指令]</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 etc]<span class="comment"># which ls</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">/usr/bin/ls</span><br><span class="line"></span><br><span class="line">[root@itachi103 etc]<span class="comment"># which reboot</span></span><br><span class="line">/usr/sbin/reboot</span><br></pre></td></tr></table></figure><h3 id="grep指令和管道符号"><a href="#grep指令和管道符号" class="headerlink" title="grep指令和管道符号|"></a>grep指令和管道符号<code>|</code></h3><p>表示将前一个命令的处理结果输出传递给后面的命令处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 查找内容 源文件</span><br></pre></td></tr></table></figure><p>常用选项</p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td style="text-align:center">显示匹配行及行号</td></tr><tr><td style="text-align:center">-i</td><td style="text-align:center">忽略字母大小写</td></tr></tbody></table></div><p>举例：请在/home/hello.txt文件中，查找”yes”所在行，并且显示行号</p><p>有两种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 etc]<span class="comment"># cat /home/hello.txt </span></span><br><span class="line">hello</span><br><span class="line"><span class="built_in">yes</span></span><br><span class="line">asd</span><br><span class="line">Yes</span><br><span class="line">ddd</span><br><span class="line"><span class="built_in">yes</span></span><br><span class="line">jack</span><br><span class="line">[root@itachi103 etc]<span class="comment"># grep -n &quot;yes&quot; /home/hello.txt </span></span><br><span class="line">2:<span class="built_in">yes</span></span><br><span class="line">6:<span class="built_in">yes</span></span><br><span class="line">[root@itachi103 etc]<span class="comment"># cat /home/hello.txt | grep -n &quot;yes&quot;</span></span><br><span class="line">2:<span class="built_in">yes</span></span><br><span class="line">6:<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><h3 id="gzip-gunzip-压缩-解压缩"><a href="#gzip-gunzip-压缩-解压缩" class="headerlink" title="gzip/gunzip  压缩/解压缩"></a>gzip/gunzip  压缩/解压缩</h3><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] XXX.zip 将要压缩的内容</span><br><span class="line">unzip [选项] xxx.zip</span><br></pre></td></tr></table></figure><blockquote><p>zip常用选项：<code>-r</code> 递归压缩，即压缩目录</p><p>unzip常用选项： <code>-d &lt;目录&gt;</code>     指定解压后文件的存放目录</p></blockquote><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 案例1：将/home下的所有文件压缩成myhome.zip</span></span><br><span class="line">zip -r myhome.zip /home/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例2：将myhome.zip解压到/opt/tmp目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/tmp</span><br><span class="line">unzip -d /opt/tmp /home/myhome.zip</span><br></pre></td></tr></table></figure><h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h3><p>tar指令是打包指令，最后打包后的文件是 <code>.tar.gz</code> 的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] XXX.tar.gz 打包内容</span><br></pre></td></tr></table></figure><p>选项说明</p><div class="table-container"><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包.tar文件</td></tr></tbody></table></div><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 案例1：压缩多个文件，将/home/pig.txt和/home/cat.txt压缩成pc.tar.gz</span></span><br><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="built_in">touch</span> pig.txt</span><br><span class="line"><span class="built_in">touch</span> cat.txt</span><br><span class="line">tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例2：删除/home/的pig.txt和cat.txt，将pc.tar.gz解压到当前目录</span></span><br><span class="line"><span class="built_in">rm</span> -f pig.txt cat.txt </span><br><span class="line">tar -zxvf pc.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例3：将/home的文件夹压缩成myhome.tar.gz</span></span><br><span class="line">tar -zcvf myhome.tar.gz /home/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例4：将myhome.tar.gz解压到/opt/tmp2目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/tmp2</span><br><span class="line">tar -zxvf /home/myhome.tar.gz -C /opt/tmp2</span><br></pre></td></tr></table></figure><h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -l中显示的内容如下：</span></span><br><span class="line">-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</span><br></pre></td></tr></table></figure><p>0-9位说明：</p><ul><li><p>第0位确定文件类型（d, -, l, c, b）</p><ul><li><p>-是普通文件</p></li><li><p>l是链接</p></li><li><p>d是目录文件</p></li><li><p>c是字符设备文件，如鼠标键盘</p></li><li><p>b是块设备，如硬盘</p></li></ul></li><li><p>1-3位确定所有者的权限</p></li><li><p>4-6位确定所属组的权限</p></li><li><p>7-9位确定其他用户权限</p></li></ul><h3 id="chmod指令"><a href="#chmod指令" class="headerlink" title="chmod指令"></a>chmod指令</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p>u:所有者  g:所有组  o：其他人  a:所有人</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u=rwx,g=rx,o=x [文件/目录名]</span><br><span class="line"><span class="built_in">chmod</span> o+w [文件/目录名]</span><br><span class="line"><span class="built_in">chmod</span> a-x [文件/目录名]</span><br></pre></td></tr></table></figure><h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p>r=4 w=2 x=1  rwx=4+2+1=7</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u=rwx,g=rx,o=x [文件/目录名]</span><br><span class="line"><span class="built_in">chmod</span> 751 [文件/目录名]</span><br></pre></td></tr></table></figure><h4 id="改变文件所有者"><a href="#改变文件所有者" class="headerlink" title="改变文件所有者"></a>改变文件所有者</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> [新的所有者] [文件/目录名]</span><br></pre></td></tr></table></figure><p>举例：将/home/abc.txt文件所有者修改为tom</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> tom /home/abc.txt</span><br></pre></td></tr></table></figure><h4 id="改变文件所有者和所有组"><a href="#改变文件所有者和所有组" class="headerlink" title="改变文件所有者和所有组"></a>改变文件所有者和所有组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> [新的所有者]:[新的组] [文件/目录名]</span><br></pre></td></tr></table></figure><p>举例：将/home/test目录下所有文件和目录的所有者都修改成tom</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R tom /home/test</span><br></pre></td></tr></table></figure><h3 id="修改文件所有组"><a href="#修改文件所有组" class="headerlink" title="修改文件所有组"></a>修改文件所有组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [新组] [文件/目录名]</span><br></pre></td></tr></table></figure><p>举例：将/home/test目录下所有文件和目录的所在组都修改成shaolin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> -R shaolin /home/test</span><br></pre></td></tr></table></figure><h3 id="rwx作用到文件"><a href="#rwx作用到文件" class="headerlink" title="rwx作用到文件"></a>rwx作用到文件</h3><ul><li>r：可以读取，查看</li><li>w：可以修改。但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限。</li><li>x：可以被执行</li></ul><h3 id="rwx作用到目录"><a href="#rwx作用到目录" class="headerlink" title="rwx作用到目录"></a>rwx作用到目录</h3><ul><li>r：可以读取，ls查看目录内容</li><li>w：可以修改，<strong>对目录内创建+删除+重命名</strong></li><li>x：<strong>可以进入该目录</strong></li></ul><h1 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h1><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [选项]</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">-e</td><td style="text-align:center">编辑crontab定时任务</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:center">查询crontab任务</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">删除当前用户所有的crontab任务</td></tr></tbody></table></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加任务</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 输入任务到文件中，保存并退出</span></span><br><span class="line">*/1 * * * * <span class="built_in">ls</span> -l /etc/ &gt; /tmp/to.txt</span><br><span class="line"><span class="comment"># 意思是说每分钟都执行一次ls -l /etc/ &gt; /tmp/to.txt命令</span></span><br></pre></td></tr></table></figure><h4 id="参数细节说明"><a href="#参数细节说明" class="headerlink" title="参数细节说明"></a>参数细节说明</h4><h5 id="5个占位符说明"><a href="#5个占位符说明" class="headerlink" title="5个占位符说明"></a>5个占位符说明</h5><div class="table-container"><table><thead><tr><th style="text-align:center">项目</th><th style="text-align:center">含义</th><th style="text-align:center">范围</th></tr></thead><tbody><tr><td style="text-align:center">第一个 *</td><td style="text-align:center">一小时当中的第几分钟</td><td style="text-align:center">0-59</td></tr><tr><td style="text-align:center">第二个 *</td><td style="text-align:center">一天当中的第几个小时</td><td style="text-align:center">0-23</td></tr><tr><td style="text-align:center">第三个 *</td><td style="text-align:center">一个月当中的第几天</td><td style="text-align:center">1-31</td></tr><tr><td style="text-align:center">第四个 *</td><td style="text-align:center">一年当中的第几月</td><td style="text-align:center">1-12</td></tr><tr><td style="text-align:center">第五个 *</td><td style="text-align:center">一周当中的星期几</td><td style="text-align:center">0-7（0和7都表示星期日）</td></tr></tbody></table></div><h5 id="特殊符号说明"><a href="#特殊符号说明" class="headerlink" title="特殊符号说明"></a>特殊符号说明</h5><div class="table-container"><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">代表任何时间，比如第一个*就代表一小时中每分钟都执行一次的意思</td></tr><tr><td style="text-align:center">,</td><td style="text-align:center">代表不连续的时间，比如 <code>0 8,12,16 * * *</code> ，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">代表连续的时间范围，比如 <code>0 5 * * 1-6</code>， 代表周一到周六的凌晨5点0分执行命令</td></tr><tr><td style="text-align:center">*/n</td><td style="text-align:center">代表每隔多久执行一次。比如 <code>*/10 * * * *</code> ,代表每隔10分钟就执行一遍命令</td></tr></tbody></table></div><h5 id="特殊时间执行案例"><a href="#特殊时间执行案例" class="headerlink" title="特殊时间执行案例"></a>特殊时间执行案例</h5><div class="table-container"><table><thead><tr><th style="text-align:center">时间</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">45 22 <em> </em> *</td><td style="text-align:center">在22点45分执行命令</td></tr><tr><td style="text-align:center">0 17 <em> </em> 1</td><td style="text-align:center">每周1的17点0分执行命令</td></tr><tr><td style="text-align:center">0 5 1,15 <em> </em></td><td style="text-align:center">每月的1号和15号的凌晨5点0分执行命令</td></tr><tr><td style="text-align:center">40 4 <em> </em> 1-5</td><td style="text-align:center">每周一到周五的凌晨4点40分执行命令</td></tr><tr><td style="text-align:center"><em>/10 4 </em> <em> </em></td><td style="text-align:center">每天的凌晨4点，每隔10分钟执行一次命令</td></tr><tr><td style="text-align:center">0 0 1,15 * 1</td><td style="text-align:center">每月1号和15号，每周一的0点0分都会执行命令。</td></tr></tbody></table></div><blockquote><p>注意：星期几和几号，最好不要同时出现，因为他们的定义都是天，非常容易让管理员混乱。</p></blockquote><h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li><li>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</li><li>at执行完一个任务后就不再执行此任务了。</li><li>在使用at命令之前，一定要确保atd进程的启动，可以使用<code>ps -ef | grep atd</code> 来检测atd是否在运行。</li></ul><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at [选项] [时间]</span><br><span class="line">ctrl + D 结束at命令的输入，按两次</span><br></pre></td></tr></table></figure><h4 id="at命令选项"><a href="#at命令选项" class="headerlink" title="at命令选项"></a>at命令选项</h4><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-m</td><td style="text-align:center">当指定的任务被完成后，将给用户发邮件，即使没有标准输出</td></tr><tr><td style="text-align:center">-I</td><td style="text-align:center">atq的别名</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">atrm的别名</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">显示任务将被执行的时间</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">打印任务的内容到输出</td></tr><tr><td style="text-align:center">-V</td><td style="text-align:center">显示版本信息</td></tr><tr><td style="text-align:center">-q &lt;队列&gt;</td><td style="text-align:center">使用指定的队列</td></tr><tr><td style="text-align:center">-f &lt;文件&gt;</td><td style="text-align:center">从指定文件读入任务而不是从标准输入读入</td></tr><tr><td style="text-align:center">-t &lt;时间参数&gt;</td><td style="text-align:center">以时间参数的形式提交要运行的任务</td></tr></tbody></table></div><h4 id="at时间定义"><a href="#at时间定义" class="headerlink" title="at时间定义"></a>at时间定义</h4><ol><li>接受在当天的 hh:mm(小时:分钟)式的时间指定。假如该时间已过去，那么就放在第二天执行。 例如:04:00</li><li>使用 midmight (深夜)，non (中午)，teatime (饮茶时间，一般是下午 4 点) 等比较模糊的词语来指定时间.</li><li>采用 12 小时计时制，即在时间后面加上 AM (上午)或PM (下午）来说明是上午还是下午。 例如: 12pm。</li><li>指定命令执行的具体日期，指定格式为 month day (月 日)或mm/dd/yy (/日/年)或 dd.mm.yy (日.月.年)，指定的日期必须跟在指定时间的后面。 例如:04:00 2021-03-1</li><li>使用相对计时法。指定格式为:now +count time-units ,now 就是当前时间,tme-units 是时间单位,这里能够是 minutes(分钟)、hours (小时)、days (天)、weeks (星期)。count 是时间的数量，几天，几小时。 例如: now +5 minutes</li><li>直接使用 today (今天)、tomorrow (明天) 来指定完成命令的时间。</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>2天后的下午5点执行 /bin/ls /home</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 tmp]<span class="comment"># at 5pm + 2 days</span></span><br><span class="line">at&gt; /bin/ls /home&lt;EOT&gt;</span><br><span class="line">job 1 at Mon Feb 27 17:00:00 2023</span><br></pre></td></tr></table></figure><p>atq命令查看系统中没有执行的工作任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 tmp]<span class="comment"># atq</span></span><br><span class="line">1Mon Feb 27 17:00:00 2023 a root</span><br></pre></td></tr></table></figure><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="磁盘分区、挂载"><a href="#磁盘分区、挂载" class="headerlink" title="磁盘分区、挂载"></a>磁盘分区、挂载</h2><p>以增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。</p><h4 id="1-虚拟机添加硬盘"><a href="#1-虚拟机添加硬盘" class="headerlink" title="1.虚拟机添加硬盘"></a>1.虚拟机添加硬盘</h4><p><img src="http://cdn.leesin.fun/typora/s3/img/虚拟机添加硬盘.png" alt="虚拟机添加硬盘"></p><p>然后重启机器</p><h4 id="2-分区"><a href="#2-分区" class="headerlink" title="2.分区"></a>2.分区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 dev]<span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   50G  0 disk </span><br><span class="line">├─sda1            8:1    0  953M  0 part /boot</span><br><span class="line">└─sda2            8:2    0   49G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   45G  0 lvm  /</span><br><span class="line">  └─centos-swap 253:1    0    4G  0 lvm  [SWAP]</span><br><span class="line">sdb               8:16   0    2G  0 disk </span><br><span class="line">sr0              11:0    1  4.4G  0 rom  </span><br><span class="line"></span><br><span class="line">[root@itachi103 dev]<span class="comment"># fdisk /dev/sdb</span></span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 0x7f1e1ee6 创建新的 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：m</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   <span class="built_in">print</span> this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   <span class="built_in">print</span> the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition<span class="string">&#x27;s system id</span></span><br><span class="line"><span class="string">   u   change display/entry units</span></span><br><span class="line"><span class="string">   v   verify the partition table</span></span><br><span class="line"><span class="string">   w   write table to disk and exit</span></span><br><span class="line"><span class="string">   x   extra functionality (experts only)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">命令(输入 m 获取帮助)：n</span></span><br><span class="line"><span class="string">Partition type:</span></span><br><span class="line"><span class="string">   p   primary (0 primary, 0 extended, 4 free)</span></span><br><span class="line"><span class="string">   e   extended</span></span><br><span class="line"><span class="string">Select (default p): p</span></span><br><span class="line"><span class="string">分区号 (1-4，默认 1)：1</span></span><br><span class="line"><span class="string">起始 扇区 (2048-4194303，默认为 2048)：</span></span><br><span class="line"><span class="string">将使用默认值 2048</span></span><br><span class="line"><span class="string">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-4194303，默认为 4194303)：</span></span><br><span class="line"><span class="string">将使用默认值 4194303</span></span><br><span class="line"><span class="string">分区 1 已设置为 Linux 类型，大小设为 2 GiB</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">命令(输入 m 获取帮助)：w</span></span><br><span class="line"><span class="string">The partition table has been altered!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Calling ioctl() to re-read partition table.</span></span><br><span class="line"><span class="string">正在同步磁盘。</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="3-格式化磁盘"><a href="#3-格式化磁盘" class="headerlink" title="3.格式化磁盘"></a>3.格式化磁盘</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1 </span><br></pre></td></tr></table></figure><h4 id="4-挂载"><a href="#4-挂载" class="headerlink" title="4.挂载"></a>4.挂载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount [设备名称] [挂载目录]</span><br><span class="line">umount [设备名称]</span><br><span class="line">umount [挂载目录]</span><br></pre></td></tr></table></figure><p>如1：把分区sdb1挂载到/newdisk上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 /]<span class="comment"># mount /dev/sdb1 /newdisk/</span></span><br><span class="line">[root@itachi103 /]<span class="comment"># lsblk -f</span></span><br><span class="line">NAME            FSTYPE      LABEL           UUID                                   MOUNTPOINT</span><br><span class="line">sdb                                                                                </span><br><span class="line">└─sdb1          ext4                        2ce25320-09e8-4ce5-bb9e-b55b0c313d3f   /newdisk</span><br></pre></td></tr></table></figure><blockquote><p>如果到此步，用命令行挂载，重启后会失效</p></blockquote><p>如2：把分区sdb1取消挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 /]<span class="comment"># umount /dev/sdb1</span></span><br><span class="line"></span><br><span class="line">[root@itachi103 /]<span class="comment"># lsblk -f</span></span><br><span class="line">NAME            FSTYPE      LABEL           UUID                                   MOUNTPOINT</span><br><span class="line">sdb                                                                                </span><br><span class="line">└─sdb1          ext4                        2ce25320-09e8-4ce5-bb9e-b55b0c313d3f   </span><br></pre></td></tr></table></figure><h4 id="5-永久挂载"><a href="#5-永久挂载" class="headerlink" title="5.永久挂载"></a>5.永久挂载</h4><p>修改 /etc/fstab 实现挂载，添加完成后执行<code>mount -a</code> 即刻生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 /etc/fstab 中添加如下内容</span></span><br><span class="line">/dev/sdb1       /newdisk        ext4    defaults        0 0</span><br></pre></td></tr></table></figure><h2 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h2><h3 id="查询系统整体磁盘使用情况"><a href="#查询系统整体磁盘使用情况" class="headerlink" title="查询系统整体磁盘使用情况"></a>查询系统整体磁盘使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><h3 id="查询指定目录使用情况"><a href="#查询指定目录使用情况" class="headerlink" title="查询指定目录使用情况"></a>查询指定目录使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -h</span><br><span class="line"><span class="comment"># 默认查询当前工作目录</span></span><br></pre></td></tr></table></figure><p>选项如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">-s</td><td style="text-align:center">指定目录占用大小汇总</td></tr><tr><td style="text-align:center">-h</td><td style="text-align:center">带计量单位</td></tr><tr><td style="text-align:center">-a</td><td style="text-align:center">含文件</td></tr><tr><td style="text-align:center">—max-depth=1</td><td style="text-align:center">子目录深度</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">列出明细的同时，增加汇总量</td></tr></tbody></table></div><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 home]<span class="comment"># du -hac --max-depth=1 /opt</span></span><br><span class="line">0/opt/rh</span><br><span class="line">0/opt</span><br><span class="line">0总用量</span><br></pre></td></tr></table></figure><h3 id="磁盘情况-工作实用指令"><a href="#磁盘情况-工作实用指令" class="headerlink" title="磁盘情况-工作实用指令"></a>磁盘情况-工作实用指令</h3><h4 id="1-统计-opt文件夹下文件的个数"><a href="#1-统计-opt文件夹下文件的个数" class="headerlink" title="1.统计/opt文件夹下文件的个数"></a>1.统计/opt文件夹下文件的个数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /home/ | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span>  -l</span><br></pre></td></tr></table></figure><h4 id="2-统计-opt文件夹下目录的个数"><a href="#2-统计-opt文件夹下目录的个数" class="headerlink" title="2.统计/opt文件夹下目录的个数"></a>2.统计/opt文件夹下目录的个数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /home/ | grep <span class="string">&quot;^d&quot;</span> | <span class="built_in">wc</span>  -l</span><br></pre></td></tr></table></figure><h4 id="3-统计-opt文件夹下文件的个数，包括子文件夹里的"><a href="#3-统计-opt文件夹下文件的个数，包括子文件夹里的" class="headerlink" title="3.统计/opt文件夹下文件的个数，包括子文件夹里的"></a>3.统计/opt文件夹下文件的个数，包括子文件夹里的</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lR /home/ | grep <span class="string">&quot;^-&quot;</span> | <span class="built_in">wc</span>  -l</span><br></pre></td></tr></table></figure><h4 id="4-统计-opt文件夹下目录的个数，包括子文件夹里的"><a href="#4-统计-opt文件夹下目录的个数，包括子文件夹里的" class="headerlink" title="4.统计/opt文件夹下目录的个数，包括子文件夹里的"></a>4.统计/opt文件夹下目录的个数，包括子文件夹里的</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lR /home/ | grep <span class="string">&quot;^d&quot;</span> | <span class="built_in">wc</span>  -l</span><br></pre></td></tr></table></figure><h4 id="5-以树状显示目录结构tree目录。"><a href="#5-以树状显示目录结构tree目录。" class="headerlink" title="5.以树状显示目录结构tree目录。"></a>5.以树状显示目录结构tree目录。</h4><blockquote><p>如果没有tree。则使用<code>yum install tree</code> 安装</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 usr]<span class="comment"># tree /home/</span></span><br><span class="line">\/home/</span><br><span class="line">├── hello.txt</span><br><span class="line">├── itachi</span><br><span class="line">│   ├── \345\205\254\345\205\261</span><br><span class="line">│   ├── \346\250\241\346\235\277</span><br><span class="line">│   ├── \350\247\206\351\242\221</span><br><span class="line">│   ├── \345\233\276\347\211\207</span><br><span class="line">│   ├── \346\226\207\346\241\243</span><br><span class="line">│   ├── \344\270\213\350\275\275</span><br><span class="line">│   ├── \351\237\263\344\271\220</span><br><span class="line">│   └── \346\241\214\351\235\242</span><br><span class="line">├── tom</span><br><span class="line">└── zhangwuji</span><br><span class="line"></span><br><span class="line">11 directories, 1 file</span><br></pre></td></tr></table></figure><h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><p><img src="http://cdn.leesin.fun/typora/s3/img/Linux的NAT上网模式.png" alt="Linux的NAT上网模式"></p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="ps指令"><a href="#ps指令" class="headerlink" title="ps指令"></a>ps指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>说明</th></tr></thead><tbody><tr><td>System V</td><td>展示风格</td></tr><tr><td>USER</td><td>用户名称</td></tr><tr><td>PID</td><td>进程号</td></tr><tr><td>%CPU</td><td>进程占用CPU的百分比</td></tr><tr><td>%MEM</td><td>进程占用物理内存的百分比</td></tr><tr><td>VSZ</td><td>进程占用的虚拟内存大小（单位：KB）</td></tr><tr><td>RSS</td><td>进程占用的物理内存大小（单位：KB）</td></tr><tr><td>TTY</td><td>终端名称，缩写</td></tr><tr><td>STAT</td><td>进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等待</td></tr><tr><td>TIME</td><td>CPU时间，即进程使用CPU的总时间</td></tr><tr><td>COMMAND</td><td>启动进程所用的命令和参数，如果过长会被截断显示</td></tr></tbody></table></div><p>举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 ~]<span class="comment"># ps -aux</span></span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0 194196  7324 ?        Ss   04:08   0:26 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">root          2  0.0  0.0      0     0 ?        S    04:08   0:00 [kthreadd]</span><br><span class="line">root          4  0.0  0.0      0     0 ?        S&lt;   04:08   0:00 [kworker/0:0H]</span><br><span class="line">root          6  0.0  0.0      0     0 ?        S    04:08   0:01 [ksoftirqd/0]</span><br><span class="line">root          7  0.0  0.0      0     0 ?        S    04:08   0:00 [migration/0]</span><br><span class="line">root          8  0.0  0.0      0     0 ?        S    04:08   0:00 [rcu_bh]</span><br><span class="line">root          9  0.0  0.0      0     0 ?        S    04:08   0:08 [rcu_sched]</span><br><span class="line">root         10  0.0  0.0      0     0 ?        S&lt;   04:08   0:00 [lru-add-drain]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>说明</th></tr></thead><tbody><tr><td>UID</td><td>用户ID</td></tr><tr><td>PID</td><td>进程ID</td></tr><tr><td>PPID</td><td>父进程ID</td></tr><tr><td>C</td><td>CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高</td></tr><tr><td>STIME</td><td>进程启动的时间</td></tr><tr><td>TTY</td><td>完整的终端名称</td></tr><tr><td>TIME</td><td>CPU时间</td></tr><tr><td>CMD</td><td>启动进程所用的命令和参数</td></tr></tbody></table></div><blockquote><p>-e 显示所有进程</p><p>-f 全格</p></blockquote><h2 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过进程号终止进程</span></span><br><span class="line"><span class="built_in">kill</span> [选项] 进程号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过进程名称终止进程，也支持通配符，这在系统因负载过大而变得很慢时很有用</span></span><br><span class="line">killall 进程名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以更加直观的来看进程信息</span></span><br><span class="line">pstree [选项]</span><br><span class="line"><span class="comment"># -p：显示进程的PID</span></span><br><span class="line"><span class="comment"># -u：显示进程的所属用户</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以树状的形式显示进程的pid</span></span><br><span class="line">pstree -p</span><br><span class="line"><span class="comment"># 以树状的形式显示进程的用户</span></span><br><span class="line">pstree -u</span><br></pre></td></tr></table></figure><h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p>服务（service）本质是一个守护进程，是在后台运行的，通常会监听某个端口，等待其他程序的请求，比如（mysqld，sshd，防火墙等）。</p><h3 id="service管理指令"><a href="#service管理指令" class="headerlink" title="service管理指令"></a>service管理指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start | stop | restart | reload | status]</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>在centos7.0后，很多服务不再使用service了，而是systemctl</p></li><li><p><strong>service指令管理的服务在 <code>/etc/init.d</code> 查看</strong></p><ul><li>~~~bash<br>[root@itachi103 ~]# ll /etc/init.d/<br>总用量 40<br>-rw-r—r—. 1 root root 18281 5月  22 2020 functions<br>-rwxr-xr-x. 1 root root  4569 5月  22 2020 netconsole<br>-rwxr-xr-x. 1 root root  7928 5月  22 2020 network<br>-rw-r—r—. 1 root root  1160 10月  2 2020 README<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 查看服务</span><br><span class="line"></span><br><span class="line">~~~bash</span><br><span class="line">setup</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><p>选中系统服务，按回车</p><p><img src="http://cdn.leesin.fun/typora/s3/img/setup1.png" alt="setup1"></p><p>即可查看所有服务</p><p><img src="http://cdn.leesin.fun/typora/s3/img/setup2.png" alt="setup2"></p><p>[*]表示开机自启动</p><p>[ ]表示开机不会自启动</p><p>选中某一行，按空格可以切换是否开机自启</p><p>按Tab键，可以选中“确定”/“取消”</p><h3 id="systemctl管理指令"><a href="#systemctl管理指令" class="headerlink" title="systemctl管理指令"></a>systemctl管理指令</h3><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [start | stop | restart | status] 服务名</span><br></pre></td></tr></table></figure><blockquote><p> systemctl指令管理的服务在 /usr/lib/systemd/system 查看</p></blockquote><h5 id="查看服务开机启动状态，可以使用grep进行过滤"><a href="#查看服务开机启动状态，可以使用grep进行过滤" class="headerlink" title="查看服务开机启动状态，可以使用grep进行过滤"></a>查看服务开机启动状态，可以使用grep进行过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files</span><br><span class="line">systemctl list-unit-files | grep sshd</span><br></pre></td></tr></table></figure><h5 id="设置服务开机启动"><a href="#设置服务开机启动" class="headerlink" title="设置服务开机启动"></a>设置服务开机启动</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> 服务名</span><br></pre></td></tr></table></figure><h5 id="关闭服务开机启动"><a href="#关闭服务开机启动" class="headerlink" title="关闭服务开机启动"></a>关闭服务开机启动</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> 服务名</span><br></pre></td></tr></table></figure><h5 id="查询某个服务是否开机自启动"><a href="#查询某个服务是否开机自启动" class="headerlink" title="查询某个服务是否开机自启动"></a>查询某个服务是否开机自启动</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled 服务名</span><br></pre></td></tr></table></figure><h5 id="举例：关闭防火墙，以及关闭防火墙开机自启"><a href="#举例：关闭防火墙，以及关闭防火墙开机自启" class="headerlink" title="举例：关闭防火墙，以及关闭防火墙开机自启"></a>举例：关闭防火墙，以及关闭防火墙开机自启</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙开机自启</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><h3 id="firewall指令"><a href="#firewall指令" class="headerlink" title="firewall指令"></a>firewall指令</h3><h5 id="打开端口"><a href="#打开端口" class="headerlink" title="打开端口"></a>打开端口</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=端口号/协议</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h5 id="关闭端口"><a href="#关闭端口" class="headerlink" title="关闭端口"></a>关闭端口</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-port=端口号/协议</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h5 id="查询端口是否开放"><a href="#查询端口是否开放" class="headerlink" title="查询端口是否开放"></a>查询端口是否开放</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=端口号/协议</span><br></pre></td></tr></table></figure><h3 id="动态监控系统"><a href="#动态监控系统" class="headerlink" title="动态监控系统"></a>动态监控系统</h3><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>top与ps命令很相似。最大不同之处在于，top在执行一段时间可以更新正在运行的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">-d 秒数</td><td style="text-align:center">指定top命令每隔几秒更新。默认是3秒</td></tr><tr><td style="text-align:center">-i</td><td style="text-align:center">使top不显示任何闲置或者僵死进程</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">通过指定监控进程ID来 仅仅监控某个进程的状态</td></tr></tbody></table></div><h5 id="交互操作"><a href="#交互操作" class="headerlink" title="交互操作"></a>交互操作</h5><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">P</td><td style="text-align:center">以CPU使用率排序，默认就是此项</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">以内存的使用率排序</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">以PID排序</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">退出top</td></tr></tbody></table></div><h5 id="案例1：监视特定用户"><a href="#案例1：监视特定用户" class="headerlink" title="案例1：监视特定用户"></a>案例1：监视特定用户</h5><p>top：输入此命令，按回车键，查看执行的进程</p><p>u : 然后输入“u” ，按回车键，再输入用户名即可</p><h5 id="案例2：终止特定进程"><a href="#案例2：终止特定进程" class="headerlink" title="案例2：终止特定进程"></a>案例2：终止特定进程</h5><p>top：输入此命令，按回车键，查看执行的进程</p><p>k: 然后输入“k”回车，再输入要结束的进程ID号</p><h2 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">显示所有socket，包括正在监听的</td></tr><tr><td style="text-align:center">-n</td><td style="text-align:center">以数字形式显示地址和端口号</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">proto 显示proto指定的协议的连接</td></tr></tbody></table></div><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用命令</span></span><br><span class="line">net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务名为sshd的服务信息</span></span><br><span class="line">netstat -anp | grep sshd</span><br></pre></td></tr></table></figure><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="系统常用日志"><a href="#系统常用日志" class="headerlink" title="系统常用日志"></a>系统常用日志</h2><p><code>/var/log</code>目录就是系统日志文件的保存位置</p><div class="table-container"><table><thead><tr><th style="text-align:center">日志文件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">/var/log/boot.log</td><td style="text-align:center">系统启动日志</td></tr><tr><td style="text-align:center">/var/log/cron</td><td style="text-align:center">记录与系统定时任务相关的日志</td></tr><tr><td style="text-align:center">/var/log/lasllog</td><td style="text-align:center">记录系统中所有用户最后一次的登录时间的日志。这是个二进制文件，要使用lastlog命令查看</td></tr><tr><td style="text-align:center">/var/Iog/maillog</td><td style="text-align:center">记录邮件信息的日志</td></tr><tr><td style="text-align:center">/var/log/message</td><td style="text-align:center">记录系统重要消息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息。如果系统出现问题，首先要检查的应该就是这个日志文件</td></tr><tr><td style="text-align:center">/var/log/secure</td><td style="text-align:center">记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录。比如系统的登录、ssh的登录、su切换用户、sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中。</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><h2 id="日志服务管理-rsyslogd"><a href="#日志服务管理-rsyslogd" class="headerlink" title="日志服务管理 rsyslogd"></a>日志服务管理 rsyslogd</h2><h5 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><code>/etc/rsyslog.conf</code>是日志服务的配置文件。默认文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Log all the mail messages <span class="keyword">in</span> one place.</span></span><br><span class="line">mail.*                                                  -/var/log/maillog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Log cron stuff</span></span><br><span class="line">cron.*                                                  /var/log/cron</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Everybody gets emergency messages</span></span><br><span class="line">*.emerg                                                 :omusrmsg:*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Save news errors of level crit and higher <span class="keyword">in</span> a special file.</span></span><br><span class="line">uucp,news.crit                                          /var/log/spooler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Save boot messages also to boot.log</span></span><br><span class="line">local7.*                                                /var/log/boot.log</span><br></pre></td></tr></table></figure><p>配置的格式为:<code>*.* 存放日志文件</code><br>其中第一个 * 代表日志类型，第二个 * 代表日志级别。</p><h5 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h5><div class="table-container"><table><thead><tr><th style="text-align:center">日志类型</th><th style="text-align:center">日志级别</th></tr></thead><tbody><tr><td style="text-align:center">auth</td><td style="text-align:center">pam产生的日志</td></tr><tr><td style="text-align:center">authpriv</td><td style="text-align:center">ssh、ftp 等登录信息的验证信息</td></tr><tr><td style="text-align:center">corn</td><td style="text-align:center">时间任务相关</td></tr><tr><td style="text-align:center">kern</td><td style="text-align:center">内核</td></tr><tr><td style="text-align:center">lpr</td><td style="text-align:center">打印</td></tr><tr><td style="text-align:center">mail</td><td style="text-align:center">邮件</td></tr><tr><td style="text-align:center">mark(syslog)-rsyslog</td><td style="text-align:center">服务内部的信息，时间标识</td></tr><tr><td style="text-align:center">news</td><td style="text-align:center">新闻组</td></tr><tr><td style="text-align:center">user</td><td style="text-align:center">用户程序产生的相关信息</td></tr><tr><td style="text-align:center">uucp</td><td style="text-align:center">unix to nuix copy 主机之间相关的通信</td></tr><tr><td style="text-align:center">local 1-7</td><td style="text-align:center">自定义的日志设备</td></tr></tbody></table></div><h5 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h5><div class="table-container"><table><thead><tr><th style="text-align:center">日志级别</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">debug</td><td style="text-align:center">有调试信息的，日志通信最多</td></tr><tr><td style="text-align:center">info</td><td style="text-align:center">一般信息日志，最常用</td></tr><tr><td style="text-align:center">notice</td><td style="text-align:center">最具有重要性的普通条件的信息</td></tr><tr><td style="text-align:center">warning</td><td style="text-align:center">警告级别</td></tr><tr><td style="text-align:center">err</td><td style="text-align:center">错误级别，阻止某个功能或者模块不能正常工作的信息</td></tr><tr><td style="text-align:center">crit</td><td style="text-align:center">严重级别，阻止整个系统或者整个软件不能正常工作的信息</td></tr><tr><td style="text-align:center">alert</td><td style="text-align:center">需要立刻修改的信息</td></tr><tr><td style="text-align:center">emerg</td><td style="text-align:center">内核崩溃等重要信息</td></tr><tr><td style="text-align:center">none</td><td style="text-align:center">什么都不记录</td></tr></tbody></table></div><p>注意: 从上到下，级别从低到高，记录信息越来越少</p><h5 id="日志内容格式"><a href="#日志内容格式" class="headerlink" title="日志内容格式"></a>日志内容格式</h5><p>由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下 4 列:</p><ol><li>事件产生的时间</li></ol><p>2) 产生事件的服务器的主机名<br>3) 产生事件的服务名或程序名<br>4) 事件的具体信息</p><p>如：查看一下<code>/var/log/secure</code>日志，这个日志中记录的是用户验证和授权方面的信息。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/secure日志.png" alt="secure日志"></p><h2 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h2><h5 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除</p><ul><li>centos7使用logrotate进行日志轮替管理，通过修改<code>/etc/logrotate.conf</code>配置文件中的<code>dateext</code>参数，可以改变日志轮替文件名字。</li><li>如果配置文件中有<code>dateext</code>参数，那么日志会用<strong>日期</strong>来作为日志文件的后缀，例如“secure-20201010”。这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可。</li><li>如果配置文件中没有<code>dateext</code>参数，日志文件就需要进行改名了。<ul><li>当第一次进行日志轮替时，当前的“secure”日志会自动改名为”secure.1”，然后新建”secure”日志，用来保存新的日志。</li><li>当第二次进行轮替时，”secure.1”会自动改名为”secure.2”，当前的”secure”日志会自动改名为”secure.1”，然后也会新建”secure”日志，用来保存新的日志，以此类推。</li></ul></li></ul><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p><code>/etc/logrotate.conf</code>  为logrotate的全局配置文件</p><p>默认内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see <span class="string">&quot;man logrotate&quot;</span> <span class="keyword">for</span> details</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rotate <span class="built_in">log</span> files weekly 每周对日志文件进行一次轮替</span></span><br><span class="line">weekly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">keep 4 weeks worth of backlogs 最多共保存4份日志文件</span></span><br><span class="line">rotate 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create new (empty) <span class="built_in">log</span> files after rotating old ones 日志轮替后，创建新的空的日志文件</span></span><br><span class="line">create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use <span class="built_in">date</span> as a suffix of the rotated file 使用日期作为日志轮替文件的后缀</span></span><br><span class="line">dateext</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment this <span class="keyword">if</span> you want your <span class="built_in">log</span> files compressed 如果希望日志文件压缩，就取消注释</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">compress</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RPM packages drop <span class="built_in">log</span> rotation information into this directory</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含/etc/logrotate.d中的所有子配置文件。也就是说会把该目录中的所有子配置文件读取进来。</span></span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no packages own wtmp and btmp -- we<span class="string">&#x27;ll rotate them here</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">下面是单独配置，优先级更高</span></span></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash"><span class="string">每月对日志文件进行一次轮替</span></span></span><br><span class="line">    monthly</span><br><span class="line">    # 建立的新日志文件，权限是 0664 ，所有者是 root ，所属组是 utmp 组</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    # 日志文件最小轮替大小是 1MB。也就是日志定要超过 1MB 才会轮替，否则就算时间达到一个月，也不进行日志转储</span><br><span class="line">minsize 1M</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">仅保留一个日志备份。也就是只有 wtmp 和 wtmp.1 日志保留而已</span></span></span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/var/log/btmp &#123;</span><br><span class="line">    # 如果日志不存在，则忽略该日志的警告信息</span><br><span class="line">    missingok</span><br><span class="line">    monthly</span><br><span class="line">    create 0600 root utmp</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">system-specific logs may be also be configured here.</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">参数说明</th></tr></thead><tbody><tr><td style="text-align:center">daily</td><td style="text-align:center">日志的轮替周期是每天</td></tr><tr><td style="text-align:center">weekly</td><td style="text-align:center">日志的轮替周期是每周</td></tr><tr><td style="text-align:center">monthly</td><td style="text-align:center">日志的轮琴周期是每月</td></tr><tr><td style="text-align:center">rotate 数字</td><td style="text-align:center">保留的日志文件的个数。0 指没有备份</td></tr><tr><td style="text-align:center">compress</td><td style="text-align:center">日志轮替时，旧的日志进行压缩</td></tr><tr><td style="text-align:center">create mode owner group</td><td style="text-align:center">建立新日志，同时指定新日志的权限与所有者和所属组。</td></tr><tr><td style="text-align:center">mail address</td><td style="text-align:center">当日志轮替时，输出内容通过邮件发送到指定的邮件地址.</td></tr><tr><td style="text-align:center">missingok</td><td style="text-align:center">如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td style="text-align:center">notifempty</td><td style="text-align:center">如果日志为空文件，则不进行日志轮替</td></tr><tr><td style="text-align:center">minsize 大小</td><td style="text-align:center">日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</td></tr><tr><td style="text-align:center">size 大小</td><td style="text-align:center">日志只有大于指定大小才进行日志轮替，而不是按照时间轮替</td></tr><tr><td style="text-align:center">dateext</td><td style="text-align:center">使用日期作为日志轮替文件的后缀。</td></tr><tr><td style="text-align:center">sharedscripts</td><td style="text-align:center">在此关键字之后的脚本只执行一次</td></tr><tr><td style="text-align:center">prerotate</td><td style="text-align:center">在日志轮替之前执行脚本命令</td></tr><tr><td style="text-align:center">endscript</td><td style="text-align:center">在日志轮替之后执行脚本命令</td></tr></tbody></table></div><h5 id="将自己的日志加入日志轮替"><a href="#将自己的日志加入日志轮替" class="headerlink" title="将自己的日志加入日志轮替"></a>将自己的日志加入日志轮替</h5><ol><li>第一种方法是直接在<code>/etc/logrotate.conf</code> 配置文件中写入该日志的轮替策略</li><li>第二种方法是在<code>/etc/logrotate.d/</code>目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略。（因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替）</li></ol><blockquote><p>推荐使用第二种方法，因为系统中需要轮替的日志非常多，如果全都直接写入<code>/etc/logrotate.conf</code>配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。</p></blockquote><h2 id="查看内存日志"><a href="#查看内存日志" class="headerlink" title="查看内存日志"></a>查看内存日志</h2><p>journalctl 可以查看内存日志，这里我们看看常用的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">journalctl <span class="comment"># 查看全部</span></span><br><span class="line">journalctl -n 3 <span class="comment"># 查看最新3条</span></span><br><span class="line">journalctl --since 19:00 --until 19:10:10 <span class="comment"># 查看起始时间到结束时间的日志可加日期</span></span><br><span class="line"></span><br><span class="line">journalctl -p err <span class="comment"># 报错日志</span></span><br><span class="line">journalctl -o verbose <span class="comment"># 日志详细内容</span></span><br><span class="line"></span><br><span class="line">journalctl _PID=1245 _COMM=sshd <span class="comment"># 查看包含这些参数的日志(在详细日志查看)</span></span><br><span class="line">journalctl | grep sshd</span><br></pre></td></tr></table></figure><p>注意: journalctl查看的是内存日志，重启清空</p><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>linux的备份和恢复很简单 ，有两种方式</p><ol><li>把需要的文件(或者分区)用TAR打包就行，下次需要恢复的时候，再解压开覆盖即可</li><li>使用dump和restore命令</li></ol><blockquote><p>如果linux上没有 dump 和 restore 指令，需要先安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install dump</span><br><span class="line">yum -y install restore</span><br></pre></td></tr></table></figure></blockquote><h2 id="使用dump完成备份"><a href="#使用dump完成备份" class="headerlink" title="使用dump完成备份"></a>使用dump完成备份</h2><p>dump 支持分卷和增量备份(所谓增量备份是指备份上次备份后 修改/增加过的文件，也称差异备份)。</p><h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dump [ -cu] [-123456789] [ -f&lt;备份后文件名&gt;] [-T&lt;日期&gt;] [目录或文件系统]</span><br><span class="line">dump []-wW</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">-c</td><td style="text-align:center">创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头。</td></tr><tr><td style="text-align:center">-0123456789</td><td style="text-align:center">备份的层级。0为最完整备份，会备份所有文件。若指定0以上的层级，则备份至上一次备份以来修改或新增的文件。到9后，可以再次轮替。</td></tr><tr><td style="text-align:center">-f&lt;备份后文件名&gt;</td><td style="text-align:center">指定备份后文件名</td></tr><tr><td style="text-align:center">-j</td><td style="text-align:center">调用 bzlib 库压缩备份文件，也就是将备份后的文件压缩成 bz2格式，让文件更小</td></tr><tr><td style="text-align:center">-T&lt;日期&gt;:</td><td style="text-align:center">指定开始备份的时间与日期</td></tr><tr><td style="text-align:center">-u</td><td style="text-align:center">备份完毕后，在/etc/dumpdares中记录备份的文件系统，层级，日期与时间等。</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">指定文件名，若该文件已存在备份文件中，则列出名称</td></tr><tr><td style="text-align:center">-W</td><td style="text-align:center">显示需要备份的文件及其最后一次备份的层级，时间 ，日期</td></tr><tr><td style="text-align:center">-w</td><td style="text-align:center">与-W类似，但仅显示需要备份的文件。</td></tr></tbody></table></div><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>将<code>/boot</code>分区所有内容备份到<code>/opt/boot.bak0.bz2</code>文件中，备份层级为0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump -0uj -f /opt/boot.bak0.bz2 /boot</span><br></pre></td></tr></table></figure><p>在<code>/boot</code>目录下新加文件，备份层级为”1“（只备份上次使用层级”0“备份后发生过改变的数据）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /boot/hello.txt <span class="comment"># 随便加内容进去</span></span><br><span class="line">dump -1uj -f /opt/boot.bak1.bz2 /boot</span><br></pre></td></tr></table></figure><p>比较看看这次生成的备份文件boot.bak1.bz2有多大</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 /]<span class="comment"># ll -h /opt/</span></span><br><span class="line">总用量 140M</span><br><span class="line">-rw-r--r--. 1 root root 140M 2月  27 14:49 boot.bak0.bz2</span><br><span class="line">-rw-r--r--. 1 root root  12K 2月  27 14:52 boot.bak1.bz2</span><br></pre></td></tr></table></figure><blockquote><p>通过dump命令配合crontab可以实现无人值守备份</p></blockquote><h3 id="dump-W"><a href="#dump-W" class="headerlink" title="dump -W"></a>dump -W</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示需要备份的文件及其最后一次备份的层级，时间，日期</span></span><br><span class="line">[root@itachi103 /]<span class="comment"># dump -W</span></span><br><span class="line">Last dump(s) <span class="keyword">done</span> (Dump <span class="string">&#x27;&gt;&#x27;</span> file systems):</span><br><span class="line">  /dev/sdb1(/newdisk) Last dump: never</span><br><span class="line">  /dev/sda1( /boot) Last dump: Level 1, Date Mon Feb 27 14:52:36 2023</span><br></pre></td></tr></table></figure><h3 id="查看备份时间文件"><a href="#查看备份时间文件" class="headerlink" title="查看备份时间文件"></a>查看备份时间文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 /]<span class="comment"># cat /etc/dumpdates </span></span><br><span class="line">/dev/sda1 0 Mon Feb 27 14:49:22 2023 +0800</span><br><span class="line">/dev/sda1 1 Mon Feb 27 14:52:36 2023 +0800</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>dump只有备份分区的时候才支持增量备份。</p><p>如果备份的是文件或者目录，则不支持增量备份，即只能使用0级别的备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 案例：使用dump备份/etc整个目录</span></span><br><span class="line">dump -0j -f /opt/etc.bak.bz2 /etc/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面语句会报错：DUMP: Only level 0 dumps are allowed on a subdirectory</span></span><br><span class="line">dump -1j -f /opt/etc.bak1.bz2 /etc/</span><br></pre></td></tr></table></figure><h2 id="使用restore恢复文件"><a href="#使用restore恢复文件" class="headerlink" title="使用restore恢复文件"></a>使用restore恢复文件</h2><p>restore 命令用来恢复已备份的文件，可以从dump 生成的备份文件中恢复原文件</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restore [模式选项] [选项]</span><br></pre></td></tr></table></figure><p>说明下面四个模式不能混用，在一次命令中，只能指定一种。</p><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-C</td><td style="text-align:center">使用对比模式，将备份的文件与已存在的文件相互对比。</td></tr><tr><td style="text-align:center">-i</td><td style="text-align:center">使用交互模式，在进行还原操作时，restors指令将依序询问用户</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">进行还原模式</td></tr><tr><td style="text-align:center">-t</td><td style="text-align:center">查看模式，看备份文件有哪些文件</td></tr></tbody></table></div><p>选项如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-f &lt;备份设备&gt;</td><td style="text-align:center">从指定的文件中读取备份数据，进行还原操作</td></tr></tbody></table></div><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><h5 id="案例1：比较模式，比较备份文件和原文件的区别"><a href="#案例1：比较模式，比较备份文件和原文件的区别" class="headerlink" title="案例1：比较模式，比较备份文件和原文件的区别"></a>案例1：比较模式，比较备份文件和原文件的区别</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 /]<span class="comment"># mv /boot/hello.txt /boot/helloxxx.txt</span></span><br><span class="line">[root@itachi103 opt]<span class="comment"># restore -C -f /opt/boot.bak1.bz2 </span></span><br><span class="line">Dump tape is compressed.</span><br><span class="line">Dump   <span class="built_in">date</span>: Mon Feb 27 14:52:36 2023</span><br><span class="line">Dumped from: Mon Feb 27 14:49:22 2023</span><br><span class="line">Level 1 dump of /boot on itachi103:/dev/sda1</span><br><span class="line">Label: none</span><br><span class="line">filesys = /boot</span><br><span class="line">restore: unable to <span class="built_in">stat</span> ./hello.txt: No such file or directory</span><br><span class="line">Some files were modified!  1 compare errors</span><br><span class="line"></span><br><span class="line">[root@itachi103 opt]<span class="comment"># mv /boot/helloxxx.txt /boot/hello.txt</span></span><br><span class="line">[root@itachi103 opt]<span class="comment"># restore -C -f /opt/boot.bak1.bz2 </span></span><br><span class="line">Dump tape is compressed.</span><br><span class="line">Dump   <span class="built_in">date</span>: Mon Feb 27 14:52:36 2023</span><br><span class="line">Dumped from: Mon Feb 27 14:49:22 2023</span><br><span class="line">Level 1 dump of /boot on itachi103:/dev/sda1</span><br><span class="line">Label: none</span><br><span class="line">filesys = /boot</span><br></pre></td></tr></table></figure><h5 id="案例2：查看模式，查看备份文件有哪些数据-文件"><a href="#案例2：查看模式，查看备份文件有哪些数据-文件" class="headerlink" title="案例2：查看模式，查看备份文件有哪些数据/文件"></a>案例2：查看模式，查看备份文件有哪些数据/文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi103 opt]<span class="comment"># restore -t -f /opt/boot.bak1.bz2 </span></span><br><span class="line">Dump tape is compressed.</span><br><span class="line">Dump   <span class="built_in">date</span>: Mon Feb 27 14:52:36 2023</span><br><span class="line">Dumped from: Mon Feb 27 14:49:22 2023</span><br><span class="line">Level 1 dump of /boot on itachi103:/dev/sda1</span><br><span class="line">Label: none</span><br><span class="line">         2.</span><br><span class="line">       350./hello.txt</span><br></pre></td></tr></table></figure><h5 id="案例3：还原模式"><a href="#案例3：还原模式" class="headerlink" title="案例3：还原模式"></a>案例3：还原模式</h5><p>注意细节：如果你有增量备份，需要把增量备份文件也进行恢复 ，有几个增量备份文件，就要恢复几个，按顺序来恢复即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/boottmp</span><br><span class="line"><span class="built_in">cd</span> /opt/boottmp</span><br><span class="line">restore -r -f /opt/boot.bak0.bz2 <span class="comment"># 恢复到第1次完全备份状态</span></span><br><span class="line">restore -r -f /opt/boot.bak1.bz2 <span class="comment"># 恢复到第2次增量备份状态</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级</title>
      <link href="/post/1.html"/>
      <url>/post/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-其他"><a href="#1-其他" class="headerlink" title="1.其他"></a>1.其他</h1><h2 id="1-1-DDL（数据定义语言）"><a href="#1-1-DDL（数据定义语言）" class="headerlink" title="1.1.DDL（数据定义语言）"></a>1.1.DDL（数据定义语言）</h2><p>数据库操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有数据库</span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"># 查询当前使用的数据库</span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line"># 创建数据库</span><br><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名 [<span class="keyword">default</span> charset 字符集] [<span class="keyword">collate</span> 排序规则];</span><br><span class="line"># 删除数据库</span><br><span class="line"><span class="keyword">drop</span> database [ if exitsts ] 数据库名;</span><br><span class="line"># 使用数据库</span><br><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><p>表操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前数据库所有表</span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"># 查询表结构</span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"># 查询指定表的建表语句</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line"># 添加字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段名 类型(长度) [comment 注释] [约束];</span><br><span class="line"># 修改数据类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 字段名 新数据类型(长度);</span><br><span class="line"># 修改字段名和字段类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];</span><br></pre></td></tr></table></figure><h2 id="1-2-DML（数据操作语言）"><a href="#1-2-DML（数据操作语言）" class="headerlink" title="1.2.DML（数据操作语言）"></a>1.2.DML（数据操作语言）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> ...</span><br><span class="line"><span class="keyword">update</span> ...</span><br><span class="line"><span class="keyword">delete</span> ...</span><br></pre></td></tr></table></figure><h2 id="1-3-DQL（数据查询语言）"><a href="#1-3-DQL（数据查询语言）" class="headerlink" title="1.3.DQL（数据查询语言）"></a>1.3.DQL（数据查询语言）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ...</span><br></pre></td></tr></table></figure><p>DQL执行顺序:</p><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h2 id="1-4-DCL（管理用户）"><a href="#1-4-DCL（管理用户）" class="headerlink" title="1.4.DCL（管理用户）"></a>1.4.DCL（管理用户）</h2><h1 id="2-事务"><a href="#2-事务" class="headerlink" title="2.事务"></a>2.事务</h1><h2 id="2-1-事务简介"><a href="#2-1-事务简介" class="headerlink" title="2.1.事务简介"></a>2.1.事务简介</h2><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作==要么同时成功，要么同时失败。==</p><p><strong>默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</strong></p><h2 id="2-2-事务操作"><a href="#2-2-事务操作" class="headerlink" title="2.2.事务操作"></a>2.2.事务操作</h2><p>方式1，将事务设置为手动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查看事务的提交方式，<span class="number">1</span>表示自动提交，<span class="number">0</span>表示手动提交</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"></span><br><span class="line"># 设置事务提交方式为手动提交</span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"># 提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方式2，不修改事务的提交方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 开启事务，以下两条语句都是可以的。</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h2 id="2-3-事务四大特性ACID⭐⭐⭐"><a href="#2-3-事务四大特性ACID⭐⭐⭐" class="headerlink" title="2.3.事务四大特性ACID⭐⭐⭐"></a>2.3.事务四大特性ACID⭐⭐⭐</h2><p>原子性 (Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</p><p>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。</p><p>隔离性 (lsolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p><p>持久性 (Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><h2 id="2-4-并发事务问题⭐⭐⭐"><a href="#2-4-并发事务问题⭐⭐⭐" class="headerlink" title="2.4.并发事务问题⭐⭐⭐"></a>2.4.并发事务问题⭐⭐⭐</h2><p>脏读：一个事务读取到另一个事务还没有提交的数据。</p><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。</p><p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在了，好像出现了”幻影“。</p><h2 id="2-5-事务的隔离级别⭐⭐⭐"><a href="#2-5-事务的隔离级别⭐⭐⭐" class="headerlink" title="2.5.事务的隔离级别⭐⭐⭐"></a>2.5.事务的隔离级别⭐⭐⭐</h2><p>不同隔离级别能解决的问题： </p><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Read uncommitted</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">Read committed</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">Repeatable Read(默认)</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">Serializable</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 查看事务的隔离级别</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"></span><br><span class="line"># 设置事务的隔离级别</span><br><span class="line"><span class="keyword">set</span> [session <span class="operator">|</span> <span class="keyword">global</span>] transaction isolation level &#123;read uncommitted <span class="operator">|</span> read committed <span class="operator">|</span> repeatable read <span class="operator">|</span> serializable&#125;;</span><br><span class="line"></span><br><span class="line"># 设置本会话的事务级别为 读未提交</span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br><span class="line"># 设置本会话的事务级别为 读已提交</span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line"># 设置本会话的事务级别为 可重复读</span><br><span class="line"><span class="keyword">set</span> session transaction isolation level repeatable read;</span><br><span class="line"># 设置本会话的事务级别为 串行化</span><br><span class="line"><span class="keyword">set</span> session transaction isolation level serializable;</span><br><span class="line"></span><br><span class="line"># 经我初步测试：设置<span class="keyword">global</span>的事务级别，需要重启会话才能生效。</span><br><span class="line"># 设置全局的事务级别为 读未提交</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read uncommitted;</span><br><span class="line"># 设置全局的事务级别为 读已提交</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br><span class="line"># 设置全局的事务级别为 可重复读</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level repeatable read;</span><br><span class="line"># 设置全局的事务级别为 串行化</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level serializable;</span><br></pre></td></tr></table></figure><h1 id="3-MySQL体系结构"><a href="#3-MySQL体系结构" class="headerlink" title="3.MySQL体系结构"></a>3.MySQL体系结构</h1><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230308221800263.png" alt="image-20230308221800263"></p><ul><li>连接层：最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li>服务层：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。</li><li>引擎层：存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</li><li>存储层：主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</li></ul><h1 id="4-存储引擎"><a href="#4-存储引擎" class="headerlink" title="4.存储引擎"></a>4.存储引擎</h1><h2 id="4-1-InnoDB-逻辑存储结构"><a href="#4-1-InnoDB-逻辑存储结构" class="headerlink" title="4.1.InnoDB 逻辑存储结构"></a>4.1.InnoDB 逻辑存储结构</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230308215852555.png" alt="image-20230308215852555"></p><h2 id="4-2-InnoDB和MyISAM和Memory对比"><a href="#4-2-InnoDB和MyISAM和Memory对比" class="headerlink" title="4.2.InnoDB和MyISAM和Memory对比"></a>4.2.InnoDB和MyISAM和Memory对比</h2><div class="table-container"><table><thead><tr><th style="text-align:center">特点</th><th style="text-align:center">InnoDB</th><th style="text-align:center">MyISAM</th><th style="text-align:center">Memory</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">64TB</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">事务安全</td><td style="text-align:center">==支持==</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">锁机制</td><td style="text-align:center">==行锁==</td><td style="text-align:center">表锁</td><td style="text-align:center">表锁</td></tr><tr><td style="text-align:center">B+tree索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">Hash索引</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center"><strong>支持</strong></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">支持（5.6版本之后）</td><td style="text-align:center">支持</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">N/A</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">中等</td></tr><tr><td style="text-align:center">批量插入速度</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">支持外键</td><td style="text-align:center">==支持==</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><blockquote><p><strong>总结：InnoDB支持事务，行级锁，外键。</strong></p></blockquote><h2 id="4-3-存储引擎的选择"><a href="#4-3-存储引擎的选择" class="headerlink" title="4.3.存储引擎的选择"></a>4.3.存储引擎的选择</h2><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。<strong>（被MongoDB替代了）</strong></li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性<strong>（被Redis替代了）</strong></li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h1 id="5-索引"><a href="#5-索引" class="headerlink" title="5.索引"></a>5.索引</h1><h2 id="5-1-优缺点"><a href="#5-1-优缺点" class="headerlink" title="5.1.优缺点"></a>5.1.优缺点</h2><div class="table-container"><table><thead><tr><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">提高数据检索效率，降低数据库的IO成本</td><td style="text-align:left">索引列也是要占用空间的</td></tr><tr><td style="text-align:left">通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td><td style="text-align:left">索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</td></tr></tbody></table></div><h2 id="5-2-索引结构"><a href="#5-2-索引结构" class="headerlink" title="5.2.索引结构"></a>5.2.索引结构</h2><div class="table-container"><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，<strong>不支持范围查询</strong></td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table></div><p>支持情况：</p><div class="table-container"><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table></div><blockquote><p>注：我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p></blockquote><h3 id="5-2-1-二叉搜索树"><a href="#5-2-1-二叉搜索树" class="headerlink" title="5.2.1.二叉搜索树"></a>5.2.1.二叉搜索树</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/二叉搜索树.png" alt="二叉搜索树"></p><p><strong>二叉树缺点: 顺序插入时，会形成一个链表，查询性能大大降低。时间复杂度为O(N)</strong></p><blockquote><p>为什么不用红黑树？</p><p>红黑树也是二叉树，大数据量情况下，层级较深，检索速度慢。</p></blockquote><h3 id="5-2-2-B-Tree（多路平衡查找树）"><a href="#5-2-2-B-Tree（多路平衡查找树）" class="headerlink" title="5.2.2.B-Tree（多路平衡查找树）"></a>5.2.2.B-Tree（多路平衡查找树）</h3><p>为了解决层级较深问题，采用B-Tree。</p><p>以5阶B-Tree为例（每个节点最多存储4个key，5个指针）</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230308223104616.png" alt="image-20230308223104616"></p><h3 id="5-2-3-B-Tree"><a href="#5-2-3-B-Tree" class="headerlink" title="5.2.3.B+Tree"></a>5.2.3.B+Tree</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230308223830882.png" alt="image-20230308223830882"></p><blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul></blockquote><h3 id="5-2-4-MySQL的B-Tree"><a href="#5-2-4-MySQL的B-Tree" class="headerlink" title="5.2.4.MySQL的B+Tree"></a>5.2.4.MySQL的B+Tree</h3><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230308224034350.png" alt="image-20230308224034350"></p><h3 id="5-2-5-Hash"><a href="#5-2-5-Hash" class="headerlink" title="5.2.5.Hash"></a>5.2.5.Hash</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230308224658146.png" alt="image-20230308224658146"></p><blockquote><p>Hash索引特点：</p><ul><li>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>解决哈希冲突的方式为：拉链法。</p><p>在MySQL中，支持hash索引的是Memory引擎，而lnnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构<br>建的。</p></blockquote><h3 id="5-2-6-面试题⭐⭐⭐"><a href="#5-2-6-面试题⭐⭐⭐" class="headerlink" title="5.2.6.面试题⭐⭐⭐"></a>5.2.6.面试题⭐⭐⭐</h3><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h2 id="5-3-索引分类"><a href="#5-3-索引分类" class="headerlink" title="5.3.索引分类"></a>5.3.索引分类</h2><div class="table-container"><table><thead><tr><th>分类</th><th style="text-align:left">含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td style="text-align:left">针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td style="text-align:left">避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td style="text-align:left">快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td style="text-align:left">全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table></div><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><div class="table-container"><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>有且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table></div><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230310105816240.png" alt="image-20230310105816240"></p><h5 id="回表⭐⭐⭐"><a href="#回表⭐⭐⭐" class="headerlink" title="回表⭐⭐⭐"></a>回表⭐⭐⭐</h5><p><img src="http://cdn.leesin.fun/typora/s3/img/image-20230310105825769.png" alt="image-20230310105825769"></p><h2 id="5-4-思考题"><a href="#5-4-思考题" class="headerlink" title="5.4.思考题"></a>5.4.思考题</h2><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span>;</span><br><span class="line"><span class="comment">-- 备注：id为主键，name字段创建的有索引</span></span><br></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h2 id="5-5-索引语法"><a href="#5-5-索引语法" class="headerlink" title="5.5.索引语法"></a>5.5.索引语法</h2><p>创建索引<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name (index_col_name, ...);</span><br></pre></td></tr></table></figure></p><p>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="5-6-索引性能分析"><a href="#5-6-索引性能分析" class="headerlink" title="5.6.索引性能分析"></a>5.6.索引性能分析</h2><h3 id="5-6-1-查看执行频次"><a href="#5-6-1-查看执行频次" class="headerlink" title="5.6.1.查看执行频次"></a>5.6.1.查看执行频次</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/show global status like &#39;Com_______&#39;;.png" alt="show global status like &#39;Com_______&#39;;"></p><h3 id="5-6-2-慢查询日志⭐⭐⭐"><a href="#5-6-2-慢查询日志⭐⭐⭐" class="headerlink" title="5.6.2.慢查询日志⭐⭐⭐"></a>5.6.2.慢查询日志⭐⭐⭐</h3><p>慢查询日志记录了所有执行时间超过指定参数 （long_query_time，单位: 秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启的，查看是否开启的命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name  <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log <span class="operator">|</span> OFF   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>需要在MySQL的配置文件 （/etc/my.cnf）中配置如下信息:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"># 设置慢日志的时间为<span class="number">2</span>秒，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>配置完毕之后，重新启动MySQL服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>查看慢日志文件中记录的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入慢查询日志所在的目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看有什么文件，其中慢查询日志文件是xxx-slow.log</span></span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line">[root@itachi102 mysql]<span class="comment"># cat itachi102-slow.log </span></span><br><span class="line">/usr/sbin/mysqld, Version: 8.0.25 (MySQL Community Server - GPL). started with:</span><br><span class="line">Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，慢查询日志不会记录管理语句，也不会记录不使用索引进行查找的查询。需要在MySQL的配置文件 （/etc/my.cnf）中配置如下信息来更改此行为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#记录执行较慢的管理语句</span></span><br><span class="line">log_slow_admin_statements=1</span><br><span class="line"><span class="comment">#记录执行较慢的未使用索引的语句</span></span><br><span class="line">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure><h3 id="5-6-3-profile操作"><a href="#5-6-3-profile操作" class="headerlink" title="5.6.3.profile操作"></a>5.6.3.profile操作</h3><blockquote><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p></blockquote><p>查看当前MySQL是否支持profile操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@have</span>_profiling;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@have</span>_profiling <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> YES              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>默认profiling是关闭的，可以通过set语句在session/global级别开启profiling</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 查看profiling的开关状态，<span class="number">0</span>表示关闭，<span class="number">1</span>表示开启</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@profiling</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 将profiling开启</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 查看是否将profiling成功开启</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@profiling</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行测试的sql语句后，使用profile查看性能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的<span class="keyword">SQL</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><h3 id="5-6-4-explain执行计划"><a href="#5-6-4-explain执行计划" class="headerlink" title="5.6.4.explain执行计划"></a>5.6.4.explain执行计划</h3><blockquote><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p></blockquote><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之前加上关键字explain或<span class="keyword">desc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="5-7-索引使用规则"><a href="#5-7-索引使用规则" class="headerlink" title="5.7.索引使用规则"></a>5.7.索引使用规则</h2><h3 id="5-7-1-最左前缀法则⭐⭐⭐"><a href="#5-7-1-最左前缀法则⭐⭐⭐" class="headerlink" title="5.7.1.最左前缀法则⭐⭐⭐"></a>5.7.1.最左前缀法则⭐⭐⭐</h3><ul><li>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。</li><li>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</li><li>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</li></ul><h3 id="5-7-2-索引失效情况⭐⭐⭐"><a href="#5-7-2-索引失效情况⭐⭐⭐" class="headerlink" title="5.7.2.索引失效情况⭐⭐⭐"></a>5.7.2.索引失效情况⭐⭐⭐</h3><ol><li>在索引列上<strong>进行运算操作</strong>，索引将失效。如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 其中 phone 字段有索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone, <span class="number">10</span>, <span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># phone 字段是字符串类型字段，且此处没用使用引号包裹起来，索引将失效，因为会类型转换</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">17799990015</span>;</span><br></pre></td></tr></table></figure></li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是<strong>头部模糊匹配</strong>，索引失效。如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 索引失效举例</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 如果是头部没有用模糊匹配，则不会失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>用 or 分割开的条件，<strong>如果 or 其中一个条件的列没有索引</strong>，那么涉及的索引都不会被用到。</li><li><strong>如果 MySQL 评估使用索引比全表更慢</strong>，则不使用索引。</li></ol><h3 id="5-7-3-SQL-提示"><a href="#5-7-3-SQL-提示" class="headerlink" title="5.7.3.SQL 提示"></a>5.7.3.SQL 提示</h3><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span>&quot;软件工程&quot;;</span><br></pre></td></tr></table></figure><br>不使用哪个索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span>&quot;软件工程&quot;;</span><br></pre></td></tr></table></figure><br>必须使用哪个索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span>&quot;软件工程&quot;;</span><br></pre></td></tr></table></figure></p><blockquote><ul><li><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改</p></li><li><p>force就是无论如何都强制使用该索引。</p></li></ul></blockquote><h3 id="5-7-4-覆盖索引-amp-回表查询⭐⭐⭐"><a href="#5-7-4-覆盖索引-amp-回表查询⭐⭐⭐" class="headerlink" title="5.7.4.覆盖索引&amp;回表查询⭐⭐⭐"></a>5.7.4.覆盖索引&amp;回表查询⭐⭐⭐</h3><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><blockquote><p><strong>explain 中 extra 字段含义</strong><br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p></blockquote><p><img src="http://cdn.leesin.fun/typora/s3/img/覆盖索引-16785139464682.png" alt="覆盖索引"></p><p>在上图中，id为主键且有聚集索引，name有二级索引。</p><p>①号sql语句使用聚集索引，只需要走一次索引，效率高。</p><p>②号sql语句虽然使用name字段的二级索引，但是他只需要 id 字段和 name 字段，也只需要走一次二级索引就OK，效率高。</p><p>③号sql语句使用name字段的二级索引，且需要的字段除了 id，name 外，还有一个 gender 字段，如果只走一次二级索引无法找到 gender 字段，所以只能根据 查找到的 id 字段，回表查询，再走一次聚集索引，才能找到 gender 字段，效率相对较低。</p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><h5 id="面试题⭐⭐⭐"><a href="#面试题⭐⭐⭐" class="headerlink" title="面试题⭐⭐⭐"></a>面试题⭐⭐⭐</h5><ol><li>一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></li></ol><blockquote><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p></blockquote><ol><li>为什么尽量不要用select *</li></ol><blockquote><p>答：避免回表操作</p></blockquote><h3 id="5-7-5-前缀索引"><a href="#5-7-5-前缀索引" class="headerlink" title="5.7.5.前缀索引"></a>5.7.5.前缀索引</h3><p>当字段类型为字符串(varchar，text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(columnn(n));</span><br></pre></td></tr></table></figure><p>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email, <span class="number">1</span>, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><p>show index 里面的sub_part可以看到接取的长度。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/前缀索引.png" alt="前缀索引"></p><h3 id="5-7-6-设计原则"><a href="#5-7-6-设计原则" class="headerlink" title="5.7.6.设计原则"></a>5.7.6.设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h1 id="6-SQL优化"><a href="#6-SQL优化" class="headerlink" title="6.SQL优化"></a>6.SQL优化</h1><h2 id="6-1-插入数据"><a href="#6-1-插入数据" class="headerlink" title="6.1.插入数据"></a>6.1.插入数据</h2><p><code>insert</code> 优化</p><ul><li>批量插入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>, <span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>手动提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>, <span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">6</span>, <span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">9</span>, <span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><ul><li>主键顺序插入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主键乱序插入 : <span class="number">8</span> <span class="number">1</span> <span class="number">9</span> <span class="number">21</span> <span class="number">88</span> <span class="number">2</span> <span class="number">4</span> <span class="number">15</span> <span class="number">89</span> <span class="number">5</span> <span class="number">7</span> <span class="number">3</span></span><br><span class="line">主键顺序插入 : <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">21</span> <span class="number">88</span> <span class="number">89</span></span><br></pre></td></tr></table></figure><ul><li>大批量插入数据</li></ul><p>如果一次性需要插入大批量数据，使用 <code>insert</code> 语句插入性能较低，此时可以使用 MySQL 数据库提供的 <code>load</code> 指令进行插入。操作如下:</p><p><img src="http://cdn.leesin.fun/typora/s3/img/load指令.png" alt="load指令"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 <span class="comment">--local-infile（这一行在bash/cmd界面输入）</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@local</span>_infile;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;tb_user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="6-2-主键优化"><a href="#6-2-主键优化" class="headerlink" title="6.2.主键优化"></a>6.2.主键优化</h2><ul><li>数据组织方式</li></ul><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><ul><li>页分裂</li></ul><p>主键乱序插入可能引起页分裂</p><blockquote><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?t=220.7&amp;p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?t=220.7&amp;p=90</a></p></blockquote><ul><li>页合并</li></ul><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><blockquote><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?t=484.7&amp;p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?t=484.7&amp;p=90</a></p></blockquote><ul><li><p><strong>主键设计原则</strong></p><ul><li><p>满足业务需求的情况下，尽量降低主键的长度</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</p></li><li><p>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</p></li><li><p>业务操作时，避免对主键的修改</p></li></ul></li></ul><h2 id="6-3-order-by-优化"><a href="#6-3-order-by-优化" class="headerlink" title="6.3. order by 优化"></a>6.3. <code>order by</code> 优化</h2><blockquote><p><strong>explain 中 extra 字段含义</strong></p><p><code>Using filesort</code>：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</p><p><code>Using index</code>：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 删除之前创建的索引，以免干扰测试</span><br><span class="line"></span><br><span class="line">#没有创建索引时，根据age, phone进行排序</span><br><span class="line">#此时 extra 字段显示的是 <span class="keyword">Using</span> filesort</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age, phone;</span><br><span class="line"></span><br><span class="line">#创建索引</span><br><span class="line"><span class="keyword">create</span> index idx_user_age_phone_aa <span class="keyword">on</span> tb_user(age,phone);</span><br><span class="line"></span><br><span class="line">#创建索引后，根据age,phone进行升序排序</span><br><span class="line">#此时 extra 字段显示的是 <span class="keyword">Using</span> index效率高</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age, phone;</span><br><span class="line"></span><br><span class="line">#创建索引后，根据age, phone进行降序排序</span><br><span class="line">#此时 extra 字段显示的是 Backward index scan, <span class="keyword">Using</span> index效率高</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>, phone <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#根据age,phone进行降序一个升序，一个降序</span><br><span class="line">#此时 extra 字段显示的是 <span class="keyword">Using</span> index; <span class="keyword">Using</span> filesort</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>, phone <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line">#创建索引，对上一个<span class="keyword">sql</span>进行优化</span><br><span class="line"><span class="keyword">create</span> index idx_user_age_phone_ad <span class="keyword">on</span> tb_user(age <span class="keyword">asc</span>, phone <span class="keyword">desc</span>);</span><br><span class="line"></span><br><span class="line">#根据age,phone进行降序一个升序，一个降序</span><br><span class="line">#此时 extra 字段显示的是 <span class="keyword">Using</span> index 效率高</span><br><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>, phone <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.leesin.fun/typora/s3/img/order by优化.png" alt="order by优化"></p><p><strong>总结：</strong></p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h2 id="6-4-group-by-优化"><a href="#6-4-group-by-优化" class="headerlink" title="6.4. group by 优化"></a>6.4. <code>group by</code> 优化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 删除之前创建的索引，以免干扰测试</span><br><span class="line"></span><br><span class="line">#执行分组操作，根据profession字段分组</span><br><span class="line">#由于没有索引，所以此次操作是全表扫描</span><br><span class="line">#此时 extra 字段显示的是 <span class="keyword">Using</span> temporary 表示使用了临时表</span><br><span class="line">explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br><span class="line"></span><br><span class="line">#创建联合索引</span><br><span class="line"><span class="keyword">Create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession, age, status);</span><br><span class="line"></span><br><span class="line">#执行分组操作，根据profession字段分组</span><br><span class="line">#此时 extra 字段显示的是 <span class="keyword">Using</span> index 效率高</span><br><span class="line">explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br><span class="line"></span><br><span class="line">#执行分组操作，根据profession字段分组</span><br><span class="line">#此时 extra 字段显示的是 <span class="keyword">Using</span> index 效率高</span><br><span class="line">explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession, age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#此时 extra 字段显示的是 <span class="keyword">Using</span> index 效率高</span><br><span class="line">explain <span class="keyword">select</span> age, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><h2 id="6-5-limit-优化"><a href="#6-5-limit-优化" class="headerlink" title="6.5. limit 优化"></a>6.5. <code>limit</code> 优化</h2><p>对于limit来说，在大数据量下进行分页操作，越往后效率越低。</p><p>个常见又非常头疼的问题就是 <code>limt 2000000,10</code> ，此时需要MySQL排席前2000010 记录，仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过<strong>覆盖索引</strong>加<strong>子查询</strong>形式进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 优化前，花费<span class="number">19.39</span>秒</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> tb_sku </span><br><span class="line">limit <span class="number">9000000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 优化后，花费<span class="number">11.46</span>秒</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> tb_sku t , (<span class="keyword">select</span> id </span><br><span class="line">                 <span class="keyword">from</span> tb_sku </span><br><span class="line">                 <span class="keyword">order</span> <span class="keyword">by</span> id </span><br><span class="line">                 limit <span class="number">9000000</span>,<span class="number">10</span>) a </span><br><span class="line"><span class="keyword">where</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><h2 id="6-6-count-优化"><a href="#6-6-count-优化" class="headerlink" title="6.6. count 优化"></a>6.6. <code>count</code> 优化</h2><ul><li>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高</li><li>InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数</li></ul><blockquote><p><strong>优化思路: 自己计数。</strong>使用redis来计数</p></blockquote><p><strong>count的几种用法</strong></p><ul><li><p><code>count(主键)</code><br>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，不用判空，直接按行进行累加（主键不可能为null）</p></li><li><p><code>count(字段)</code></p><p>没有not null 约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null。不为null，计数累加；为null，不加。<br>有not null约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，不用判空，直接按行进行累加。</p></li><li><p><code>count(1)</code><br>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1“进去，直接按行进行累加。</p></li><li><p><code>count(*)</code><br>lnnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p></li></ul><p><strong>总结</strong></p><p>按照效率排序的话，<code>count(字段)</code>&lt; <code>count(主键 id)</code>&lt; <code>count(1)</code> ≈<code>count(*)</code>，所以尽量使用 <code>count(*)</code></p><h2 id="6-7-update-优化（避免行锁升级为表锁）"><a href="#6-7-update-优化（避免行锁升级为表锁）" class="headerlink" title="6.7. update 优化（避免行锁升级为表锁）"></a>6.7. <code>update</code> 优化（避免行锁升级为表锁）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># id字段有索引，此<span class="keyword">sql</span>语句加行锁</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">no</span> <span class="operator">=</span> <span class="string">&#x27;2000100100&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># name字段没有设置索引，此<span class="keyword">sql</span>语句加表锁</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">no</span> <span class="operator">=</span><span class="string">&#x27;2000100105&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;韦一笑&#x27;</span>;</span><br></pre></td></tr></table></figure><p>lnnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁</p><h1 id="7-锁"><a href="#7-锁" class="headerlink" title="7.锁"></a>7.锁</h1><p>MySQL中的锁，按照锁的粒度分，分为以下三类:<br>1.全局锁：锁定数据库中的所有表<br>2.表级锁：每次操作锁住整张表。<br>3.行级锁：每次操作锁住对应的行数据。</p><h2 id="7-1-全局锁"><a href="#7-1-全局锁" class="headerlink" title="7.1.全局锁"></a>7.1.全局锁</h2><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 加全局锁</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"># 释放全局锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>数据库中加全局锁，是一个比较重的操作，存在以下问题:</p><ol><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟。</p></li></ol><p><strong>白雪警告</strong></p><p>在innoDB引擎中，我们可以在备份时加上参数 <code>--single-transaction</code> 参数来完成不加锁的一致性数据备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot -proot itcast &gt; itcast.sql</span></span><br></pre></td></tr></table></figure><h2 id="7-2-表级锁"><a href="#7-2-表级锁" class="headerlink" title="7.2.表级锁"></a>7.2.表级锁</h2><h3 id="7-2-1-读写锁"><a href="#7-2-1-读写锁" class="headerlink" title="7.2.1.读写锁"></a>7.2.1.读写锁</h3><ol><li><p>表共享读锁 (read lock)：不会阻塞所有客户端的读，但是会阻塞所有的写。</p></li><li><p>表独占写锁 (write lock)：其他客户端不能读也不能写，</p></li></ol><div class="table-container"><table><thead><tr><th></th><th>获取锁的客户端</th><th>其他客户端</th></tr></thead><tbody><tr><td>共享读锁</td><td>可以读，不可以写</td><td>可以读，不可以写</td></tr><tr><td>独占写锁</td><td>可以读，可以写</td><td>不可以读，不可以写</td></tr></tbody></table></div><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 给tb_user加共享读锁</span><br><span class="line">lock tables tb_user read;</span><br><span class="line"># 释放锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line"># 给tb_user加独占写锁</span><br><span class="line">lock tables tb_user write;</span><br><span class="line"># 释放锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>客户端断开连接，也会自动释放锁。</p><h3 id="7-2-2-元数据锁-meta-data-lock，-MDL"><a href="#7-2-2-元数据锁-meta-data-lock，-MDL" class="headerlink" title="7.2.2.元数据锁 (meta data lock， MDL)"></a>7.2.2.元数据锁 (meta data lock， MDL)</h3><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。<br>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)，当对表结构进行变更操作的时候，加MDL写锁(排他)。</p><div class="table-container"><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read</td><td>SHARED_READ_ONLY</td><td></td></tr><tr><td>lock tables xxx write</td><td>SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert、update、delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table></div><p>查看元数据锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure><h3 id="7-2-3-意向锁"><a href="#7-2-3-意向锁" class="headerlink" title="7.2.3.意向锁"></a>7.2.3.意向锁</h3><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><ol><li>意向共享锁 (IS)：由语句 select…lock in share mode添加。与表共享读锁（read）兼容，与表独占写锁（write）互斥。</li><li>意向排他锁 (IX)：由insert、update、delete、select…for update 添加。与表共享读锁（read）及表独占写锁（write）都互斥。</li><li>意向锁之间不会互斥。</li></ol><p>可以通过以下SQL，查看意向锁及行锁的加锁情况:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><blockquote><p>说人话，如果事务A执行了 <code>select...lock in share mode</code> ，那么就会加意向共享锁 (IS)，此时，另一客户端尝试加表共享读锁是OK的，尝试加表独占写锁是不行的，会被阻塞住。</p><p>如果事务B执行了 <code>insert、update、delete、select...for update</code> 这些语句，那么就会加意向排他锁 (IX)，此时，另一客户端尝试加表共享读锁或表独占写锁都是不行的，会被阻塞住。</p><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=127">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=127</a></p></blockquote><h2 id="7-3-行级锁"><a href="#7-3-行级锁" class="headerlink" title="7.3.行级锁"></a>7.3.行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>lnnoDB的数据是基于索引组织的，<strong>行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</strong>。对于行级锁，主要分为以下三类:</p><ol><li>行锁(Record Lock)：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/行锁.png" alt="行锁"></p><ol><li>间隙锁(Gap Lock)：锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行inset，产生幻读。在RR隔离级别下都支持</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/间隙锁.png" alt="间隙锁"></p><ol><li>临键锁(Next-Key Lock)：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/临键锁.png" alt="临键锁"></p><h3 id="7-3-1-行锁"><a href="#7-3-1-行锁" class="headerlink" title="7.3.1.行锁"></a>7.3.1.行锁</h3><p>InnoDB实现了以下两种类型的行锁:</p><ol><li>共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">insert …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td style="text-align:left">update …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td style="text-align:left">delete …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td style="text-align:left">select</td><td>不加任何锁</td><td></td></tr><tr><td style="text-align:left">select … lock in share mode</td><td>共享锁</td><td>需要手动在select之后加lock in share mode</td></tr><tr><td style="text-align:left">select … for update</td><td>排他锁</td><td>需要手动在select之后加for update</td></tr></tbody></table></div><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 临键锁进行搜索和索引扫描，以防止幻读。</p><ol><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么lnnoDB将对表中的所有记录加锁，此时 就会<strong>升级为表锁。</strong></p></li></ol><p>可以通过以下SQL，查看意向锁及行锁的加锁情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h3 id="7-3-2-间隙锁-临键锁（学的不是很懂⭐⭐⭐）"><a href="#7-3-2-间隙锁-临键锁（学的不是很懂⭐⭐⭐）" class="headerlink" title="7.3.2.间隙锁/临键锁（学的不是很懂⭐⭐⭐）"></a>7.3.2.间隙锁/临键锁（学的不是很懂⭐⭐⭐）</h3><p>默认情况下，lnnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 临键 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁 。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> money <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三 <span class="operator">|</span>  <span class="number">2000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 李四 <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 王五 <span class="operator">|</span>  <span class="number">2000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> 李六 <span class="operator">|</span>  <span class="number">2000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-------+</span></span><br><span class="line"></span><br><span class="line"># 在这样的表结构下，开启一个事务，执行以下语句</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money<span class="operator">=</span><span class="number">100</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">7</span>;</span><br><span class="line"># 因为id<span class="operator">=</span><span class="number">7</span>是不存在的记录，所以会优化成id<span class="operator">=</span><span class="number">5</span>到id<span class="operator">=</span><span class="number">9</span>的间隙锁。</span><br><span class="line"></span><br><span class="line"># 然后在另一个客户端开启一个事务，执行测试</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account <span class="keyword">value</span>(<span class="number">6</span>,<span class="string">&#x27;lily&#x27;</span>,<span class="number">2000</span>);</span><br><span class="line"># 会被阻塞住，因为被上了间隙锁</span><br></pre></td></tr></table></figure><ol><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，临键锁退化为间隙锁</li><li>索引上的范围查询(唯一索引)—会访问到不满足条件的第一个值为止。</li></ol><p>注意:间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p><h1 id="8-InnoDB引擎"><a href="#8-InnoDB引擎" class="headerlink" title="8.InnoDB引擎"></a>8.InnoDB引擎</h1><h2 id="8-1-InnoDB逻辑存储结构"><a href="#8-1-InnoDB逻辑存储结构" class="headerlink" title="8.1.InnoDB逻辑存储结构"></a>8.1.InnoDB逻辑存储结构</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB逻辑存储结构.png" alt="InnoDB逻辑存储结构"></p><h2 id="8-2-架构"><a href="#8-2-架构" class="headerlink" title="8.2.架构"></a>8.2.架构</h2><p>左侧是内存结构，右侧是磁盘结构</p><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构.png" alt="InnoDB架构"></p><h3 id="8-2-1-内存架构"><a href="#8-2-1-内存架构" class="headerlink" title="8.2.1.内存架构"></a>8.2.1.内存架构</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构-内存架构.png" alt="InnoDB架构-内存架构"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构-内存架构2.png" alt="InnoDB架构-内存架构2"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构-内存架构3.png" alt="InnoDB架构-内存架构3"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构-内存架构4.png" alt="InnoDB架构-内存架构4"></p><h3 id="8-2-2-磁盘结构"><a href="#8-2-2-磁盘结构" class="headerlink" title="8.2.2.磁盘结构"></a>8.2.2.磁盘结构</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构-磁盘架构1.png" alt="InnoDB架构-磁盘架构1"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构-磁盘架构2.png" alt="InnoDB架构-磁盘架构2"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构-磁盘架构3.png" alt="InnoDB架构-磁盘架构3"></p><h3 id="8-2-3-后台线程"><a href="#8-2-3-后台线程" class="headerlink" title="8.2.3.后台线程"></a>8.2.3.后台线程</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/InnoDB架构-后台线程.png" alt="InnoDB架构-后台线程"></p><h2 id="8-3-事务原理⭐⭐⭐"><a href="#8-3-事务原理⭐⭐⭐" class="headerlink" title="8.3.事务原理⭐⭐⭐"></a>8.3.事务原理⭐⭐⭐</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/事务原理.png" alt="事务原理"></p><h3 id="8-3-1-redo-log"><a href="#8-3-1-redo-log" class="headerlink" title="8.3.1.redo log"></a>8.3.1.redo log</h3><p>==解决事务的持久性==</p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的<strong>持久性</strong>。<br>该日志文件由两部分组成：重做日志缓冲(redo log buffer)以及重做日志文件(redo og file)，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。    </p><p><img src="http://cdn.leesin.fun/typora/s3/img/redo log.png" alt="redo log"></p><h3 id="8-3-2-undo-log"><a href="#8-3-2-undo-log" class="headerlink" title="8.3.2.undo log"></a>8.3.2.undo log</h3><p>==解决事务的原子性==</p><p>回滚日志，用于记录数据被修改前的信息，作用包含两个:提供<strong>回滚</strong> 和 <strong>MVCC</strong>(多版本并发控制)。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><ul><li><p>undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC.</p></li><li><p>undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p></li></ul><h3 id="8-3-3-MVCC⭐⭐⭐"><a href="#8-3-3-MVCC⭐⭐⭐" class="headerlink" title="8.3.3.MVCC⭐⭐⭐"></a>8.3.3.MVCC⭐⭐⭐</h3><h4 id="8-3-3-1-基本概念"><a href="#8-3-3-1-基本概念" class="headerlink" title="8.3.3.1.基本概念"></a>8.3.3.1.基本概念</h4><h5 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h5><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)， select … for updte、 update、 insert、delete(排他锁)都是一种当前读。</p><h5 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h5><p>简单的select(不加锁)就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方</li><li>Serializable：快照读会退化为当前读。    </li></ul><h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h5><p>全称 Multi-Version Concurrency ontrol，<strong>多版本并发控制</strong>。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h5 id="记录中的隐藏字段"><a href="#记录中的隐藏字段" class="headerlink" title="记录中的隐藏字段"></a>记录中的隐藏字段</h5><p><img src="http://cdn.leesin.fun/typora/s3/img/记录中的隐藏字段.png" alt="记录中的隐藏字段"></p><h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p><strong>当insert的时候</strong>，产生的undo log日志只在回滚时需要，<strong>在事务提交后，可被立即删除</strong>。</p><p><strong>而update、delete的时候</strong>，产生的undo log日志<strong>不仅在回滚时需要</strong>，<strong>在快照读时也需要</strong>，不会立即被删除。</p><h5 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h5><p><img src="http://cdn.leesin.fun/typora/s3/img/undo log版本链.png" alt="undo log版本链"></p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><p>ReadView(读视图)是 <strong>快照读</strong> SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)id。<br>ReadView中包含了四个核心字段：</p><div class="table-container"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table></div><p><img src="http://cdn.leesin.fun/typora/s3/img/readView.png" alt="readView"></p><p>==不同的隔离级别，生成ReadView的时机不同：==</p><ul><li>==READ COMMITTED：在事务中每一次执行快照读时生成ReadView。==</li><li>==REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。==</li></ul><p>下面举例说明</p><p>举例1，read committed（可以看视频<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145）">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145）</a></p><p><img src="http://cdn.leesin.fun/typora/s3/img/readview举例之read committed1.png" alt="readview举例之read committed1"></p><p><img src="http://cdn.leesin.fun/typora/s3/img/readview举例之read committed2.png" alt="readview举例之read committed2"></p><p>举例2，repeatable read（可以看视频<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=146）">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=146）</a></p><p><img src="http://cdn.leesin.fun/typora/s3/img/readview举例之repeatable read.png" alt="readview举例之repeatable read"></p><h3 id="8-3-4-事务原理总结⭐⭐⭐"><a href="#8-3-4-事务原理总结⭐⭐⭐" class="headerlink" title="8.3.4.事务原理总结⭐⭐⭐"></a>8.3.4.事务原理总结⭐⭐⭐</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/事务原理总结.png" alt="事务原理总结"></p><h1 id="9-MySQL管理"><a href="#9-MySQL管理" class="headerlink" title="9.MySQL管理"></a>9.MySQL管理</h1><h2 id="9-1-系统数据库"><a href="#9-1-系统数据库" class="headerlink" title="9.1.系统数据库"></a>9.1.系统数据库</h2><p>Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下：</p><div class="table-container"><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息 (时区、主从、用户、权限等)</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td></tr><tr><td>performance_schema</td><td>为MysQL服务器送行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便DBA和开发人员利用 performance schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table></div><h2 id="9-2-常用工具"><a href="#9-2-常用工具" class="headerlink" title="9.2.常用工具"></a>9.2.常用工具</h2><h3 id="9-2-1-mysql"><a href="#9-2-1-mysql" class="headerlink" title="9.2.1.mysql"></a>9.2.1.mysql</h3><p>该mysql不是指mysql服务，而是指mysql的客户端工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">语法 :</span><br><span class="line">mysql [options] [database]</span><br><span class="line">选项:</span><br><span class="line">    -u, --user=name    <span class="comment">#指定用户名</span></span><br><span class="line">    -p,--password[=namel    <span class="comment">#指定密码</span></span><br><span class="line">    -h, --host=name    <span class="comment">#指定服务器IP或域名</span></span><br><span class="line">    -P,--port=port    <span class="comment">#指定连接端口</span></span><br><span class="line">    -e,--execute=name    <span class="comment">#执行SQL语句并退出</span></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">mysql -hitachi102 -uroot -proot -P3306</span><br></pre></td></tr></table></figure><p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MyQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot db01 -e<span class="string">&quot;select * from stu&quot;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-2-mysqladmin"><a href="#9-2-2-mysqladmin" class="headerlink" title="9.2.2.mysqladmin"></a>9.2.2.mysqladmin</h3><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过帮助文档查看选项</span></span><br><span class="line">mysqladmin --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="9-2-3-mysqlbinlog⭐⭐⭐"><a href="#9-2-3-mysqlbinlog⭐⭐⭐" class="headerlink" title="9.2.3.mysqlbinlog⭐⭐⭐"></a>9.2.3.mysqlbinlog⭐⭐⭐</h3><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到myslbinlog 日志管理工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">语法 :</span><br><span class="line">mysqlbinlog [options] log-files1 ...</span><br><span class="line">选项 :</span><br><span class="line"><span class="comment"># 指定数据库名称，只列出指定的数据库相关操作。</span></span><br><span class="line">    -d,--database=name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 忽略掉日志中的前n行命令。</span></span><br><span class="line">    -o,--offset=</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将行事件（数据变更）重构为SQL语句</span></span><br><span class="line">    -v</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将行事件（数据变更）重构为SQL语句，并输出注释信息</span></span><br><span class="line">    -w</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将输出的文本格式日志输出到指定文件。</span></span><br><span class="line">    -r,--result-file=name</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示简单格式，省略掉一些信息。</span></span><br><span class="line">    -s, --short-form</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定日期间隔内的所有日志</span></span><br><span class="line">    --start-datatime=date1 --stop-datetime=date2</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定位置间隔内的所有日志。</span></span><br><span class="line">    --start-position=pos1 --stop-position=pos2</span><br></pre></td></tr></table></figure><p>使用举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入Linux</span></span><br><span class="line"><span class="comment"># 进入mysql日志文件存放的位置</span></span><br><span class="line"><span class="comment"># ll查看文件</span></span><br><span class="line"><span class="comment"># mysqlbinlog查看日志文件</span></span><br><span class="line">[root@itachi102 mysql]<span class="comment"># cd /var/lib/mysql</span></span><br><span class="line">[root@itachi102 mysql]<span class="comment"># ll</span></span><br><span class="line">[root@itachi102 mysql]<span class="comment"># mysqlbinlog binlog.000001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-2-4-mysqlshow"><a href="#9-2-4-mysqlshow" class="headerlink" title="9.2.4.mysqlshow"></a>9.2.4.mysqlshow</h3><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法 :</span><br><span class="line">mysqlshow [options] [db_name[table_name[col_name]]]</span><br><span class="line">选项:</span><br><span class="line">--count<span class="comment"># 显示数据库及表的统计信息 (数据库，表 均可以不指定)</span></span><br><span class="line">-i<span class="comment"># 显示指定数据库或者指定表的状态信息</span></span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询每个数据库的表的数量及表中记录的数量</span></span><br><span class="line">mysqlshow -uroot -proot --count</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询test库中每个表中的字段数，及行数</span></span><br><span class="line">mysqlshow -uroot -proot <span class="built_in">test</span> --count</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询test库中book表的详细情况</span></span><br><span class="line">mysqlshow -uroot -proot <span class="built_in">test</span> book --count</span><br></pre></td></tr></table></figure><h3 id="9-2-5-mysqldump"><a href="#9-2-5-mysqldump" class="headerlink" title="9.2.5.mysqldump"></a>9.2.5.mysqldump</h3><p>mysqldump 客户端工具用备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SOL语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] --database/-B db1 [db2 db3...]</span><br><span class="line">mysqldump [options] --all-databases/-A</span><br><span class="line"></span><br><span class="line">连接选项：</span><br><span class="line">-u,--user=name<span class="comment">#指定用户名</span></span><br><span class="line">-p,--password[=name]<span class="comment">#指定密码</span></span><br><span class="line">-h,--host=name<span class="comment">#指定服务器ip或域名</span></span><br><span class="line">-P,--port=<span class="comment">#指定连接端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出选项：</span><br><span class="line"></span><br><span class="line"><span class="comment">#在每个数据库创建语句前加上 drop database 语句</span></span><br><span class="line">--add-drop-database</span><br><span class="line"><span class="comment">#在每个表创建语句前加上 drop table 语句，默认开启 ;不开启(--skip-add-drop-table)</span></span><br><span class="line">--add-drop-table</span><br><span class="line">    <span class="comment">#不包含数据库的创建语句</span></span><br><span class="line">-n,--no-create-db</span><br><span class="line"><span class="comment">#不包含数据表的创建语句</span></span><br><span class="line">-t,--no-create-info</span><br><span class="line"><span class="comment">#不包含数据</span></span><br><span class="line">-d --no-data</span><br><span class="line"><span class="comment">#自动生成两个文件:一个.sql文件，创建表结构的语句;一个.txt文件，数据文件</span></span><br><span class="line">-T,--tab=name</span><br></pre></td></tr></table></figure><p>使用举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份数据库db01</span></span><br><span class="line">mysqldump -uroot -proot db01 &gt; db01.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份数据库db01，只备份表结构不备份数据</span></span><br><span class="line">mysqldump -uroot -proot -d db01 &gt; db02.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份数据库db01下的score表，并且将表结构输出为.sql文件，将数据输出为.txt文件</span></span><br><span class="line"><span class="comment"># 并指定输出的目录为/var/lib/mysql-files/</span></span><br><span class="line">mysqldump -uroot -proot -T /var/lib/mysql-files/ db01 score</span><br></pre></td></tr></table></figure><h3 id="9-2-6-mysqlimport"><a href="#9-2-6-mysqlimport" class="headerlink" title="9.2.6.mysqlimport"></a>9.2.6.mysqlimport</h3><p>mysqlimport是客户端数据导入工具，用来导入mysqldump 加-T参数后导出的文本文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">mysqlimport [options] db_name textfile1 [textfile2 ...]</span><br><span class="line">示例：</span><br><span class="line">mysqlimport -uroot -proot db01 /var/lib/mysql-files/score.txt</span><br><span class="line"><span class="comment"># 注意：文件名就是表名</span></span><br></pre></td></tr></table></figure><h3 id="9-2-7-source"><a href="#9-2-7-source" class="headerlink" title="9.2.7.source"></a>9.2.7.source</h3><p>如果需要导入sql文件，可以使用source指令，但是这个指令要进入mysql中的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="built_in">source</span> /.../xxx.sql</span><br></pre></td></tr></table></figure><h1 id="10-运维"><a href="#10-运维" class="headerlink" title="10.运维"></a>10.运维</h1><h2 id="10-1-日志⭐⭐⭐"><a href="#10-1-日志⭐⭐⭐" class="headerlink" title="10.1.日志⭐⭐⭐"></a>10.1.日志⭐⭐⭐</h2><h3 id="10-1-1-错误日志"><a href="#10-1-1-错误日志" class="headerlink" title="10.1.1.错误日志"></a>10.1.1.错误日志</h3><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。<strong>当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。</strong></p><p>该日志是默认开启的，默认存放目录 <code>/var/log/</code> ，默认的日志文件名为 <code>mysqld.log</code> 。</p><p>进入mysql查看日志位置:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> log_error     <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -50 /var/log/mysqld.log </span><br><span class="line"><span class="built_in">tail</span> -f /var/log/mysqld.log </span><br></pre></td></tr></table></figure><h3 id="10-1-2-二进制日志"><a href="#10-1-2-二进制日志" class="headerlink" title="10.1.2.二进制日志"></a>10.1.2.二进制日志</h3><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询(SELECT、SHOW)语句。</p><p>作用：</p><ol><li><p><strong>灾难时的数据恢复</strong></p></li><li><p><strong>MSQL的主从复制</strong></p></li></ol><p>在MySL8版本中，默认二进制日志是开启着的，涉及到的参数如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>在linux看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@itachi102 mysql-files]<span class="comment"># cd /var/lib/mysql/</span></span><br><span class="line">[root@itachi102 mysql]<span class="comment"># ll</span></span><br><span class="line">-rw-r-----. 1 mysql mysql      998 3月  10 17:43 binlog.000001</span><br><span class="line">-rw-r-----. 1 mysql mysql     9824 3月  12 18:28 binlog.000002</span><br><span class="line">-rw-r-----. 1 mysql mysql       32 3月  10 17:44 binlog.index</span><br><span class="line">[root@itachi102 mysql]<span class="comment"># cat binlog.index </span></span><br><span class="line">./binlog.000001</span><br><span class="line">./binlog.000002</span><br></pre></td></tr></table></figure><h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><p>MySQL服务器中提供了多种格式来记录二进制日志:</p><div class="table-container"><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录的是每一行的数据变更。(默认)</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。</td></tr></tbody></table></div><p>查看当前mysql版本中，默认的日志格式是哪种</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> binlog_format <span class="operator">|</span> <span class="type">ROW</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h4><p>前面有笔记  6.2.3.mysqlbinlog</p><h4 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h4><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 删除全部binlog日志，删除之后，日志编号将会从binlog<span class="number">.000001</span>开始编号</span><br><span class="line">reset master</span><br><span class="line"></span><br><span class="line"># 删除<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>编号之前的所有日志</span><br><span class="line">purge master logs <span class="keyword">to</span> <span class="string">&#x27;binlog.******&#x27;</span></span><br><span class="line"></span><br><span class="line"># 删除日志为&quot;yyyy-mm-dd hh24:mi:ss&quot;之前产生的所有日志</span><br><span class="line">purge master logs before <span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span></span><br></pre></td></tr></table></figure><p>如果不手动删除，mysql也会在一定时间内删除。</p><p>查看过期时间的语句：（默认是30天的过期时间）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_expire_logs_seconds&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name              <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> binlog_expire_logs_seconds <span class="operator">|</span> <span class="number">2592000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>当然我们也可以在mysql配置文件中手动修改二进制文件的过期时间。</p><h3 id="10-1-3-查询日志"><a href="#10-1-3-查询日志" class="headerlink" title="10.1.3.查询日志"></a>10.1.3.查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以去 <code>/etc/my.cnf</code>  末尾追加 <code>general_log=1</code>，然后重启服务。</p><p>查看默认情况的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>itachi102.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="10-1-4-慢查询日志"><a href="#10-1-4-慢查询日志" class="headerlink" title="10.1.4.慢查询日志"></a>10.1.4.慢查询日志</h3><p>请查看2.6.2.慢查询日志</p><h2 id="10-2-主从复制"><a href="#10-2-主从复制" class="headerlink" title="10.2.主从复制"></a>10.2.主从复制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>主从复制是指将主数据库的DDL和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>主库出现问题，可以快速切换到从库提供服务</p></li><li><p>实现读写分离，降低主库的访问压力。</p></li><li><p>可以在从库中执行备份，以避免备份期间影响主库服务。</p></li></ol><h3 id="原理⭐⭐⭐"><a href="#原理⭐⭐⭐" class="headerlink" title="原理⭐⭐⭐"></a>原理⭐⭐⭐</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/主从复制原理.png" alt="主从复制原理"></p><p>从上图来看，复制分成三步:</p><ol><li><p>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p></li><li><p>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志 Relay Log。</p></li><li><p>slave重做中继日志中的事件，将改变反映它自己的数据。</p></li></ol><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>准备两台服务器：itachi102和itachi103</p><p>itachi102作为主库，itachi103作为从库</p><h5 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h5><ol><li>修改<code>/etc/my.cnf</code></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql服务ID，保证整个集群环境中唯一，取值范围: 1 - 2^32-1，默认为1</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#是否只读,1 代表只读,0代表读写</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#忽略的数据,指不需要同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-ignore-db=mysql</span></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=db01</span></span><br></pre></td></tr></table></figure><ol><li>重启服务</li><li>登录mysql，创建从库连接主库用的远程连接的账号，并授予主从复制权限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建itachi用户，该用户可在任意主机连接该mysql服务</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"># 为<span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>用户分配主从复制权限</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>通过指令，查看二进制日志坐标</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File          <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span> Binlog_Ignore_DB <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> binlog<span class="number">.000006</span> <span class="operator">|</span>      <span class="number">663</span> <span class="operator">|</span>              <span class="operator">|</span>                  <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>字段含义说明:</p><ul><li>File：从哪个日志文件开始推送日志文件</li><li>Position：从哪个位置开始推送日志</li><li>Binlog_ignore_db：指定不需要同步的数据库</li></ul><h5 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h5><ol><li>修改<code>/etc/my.cnf</code></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql服务ID，保证整个集群环境中唯一，取值范围: 1 - 2^32-1，和主库不一样即可</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">2</span></span><br><span class="line"><span class="comment">#是否只读,1 代表只读,0代表读写</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure><ol><li>如果是克隆过来的机器，需要修改uuid</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 登录mysql</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> uuid();</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> uuid()                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> b33057ff<span class="operator">-</span>bec6<span class="number">-11</span>eb<span class="operator">-</span>ad94<span class="number">-000</span>c29af6856 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line"># 退出mysql，去修改uuid</span><br><span class="line">vim <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>auto.cnf</span><br><span class="line"></span><br><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>重启服务</li><li>登录mysql，设置主库配置</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;itachi102&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;itachi&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;binlog.000006&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><ol><li>开启同步操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">start</span> replica; </span><br><span class="line"></span><br><span class="line"># <span class="number">8.0</span><span class="number">.22</span>.之前</span><br><span class="line"><span class="keyword">start</span> slave; </span><br></pre></td></tr></table></figure><ol><li>查看主从同步状态</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">show</span> replica status\G; </span><br><span class="line"></span><br><span class="line"># <span class="number">8.0</span><span class="number">.22</span>.之前</span><br><span class="line"><span class="keyword">show</span> slave status\G; </span><br></pre></td></tr></table></figure><p>主要看两个字段，如果这两个字段为YES，说明就成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><ol><li>在主库中创建数据库、表，并插入数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db01;</span><br><span class="line">use db01;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">primary</span> key <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><ol><li>去从库查询数据，验证主从是否同步</li></ol><h2 id="10-3-分库分表"><a href="#10-3-分库分表" class="headerlink" title="10.3.分库分表"></a>10.3.分库分表</h2><h3 id="10-3-1-拆分方式"><a href="#10-3-1-拆分方式" class="headerlink" title="10.3.1.拆分方式"></a>10.3.1.拆分方式</h3><h3 id="10-3-2-MyCat架构"><a href="#10-3-2-MyCat架构" class="headerlink" title="10.3.2.MyCat架构"></a>10.3.2.MyCat架构</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/mycat架构.png" alt="mycat架构"></p><h3 id="10-3-3-入门"><a href="#10-3-3-入门" class="headerlink" title="10.3.3.入门"></a>10.3.3.入门</h3><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>由于 tb_order 表中数据量很大，磁盘 IO 及容量都到达了瓶颈，现在需要对 tb_order 表进行数据分片，分为三个数据节点，每一个节点主机位于不同的服务器上，具体的结构参考下图：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/mycat入门1.png" alt="mycat入门1" style="zoom:50%;"></p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><div class="table-container"><table><thead><tr><th>服务器</th><th>安装软件</th><th>说明</th></tr></thead><tbody><tr><td>itachi103</td><td>JDK和Mycat</td><td>Mycat中间件服务器</td></tr><tr><td>itachi103</td><td>MySQL</td><td>分片服务器</td></tr><tr><td>itachi104</td><td>MySQL</td><td>分片服务器</td></tr><tr><td>itachi105</td><td>MySQL</td><td>分片服务器</td></tr></tbody></table></div><p>然后进入itachi103的目录<code>/usr/local/mycat/lib</code></p><p>将mysql驱动包换成8版本的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/mycat/lib</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f mysql-connector-java-5.1.35.jar </span><br><span class="line"></span><br><span class="line">然后将mysql-connector-java-8.0.22.jar上传至此目录下</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 777 mysql-connector-java-8.0.22.jar </span><br></pre></td></tr></table></figure><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p>分别在3台mysql服务器中创建一个空的数据库，名字为<code>db01</code></p><h5 id="配置schema-xml"><a href="#配置schema-xml" class="headerlink" title="配置schema.xml"></a>配置schema.xml</h5><p>位于<code>/usr/local/mycat/conf/schema.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_ORDER&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi103:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi104:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi105:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里配置的是，逻辑库逻辑表相关信息</p></blockquote><h5 id="配置server-xml"><a href="#配置server-xml" class="headerlink" title="配置server.xml"></a>配置server.xml</h5><p>修改server.xml相应的标签为如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里配置的是，登录mycat的账号密码</p></blockquote><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入mycat目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/mycat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动，端口号默认为8066</span></span><br><span class="line">bin/mycat start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否启动成功，如果出现MyCAT Server startup successfully.则成功了</span></span><br><span class="line"><span class="built_in">tail</span> -f logs/wrapper.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">bin/mycat stop</span><br></pre></td></tr></table></figure><h5 id="登录mycat"><a href="#登录mycat" class="headerlink" title="登录mycat"></a>登录mycat</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hitachi103 -P8066 -uroot -p123456 --default_auth=mysql_native_password</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> DATABASE <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> DB01     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use DB01;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> Tables <span class="keyword">in</span> DB01 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> tb_order       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时三台服务器的mysql都还没有表结构，上面查询出来的只是mycat中的逻辑表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_order(</span><br><span class="line">    id <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    title <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>执行创建表后，三台服务器才真正的创建了表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_order(id,title) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;godds1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_order(id,title) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;godds2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_order(id,title) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;godds3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_order(id,title) <span class="keyword">values</span>(<span class="number">1000000</span>,<span class="string">&#x27;godds1000000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_order(id,title) <span class="keyword">values</span>(<span class="number">10000000</span>,<span class="string">&#x27;godds10000000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_order(id,title) <span class="keyword">values</span>(<span class="number">10000001</span>,<span class="string">&#x27;godds10000001&#x27;</span>);</span><br></pre></td></tr></table></figure><p>插入数据后，根据分片规则（schema.xml配置），水平拆分给三台服务器存放数据</p><p>itachi103</p><p><img src="http://cdn.leesin.fun/typora/s3/img/itachi103.png" alt="itachi103"></p><p>itachi104</p><p><img src="http://cdn.leesin.fun/typora/s3/img/itachi104.png" alt="itachi104"></p><p>itachi105</p><p><img src="http://cdn.leesin.fun/typora/s3/img/itachi105.png" alt="itachi105"></p><h3 id="10-3-4-MyCat配置"><a href="#10-3-4-MyCat配置" class="headerlink" title="10.3.4.MyCat配置"></a>10.3.4.MyCat配置</h3><h4 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h4><p>schema.xml作为MyCat中最重要的配置文件之一,涵盖了MyCat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。</p><p>主要包含以下三组标签:</p><p><strong>schema标签</strong></p><p><img src="http://cdn.leesin.fun/typora/s3/img/schema.xml的sechema标签.png" alt="schema.xml的sechema标签"></p><p>schema 标签用于定义 Mycat实例中的逻辑库，一个Mycat实例中，可以有多个逻辑库，可以通过 schema 标签来划分不同的逻辑库。</p><p>Mycat中的逻辑库的概念，等同于MySQL中的database概念，需要操作某个逻辑库下的表时，也需要切换逻辑库(use xxx)。</p><blockquote><ul><li>name：指定自定义的逻辑库库名</li><li><p>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</p></li><li><p>table标签里面的属性：</p><ul><li>name：定义逻辑表表名，在该逻辑库下唯一</li><li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应</li><li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li><li>primaryKey：逻辑表对应真实表的主键</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为 global</li></ul></li></ul></blockquote><p><strong>datanode标签</strong></p><p><img src="http://cdn.leesin.fun/typora/s3/img/schema.xml的dataNode标签.png" alt="schema.xml的dataNode标签"></p><p>dataNode 标签中定义了 MyCat 中的数据节点，也就是我们通常说的数据分片。一个 dataNode 标签就是一个独立的数据分片。</p><blockquote><ul><li>name：定义数据节点名称</li><li>dataHost：数据库实例主机名称，引用自 dataHost标签中name属性</li><li>database：定义分片的数据库</li></ul></blockquote><p><strong>datahost标签</strong></p><p><img src="http://cdn.leesin.fun/typora/s3/img/schema.xml的dataHost标签.png" alt="schema.xml的dataHost标签"></p><p>该标签在 MyCat 逻辑库中作为底层标签存在，直接定义了具体的数据库实例、读写分离、心跳语句。</p><blockquote><ul><li>name：唯一标识，供上层标签使用</li><li>maxCon/minCon：最大连接数/最小连接数</li><li>balance：负载均衡策略，取值 0,1,2,3</li><li>writeType：写操作分发方式，取值0,1</li><li>switchType：设置是否自动切换，取值-1,1</li><li>dbDriver：数据库驱动，支持 native、jdbc</li></ul></blockquote><div class="table-container"><table><thead><tr><th>balance参数值</th><th>含义</th></tr></thead><tbody><tr><td>0（默认值）</td><td>不开启读写分离机制，所有读操作都发送到当前可用的writeHost上</td></tr><tr><td>1</td><td>全部的readHost与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式）</td></tr><tr><td>2</td><td>所有的读写操作都随机在writeHost，readHost上分发</td></tr><tr><td>3</td><td>所有的读请求随机分发到writeHost对应的readHost上执行。writeHost只负担写压力，不负担读压力</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">writeType参数值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">写操作转发到第一个writeHost，第一个挂了，切换到第二个</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">写操作随机分发到配置的writeHost</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">switch参数值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-1</td><td style="text-align:center">不自动切换</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">当writeHost1挂了之后，自动切换至writeHost2上</td></tr></tbody></table></div><p><strong>总结</strong></p><p><img src="http://cdn.leesin.fun/typora/s3/img/schema.xml总结.png" alt="schema.xml总结"></p><h4 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h4><p>rule.xml 中定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配置化。主要包含两类标签：tableRule、Function。</p><p>以rang-long为例：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/rule.xml举例之rang-long策略.png" alt="rule.xml举例之rang-long策略"></p><h4 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h4><p>server.xml 配置文件包含了 MyCat 的系统配置信息，主要有两个重要的标签：system、user。</p><ul><li>system标签</li></ul><p>​    自己打开server.xml来看，里面有注释</p><ul><li>user标签</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/mycat的server.xml的user标签.png" alt="mycat的server.xml的user标签"></p><p>注意，如果配置多个逻辑库，逗号隔开，如下：⭐⭐⭐</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01,DB02,DB03,DB04<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="10-3-5-垂直分库示例"><a href="#10-3-5-垂直分库示例" class="headerlink" title="10.3.5.垂直分库示例"></a>10.3.5.垂直分库示例</h3><p>在业务系统中，涉及以下表结构，但是由于用户与订单每天都会产生大量的数据，单台服务器的数据存储及处理能力是有限的，可以对数据库表进行拆分。图的左边原有的数据库表，图的右边是垂直分库后的情况。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/垂直分库示例-167869852638120.png" alt="垂直分库示例"></p><p><strong>准备</strong></p><p>在三台服务器中都创建数据库<code>shopping</code></p><p><strong>配置</strong></p><p>schema.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;SHOPPING&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_base&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_brand&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_cat&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_desc&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;goods_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_goods_item&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_order_item&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_order_master&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_order_pay_log&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;out_trade_no&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user_address&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_provinces&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_city&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_region&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;shopping&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi103:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi104:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi105:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>server.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>SHOPPING<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>SHOPPING<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>上传sql文件至itachi103的<code>/opt/sql</code></strong></p><p><strong>在itachi103登录mycat</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hitachi103 -P8066 -uroot -p123456 --default_auth=mysql_native_password</span><br></pre></td></tr></table></figure><p><strong>然后在里面运行sql文件</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use SHOPPING;</span><br><span class="line">mysql<span class="operator">&gt;</span> source <span class="operator">/</span>home<span class="operator">/</span><span class="keyword">sql</span><span class="operator">/</span>shopping<span class="operator">-</span>table.sql</span><br><span class="line">mysql<span class="operator">&gt;</span> source <span class="operator">/</span>home<span class="operator">/</span><span class="keyword">sql</span><span class="operator">/</span>shopping<span class="operator">-</span>insert.sql</span><br></pre></td></tr></table></figure><p><strong>在datagrip查看每一个Mysql服务器是否有响应数据</strong></p><p><strong>测试多表联查</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ua.user_id, ua.contact, p.province, c.city, r.area, ua.address</span><br><span class="line"><span class="keyword">from</span> tb_user_address ua, tb_areas_provinces p, tb_areas_city c, tb_areas_region r</span><br><span class="line"><span class="keyword">where</span> ua.province_id<span class="operator">=</span>p.provinceid <span class="keyword">and</span> ua.city_id<span class="operator">=</span>c.cityid <span class="keyword">and</span> ua.town_id<span class="operator">=</span>r.areaid;</span><br></pre></td></tr></table></figure><p>上述sql在itachi105上是能成功的，因为上述sql使用的表在itachi105上都有，然后在mycat中执行也是能成功的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_id, payment, receiver, province, city, area</span><br><span class="line"><span class="keyword">from</span> tb_order_master o, tb_areas_provinces p, tb_areas_city c, tb_areas_region r</span><br><span class="line"><span class="keyword">where</span> o.receiver_province<span class="operator">=</span>p.provinceid <span class="keyword">and</span> o.receiver_city<span class="operator">=</span>c.cityid <span class="keyword">and</span> o.receiver_region<span class="operator">=</span>r.areaid;</span><br></pre></td></tr></table></figure><p>上述语句在mycat中执行报错 <code>invalid route in sql, multi tables found but datanode has no intersection</code> ，原因是 <code>tb_order_master</code> 表和其他表不属于同一个dataNode中。</p><p>​    </p><p><strong>全局表demo</strong></p><p>因为有这样的需求，所以我们可以把<code>tb_areas_provinces</code>， <code>tb_areas_city</code>， <code>tb_areas_region</code> 这三个表设置为全局表。这样操作后，三台mysql服务器中都会含有这三个表。</p><p>步骤：停掉mycat  -&gt; 去data grip先将三个mysql中的shopping数据库的表都删除掉 -&gt; 重复上述步骤，仅仅是将配置文件修改一下：</p><p>schema.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_provinces&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_city&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_areas_region&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后在mycat中测试，就能成功执行上述两条sql了。</p><h2 id="10-4-读写分离"><a href="#10-4-读写分离" class="headerlink" title="10.4.读写分离"></a>10.4.读写分离</h2><p>MyCat的schema.xml中的dataHost标签的balance属性</p><div class="table-container"><table><thead><tr><th>balance参数值</th><th>含义</th></tr></thead><tbody><tr><td>0（默认值）</td><td>不开启读写分离机制，所有读操作都发送到当前可用的writeHost上</td></tr><tr><td>1</td><td>全部的readHost与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式）</td></tr><tr><td>2</td><td>所有的读写操作都随机在writeHost，readHost上分发</td></tr><tr><td>3</td><td>所有的读请求随机分发到writeHost对应的readHost上执行。writeHost只负担写压力，不负担读压力</td></tr></tbody></table></div><h3 id="10-4-1-一主一从读写分离"><a href="#10-4-1-一主一从读写分离" class="headerlink" title="10.4.1.一主一从读写分离"></a>10.4.1.一主一从读写分离</h3><ol><li>准备好一主一从，itachi106为主库，itachi107为从库，并且在主库安装好MyCat</li><li>去主库执行sql</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database itachi;</span><br><span class="line"></span><br><span class="line">use itachi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">primary</span> key (id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>mycat配置</li></ol><p>schema.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITACHI_RW&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itachi&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi106:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi107:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>server.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITACHI_RW<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITACHI_RW<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>登录mycat测试</li></ol><p>在itachi107从库中修改表中的某项数据，然后去mycat中查看，结果查看的数据一直是itachi107的数据，多试几次还是这样，说明读的时候是去从库读取的。</p><p>在mycat中插入一行数据，但是在itachi106主库和itachi107主库都能查得到这行新数据，说明写数据是在主库中进行的，因为如果在从库中写入是不会同步到主库的。</p><p><strong>问题：主节点Master宕机之后，业务系统就只能够读，而不能写入数据了。</strong></p><h3 id="10-4-2-双主双从读写分离"><a href="#10-4-2-双主双从读写分离" class="headerlink" title="10.4.2.双主双从读写分离"></a>10.4.2.双主双从读写分离</h3><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。当Master1主机宕机后，Master2 主机负责写请求，Master1、Master2 互为备机。架构图如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/双主双从.png" alt="双主双从"></p><h5 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h5><p>准备5台服务器</p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">主机</th><th style="text-align:center">预装软件</th><th style="text-align:center">角色</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">itachi108</td><td style="text-align:center">mycat、mysql</td><td style="text-align:center">mycat中间件服务器</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">itachi109</td><td style="text-align:center">mysql</td><td style="text-align:center">master1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">itachi110</td><td style="text-align:center">mysql</td><td style="text-align:center">slave1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">itachi111</td><td style="text-align:center">mysql</td><td style="text-align:center">maste2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">itachi112</td><td style="text-align:center">mysql</td><td style="text-align:center">slave2</td></tr></tbody></table></div><p>如果是克隆过来的机器，需要修改每台mysql的uuid，确保不同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 登录mysql</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> uuid();</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> uuid()                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> b33057ff<span class="operator">-</span>bec6<span class="number">-11</span>eb<span class="operator">-</span>ad94<span class="number">-000</span>c29af6856 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line"># 退出mysql，去修改uuid</span><br><span class="line">vim <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>auto.cnf</span><br><span class="line"></span><br><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="搭建-1"><a href="#搭建-1" class="headerlink" title="搭建"></a>搭建</h5><p>主库配置（Master1-itachi109）</p><ol><li>修改配置文件<code>/etc/my.cnf</code></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql服务ID，保证整个集群环境中唯一，取值范围: 1 - 2^32-1，默认为1</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"># 指定同步的数据库</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">db01</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">db02</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">db03</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当当前节点在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line"><span class="attr">log-slave-updates</span></span><br></pre></td></tr></table></figure><ol><li>重启mysql服务</li><li>登录mysql，创建从库连接主库用的远程连接的账号，并授予主从复制权限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建itachi用户，该用户可在任意主机连接该mysql服务</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"># 为<span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>用户分配主从复制权限</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>通过指令，查看二进制日志坐标</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p>主库配置（Master2-itachi111）</p><ol><li>修改配置文件<code>/etc/my.cnf</code></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql服务ID，保证整个集群环境中唯一，取值范围: 1 - 2^32-1，默认为1</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 指定同步的数据库</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">db01</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">db02</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">db03</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 当当前节点在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line"><span class="attr">log-slave-updates</span></span><br></pre></td></tr></table></figure><ol><li><p>重启mysql服务</p></li><li><p>登录mysql，创建从库连接主库用的远程连接的账号，并授予主从复制权限</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建itachi用户，该用户可在任意主机连接该mysql服务</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"># 为<span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>用户分配主从复制权限</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itachi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>通过指令，查看二进制日志坐标</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p>从库配置（Slave1-itachi110）</p><ol><li>修改配置文件<code>/etc/my.cnf</code></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql服务ID，保证整个集群环境中唯一，取值范围: 1 - 2^32-1，默认为1</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><ol><li>重启mysql服务</li><li>登录mysql，设置主库配置</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;itachi109&#x27;</span>,maaster_user<span class="operator">=</span><span class="string">&#x27;itachi&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;binlog.000006&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><ol><li>开启同步操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave; </span><br></pre></td></tr></table></figure><ol><li>查看主从同步状态</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status\G; </span><br></pre></td></tr></table></figure><p>主要看两个字段，如果这两个字段为YES，说明就成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><p>从库配置（Slave2-itachi112）</p><ol><li>修改配置文件<code>/etc/my.cnf</code></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql服务ID，保证整个集群环境中唯一，取值范围: 1 - 2^32-1，默认为1</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">4</span></span><br></pre></td></tr></table></figure><ol><li>重启mysql服务</li><li>登录mysql，设置主库配置</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;itachi111&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;itachi&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;binlog.000007&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><ol><li>开启同步操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> slave; </span><br></pre></td></tr></table></figure><ol><li>查看主从同步状态</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status\G; </span><br></pre></td></tr></table></figure><p>主要看两个字段，如果这两个字段为YES，说明就成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><p>两台主库相互复制</p><p>Master1复制Master2，Master2复制Master1</p><p>在itachi109，即Master1中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;itachi111&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;itachi&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;binlog.000007&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">663</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> slave; </span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> slave status\G; </span><br></pre></td></tr></table></figure><p>在itachi111，即Master2中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;itachi109&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;itachi&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;binlog.000006&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">663</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">start</span> slave; </span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> slave status\G; </span><br></pre></td></tr></table></figure><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p>在Datagrip中，Master1执行创建数据库和表，看看M2和S1和S2是否同步</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db01;</span><br><span class="line"></span><br><span class="line">use db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">primary</span> key (id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后Master2执行插入数据，看看是否同步</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Jack Ma&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Coco&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,sex) <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果测试通过，双主双从搭建完成</p><h5 id="搭建读写分离——MyCat"><a href="#搭建读写分离——MyCat" class="headerlink" title="搭建读写分离——MyCat"></a>搭建读写分离——MyCat</h5><p>schema.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;ITACHI_RW2&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi109:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi110:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi111:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://itachi112:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">readHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>server.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITACHI_RW2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>ITACHI_RW2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="启动mycat"><a href="#启动mycat" class="headerlink" title="启动mycat"></a>启动mycat</h5><h5 id="登录mycat-1"><a href="#登录mycat-1" class="headerlink" title="登录mycat"></a>登录mycat</h5><h5 id="测试主从复制"><a href="#测试主从复制" class="headerlink" title="测试主从复制"></a>测试主从复制</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在mycat中插入数据，然后去datagrip看四个mysql是否都有相应数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user <span class="keyword">value</span>(<span class="number">7</span>,<span class="string">&#x27;jackk&#x27;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h5 id="测试高可用"><a href="#测试高可用" class="headerlink" title="测试高可用"></a>测试高可用</h5><ol><li><p>停掉master1的mysql服务</p></li><li><p>在mycat中测试插入一行数据</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> tb_user <span class="keyword">value</span>(<span class="number">8</span>,<span class="string">&#x27;jackk&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"> OK<span class="operator">!</span></span><br></pre></td></tr></table></figure><ol><li>去datagrip发现M1连接不上，S1没新数据（因为M1挂了），M2和S2都有新数据。并且此时的读请求也不会去s1中执行了，指挥在m2和s2中读取数据。</li><li>重新启动M1的mysql服务，再去datagrip查看M1，自动把新数据同步过来了，且m1和s1恢复工作状态。（热插拔？）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp</title>
      <link href="/post/6.html"/>
      <url>/post/6.html</url>
      
        <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><blockquote><p>示例1：<br>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：爬到i层有dp[i]种方法。</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i] =  dp[i-1] + dp[i-2]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0] = 1 dp[1] = 1 dp[2] = 2</span></span><br><span class="line"><span class="comment">    4.计算顺序：从前往后</span></span><br><span class="line"><span class="comment">    5.举例：n=5</span></span><br><span class="line"><span class="comment">      dp[i]</span></span><br><span class="line"><span class="comment">    1   1</span></span><br><span class="line"><span class="comment">    2   2</span></span><br><span class="line"><span class="comment">    3   3</span></span><br><span class="line"><span class="comment">    4   5</span></span><br><span class="line"><span class="comment">    5   8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h4><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><blockquote><p>示例1：</p><p>输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为 1 的台阶开始。</p><ul><li>支付 15 ，向上爬两个台阶，到达楼梯顶部。 </li></ul><p>总花费为 15 。</p><p>示例2：</p><p>输入：cost = [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为 0 的台阶开始。</p><ul><li>支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</li><li>支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</li><li>支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</li><li>支付 1 ，向上爬一个台阶，到达楼梯顶部。<br>总花费为 6 。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i-<span class="number">1</span>] + cost[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + cost[i-<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：爬到第i层，最小花费是dp[i]</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0] = dp[1] = 0 表示不需要花费就能到达第0/1层</span></span><br><span class="line"><span class="comment">    4.计算顺序：从前往后</span></span><br><span class="line"><span class="comment">    5.举例：cost = [1,100,1,1,1,100,1,1,100,1]</span></span><br><span class="line"><span class="comment">                    dp[i]</span></span><br><span class="line"><span class="comment">    cost[0]=1         0</span></span><br><span class="line"><span class="comment">    cost[1]=100       0</span></span><br><span class="line"><span class="comment">    cost[2]=1         1</span></span><br><span class="line"><span class="comment">    cost[3]=1         2 </span></span><br><span class="line"><span class="comment">    cost[4]=1         2</span></span><br><span class="line"><span class="comment">    cost[5]=100       3</span></span><br><span class="line"><span class="comment">    cost[6]=1         3</span></span><br><span class="line"><span class="comment">    cost[7]=1         4</span></span><br><span class="line"><span class="comment">    cost[8]=100       4</span></span><br><span class="line"><span class="comment">    cost[9]=1         5</span></span><br><span class="line"><span class="comment">    n = 10            6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：到达坐标为(i,j)有dp[i][j]条不同路径</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][i] = dp[i][0] = 1</span></span><br><span class="line"><span class="comment">    4.计算顺序：内外层都顺序</span></span><br><span class="line"><span class="comment">    5.举例：m = 3, n = 7</span></span><br><span class="line"><span class="comment">        1  2  3  4  5  6  7</span></span><br><span class="line"><span class="comment">    1   1  1  1  1  1  1  1</span></span><br><span class="line"><span class="comment">    2   1  2  3  4  5  6  7 </span></span><br><span class="line"><span class="comment">    3   1  3  6  10 15 21 28</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：到达坐标为(i,j)有dp[i][j]条不同路径</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">        如果(i,j)不是障碍：dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="comment">        如果(i,j)是障碍： dp[i][j] = 0</span></span><br><span class="line"><span class="comment">    3.初始化：</span></span><br><span class="line"><span class="comment">        第一行：障碍左边的初始化为1，障碍右边的初始化为0</span></span><br><span class="line"><span class="comment">        第一列：障碍上边的初始化为1，障碍下边的初始化为0</span></span><br><span class="line"><span class="comment">    4.计算顺序：内外层都顺序</span></span><br><span class="line"><span class="comment">    5.举例：</span></span><br><span class="line"><span class="comment">    [0,0,0]</span></span><br><span class="line"><span class="comment">    [0,1,0]</span></span><br><span class="line"><span class="comment">    [0,0,0]</span></span><br><span class="line"><span class="comment">        1  2  3</span></span><br><span class="line"><span class="comment">    1   1  1  1</span></span><br><span class="line"><span class="comment">    2   1  0  1</span></span><br><span class="line"><span class="comment">    3   1  1  2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h4><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p><p>返回 <em>你可以获得的最大乘积</em> 。</p><blockquote><p>示例1：<br>输入: n = 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。</p><p>示例2：</p><p>输入: n = 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 完全背包问题</span><br><span class="line"></span><br><span class="line">#### <span class="number">518.</span>零钱兑换II</span><br><span class="line"></span><br><span class="line">[题目链接](https:<span class="comment">//leetcode-cn.com/problems/coin-change-2/)</span></span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-coins[i]];</span><br><span class="line">                <span class="comment">// System.out.print(dp[j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.dp[j]含义：容量为j的背包，装满此背包的方式有dp[j]种</span></span><br><span class="line"><span class="comment">    2.递推式：dp[j] = dp[j] + dp[j-weight[i]]</span></span><br><span class="line"><span class="comment">    dp[j]是不选物品j  dp[j-weight[i]]选物品j</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0]=1，表示装满容量0的背包，有一种方式，那就是什么也不装</span></span><br><span class="line"><span class="comment">    4.顺序：完全背包的组合问题，外层先遍历物品，内层遍历背包，内层循环从小到大，因为物品是可以添加多次的</span></span><br><span class="line"><span class="comment">    5.举例：amount=5，coins=[1,2,5]</span></span><br><span class="line"><span class="comment">    i  j 0 1 2 3 4 5</span></span><br><span class="line"><span class="comment">    0    1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">    1    1 1 2 2 3 3</span></span><br><span class="line"><span class="comment">    2    1 1 2 2 3 4</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    对于以上举例，程序运行的输出如下：</span></span><br><span class="line"><span class="comment">    1 1 1 1 1 </span></span><br><span class="line"><span class="comment">      2 2 3 3 </span></span><br><span class="line"><span class="comment">            4 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p><ul><li><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p></li><li><p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p><p>（本问题属于组合数问题）</p></li></ul></blockquote><h4 id="377-组合总和IV⭐⭐⭐"><a href="#377-组合总和IV⭐⭐⭐" class="headerlink" title="377.组合总和IV⭐⭐⭐"></a>377.组合总和IV⭐⭐⭐</h4><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">题目链接</a></p><blockquote><p>此题目名为组合，实则是排列问题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j - nums[i]];</span><br><span class="line">                    <span class="comment">// System.out.print(dp[j] + &quot; &quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.dp[j]：表示凑成容量为j的背包的排列个数为dp[j]</span></span><br><span class="line"><span class="comment">    2.递推式：dp[j] = dp[j] + dp[j-nums[i]]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0] = 1</span></span><br><span class="line"><span class="comment">    4.遍历顺序：完全背包排列问题，外层先遍历背包，内层遍历物品，内层从小到大</span></span><br><span class="line"><span class="comment">    5.举例：nums = [1,2,3], target = 4</span></span><br><span class="line"><span class="comment">        j 0 1 2 3 4</span></span><br><span class="line"><span class="comment">    i</span></span><br><span class="line"><span class="comment">    0     1 1 1 2 4</span></span><br><span class="line"><span class="comment">    1         2 3 6 </span></span><br><span class="line"><span class="comment">    2           4 7</span></span><br><span class="line"><span class="comment">    对于以上举例，程序运行的输出如下：</span></span><br><span class="line"><span class="comment">    1 </span></span><br><span class="line"><span class="comment">    1 2 </span></span><br><span class="line"><span class="comment">    2 3 4 </span></span><br><span class="line"><span class="comment">    4 6 7 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果把题目改成组合问题，外层先遍历物品，内层遍历背包，举例如下：</span></span><br><span class="line"><span class="comment">        j 0 1 2 3 4</span></span><br><span class="line"><span class="comment">    i</span></span><br><span class="line"><span class="comment">    0     1 1 1 1 1</span></span><br><span class="line"><span class="comment">    1         2 2 3 </span></span><br><span class="line"><span class="comment">    2           3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.leef.fun/typora/s3/img/完全背包之排列-组合总和4.jpg" alt="完全背包之排列-组合总和4"></p><p><img src="http://cdn.leef.fun/typora/s3/img/完全背包之组合-组合总和4.jpg" alt="完全背包之组合-组合总和4"></p><blockquote><p>如果本题要把排列都列出来的话，只能使⽤回溯算法爆搜。</p></blockquote><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h4><p><a href="https://leetcode.cn/problems/coin-change/">题目链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j-coins[i]] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j-coins[i]] + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// System.out.print(dp[j] + &quot; &quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. dp[j]：装满容量为j的背包的最小硬币数为dp[j]</span></span><br><span class="line"><span class="comment">    2. 递推式：dp[j] = min(dp[j],dp[j-coins[i]+1])</span></span><br><span class="line"><span class="comment">    3. 初始化：dp[0] = 0 表示装满容量为0的背包的最小硬币数是0个硬币， 其他初始化为正无穷</span></span><br><span class="line"><span class="comment">    4. 遍历顺序：外层先遍历背包；内层遍历物品，从小到大</span></span><br><span class="line"><span class="comment">    5. 举例：coins = [1, 2, 5], amount = 11</span></span><br><span class="line"><span class="comment">            0 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">coins[0]=1  0 1 2 2 3 3 2 3 3 4 4  3 </span></span><br><span class="line"><span class="comment">coins[1]=2      1 2 2 3 2 2 3 3 4  3</span></span><br><span class="line"><span class="comment">coins[2]=5            1 2 2 3 3 2  3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标准输出为：</span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">2 1 </span></span><br><span class="line"><span class="comment">2 2 </span></span><br><span class="line"><span class="comment">3 2 </span></span><br><span class="line"><span class="comment">3 3 1 </span></span><br><span class="line"><span class="comment">2 2 2 </span></span><br><span class="line"><span class="comment">3 2 2 </span></span><br><span class="line"><span class="comment">3 3 3 </span></span><br><span class="line"><span class="comment">4 3 3 </span></span><br><span class="line"><span class="comment">4 4 2 </span></span><br><span class="line"><span class="comment">3 3 3 </span></span><br><span class="line"><span class="comment">和预测的一模一样！！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举例2：coins = [2], amount = 3</span></span><br><span class="line"><span class="comment">            0 1         2   3 </span></span><br><span class="line"><span class="comment">coins[0]=2  0 maxvalue  1   maxvalue</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p><p><strong>518.零钱兑换II</strong> 中求的是组合数，<strong>377. 组合总和 Ⅳ</strong> 中求的是排列数。 </p><p>⽽本题是要求最少硬币数量，硬币是组合数还是排列数都⽆所谓！所以两个for循环先后顺序怎样都可以！</p></blockquote><h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i * i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j - i * i] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// System.out.print(dp[j] + &quot; &quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">values[] = &#123;1², 2², 3², ... , x²&#125; x为n的开平方</span></span><br><span class="line"><span class="comment">背包总重量为n</span></span><br><span class="line"><span class="comment">本题和322.零钱兑换一致，五部曲就不再赘述了，只做出举例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举例：n = 13</span></span><br><span class="line"><span class="comment">        0 1 2 3 4 5 6 7 8 9 10 11 12 13</span></span><br><span class="line"><span class="comment">1²=1    0 1 2 3 4 5 6 7 8 9 10 11 12 13</span></span><br><span class="line"><span class="comment">2²=4    0 1 2 3 1 2 3 4 2 3 4  5  3  4</span></span><br><span class="line"><span class="comment">3²=9    0 1 2 3 1 2 3 4 2 1 2  3  3  2</span></span><br><span class="line"><span class="comment">程序输出为：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10 11 12 13 </span></span><br><span class="line"><span class="comment">      1 2 3 4 2 3 4  5  3  4 </span></span><br><span class="line"><span class="comment">                1 2  3  3  2 </span></span><br><span class="line"><span class="comment">与预测的一致</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"># 其他</span><br><span class="line"></span><br><span class="line">## 股票问题</span><br><span class="line"></span><br><span class="line">#### <span class="number">121.</span>买卖股票的最佳时机</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> -prices[<span class="number">0</span>], dp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dpi0</span> <span class="operator">=</span> Math.max(dp0, -prices[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> Math.max(dp1, prices[i] + dp0);</span><br><span class="line">            dp0 = dpi0;</span><br><span class="line">            dp1 = dpi1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1. dp[i][0]：持有股票之后的最大资产</span></span><br><span class="line"><span class="comment">       dp[i][1]: 不持有股票（卖掉股票）之后的最大资产</span></span><br><span class="line"><span class="comment">    2. 递推式：dp[i][0] = max(dp[i-1][0], -price[i])</span></span><br><span class="line"><span class="comment">              dp[i][1] = max(dp[i-1][1], price[i] + dp[i-1][0])</span></span><br><span class="line"><span class="comment">       注：假设这个人的初始资产为0，那么它入股第i个股票后，他持有股票之后的资产就是-price[i]</span></span><br><span class="line"><span class="comment">        在第一个递推式中：要么是保持前一天买的股票，要么是今天买入股票，取决于谁的绝对值最小，也就是谁的股票便宜</span></span><br><span class="line"><span class="comment">        在第二个递推式中：要么是前一天的结果，要么是今天卖出股票的利润，取决于谁的大，也就是谁的利润多</span></span><br><span class="line"><span class="comment">    3. 初始化：dp[i][0] = -prices[0] </span></span><br><span class="line"><span class="comment">              dp[i][1] = 0</span></span><br><span class="line"><span class="comment">    4. 计算顺序： 从前往后</span></span><br><span class="line"><span class="comment">    5. 举例：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">        dp[i][0]    dp[i][1]</span></span><br><span class="line"><span class="comment">    7   -7          0</span></span><br><span class="line"><span class="comment">    1   -1          0</span></span><br><span class="line"><span class="comment">    5   -1          4</span></span><br><span class="line"><span class="comment">    3   -1          4</span></span><br><span class="line"><span class="comment">    6   -1          5</span></span><br><span class="line"><span class="comment">    4   -1          5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> -prices[<span class="number">0</span>], dp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(dp0 + &quot; &quot; + dp1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dpi0</span> <span class="operator">=</span> Math.max(dp0, dp1-prices[i]);</span><br><span class="line">            <span class="comment">// dp0是保持原有的股票，dp1-prices[i]是昨天卖掉股票，今天新买入股票</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> Math.max(dp1, prices[i] + dp0);</span><br><span class="line">            <span class="comment">// dp1是昨天不持股票的最大资产，prices[i]+dp0是今天卖出股票后的资产。</span></span><br><span class="line">            dp0 = dpi0;</span><br><span class="line">            dp1 = dpi1;</span><br><span class="line">            <span class="comment">//System.out.println(dp0 + &quot; &quot; + dp1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    5. 举例：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">        dp[i][0]    dp[i][1]</span></span><br><span class="line"><span class="comment">    7   -7          0</span></span><br><span class="line"><span class="comment">    1   -1          0</span></span><br><span class="line"><span class="comment">    5   -1          4</span></span><br><span class="line"><span class="comment">    3   1           4</span></span><br><span class="line"><span class="comment">    6   1           7</span></span><br><span class="line"><span class="comment">    4   3           7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h4><blockquote><p>给定两个字符串 text1 和 text2，返回它们的最长公共子序列的长度。如果不存在公共子序列 ，返回 0。</p><p>（PS:这里的子序列<strong>不要求连续</strong>。）</p><p>示例1：</p><blockquote><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length(), n2 = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：dp[i][j]表示text1[0...i-1]和text2[0...j-1]的最长公共子序列为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">        if text1[i]==text2[j] then dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment">        else then dp[i][j] = max(dp[i][j-1], dp[i-1][j])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = 0, dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层text1，内层text2。反之亦行</span></span><br><span class="line"><span class="comment">    5.举例：text1 = &quot;abcde&quot; text2 = &quot;ace&quot;</span></span><br><span class="line"><span class="comment">    dp[i][j]  0 a c e</span></span><br><span class="line"><span class="comment">        0     0 0 0 0</span></span><br><span class="line"><span class="comment">        a     0 1 1 1</span></span><br><span class="line"><span class="comment">       b     0 1 1 1</span></span><br><span class="line"><span class="comment">        c     0 1 2 2</span></span><br><span class="line"><span class="comment">        d  0 1 2 2</span></span><br><span class="line"><span class="comment">        e  0 1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h4><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>（PS:这里的子序列<strong>不要求连续</strong>。）</p><p>示例1：</p><blockquote><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">            <span class="comment">// System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：以nums[i]为结尾的最长严格递增子序列长度为dp[i]</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i] = max(dp[j] + 1) 其中0&lt;=j&lt;i且nums[i] &gt; nums[j]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0...i-1] = 1</span></span><br><span class="line"><span class="comment">    4.计算顺序：顺序，从小到大</span></span><br><span class="line"><span class="comment">    5.举例：nums = [10,9,2,5,3,7,101,18]</span></span><br><span class="line"><span class="comment">    nums[i]:    10 9 2 5 3 7 101 18</span></span><br><span class="line"><span class="comment">    dp[i]:      1  1 1 2 2 3 4   4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718.最长重复子数组"></a>718.最长重复子数组</h4><blockquote><p>给两个整数数组 nums1和 nums2 ，返回两个数组中公共的 、长度最长的子数组的长度。</p><p>（PS:子数组是<strong>要求连续</strong>的）</p><p>示例1：</p><blockquote><p>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3,2,1] 。</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> nums1.length, n2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = Math.max(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：以下标i-1为结尾的nums1和以下标j-1为结尾的nums2，最长重复子数组长度为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.dp[i][j] = dp[i-1][j-1] + 1 , if nums[i-1]==nums[j-1]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层nums1，内层nums2，反之亦行。</span></span><br><span class="line"><span class="comment">    5.举例：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span></span><br><span class="line"><span class="comment">        0 3 2 1 4 7</span></span><br><span class="line"><span class="comment">    0   0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    1   0 0 0 1 0 0</span></span><br><span class="line"><span class="comment">    2   0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">    3   0 1 0 0 0 0</span></span><br><span class="line"><span class="comment">    2   0 0 2 0 0 0</span></span><br><span class="line"><span class="comment">    1   0 0 0 3 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h4><blockquote><p>给定一个未经排序的整数数组，找到最长且<strong>连续</strong>递增的子序列，并返回该序列的长度。</p><p>（PS：<strong>要求连续</strong>）</p><p>示例1：</p><blockquote><p>输入：nums = [1,3,5,4,7]</p><p>输出：3</p><p>解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</p></blockquote></blockquote><h5 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1. dp[i]表示以nums[i]为结尾的最大连续递增子序列的长度</span></span><br><span class="line"><span class="comment">    2. 递推式：dp[i] = dp[i-1] + 1 （如果nums[i] &gt; nums[i-1]）</span></span><br><span class="line"><span class="comment">    3. 初始化：dp[0...n] = 1</span></span><br><span class="line"><span class="comment">    4. 计算顺序：从前往后</span></span><br><span class="line"><span class="comment">    5. 举例：nums = [1,3,5,4,7]</span></span><br><span class="line"><span class="comment">        nums[i] 1 3 5 4 7</span></span><br><span class="line"><span class="comment">        dp[i]   1 2 3 1 2  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DP算法</span></span><br><span class="line"><span class="comment">    时间复杂度O(n)</span></span><br><span class="line"><span class="comment">    空间复杂度O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                curLen++;</span><br><span class="line">                res = Math.max(res, curLen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curLen = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    贪心算法</span></span><br><span class="line"><span class="comment">    时间复杂度O(n)</span></span><br><span class="line"><span class="comment">    空间复杂度O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h4><blockquote><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p><p>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：</p><blockquote><p> nums1[i] == nums2[j]<br>且绘制的直线不与任何其他连线（非水平线）相交。</p></blockquote><p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p><p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p><p>示例1：</p><blockquote><p>输入：nums1 = [1,4,2], nums2 = [1,2,4]<br>输出：2<br>解释：可以画出两条不交叉的线，如上图所示。<br>但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</p></blockquote></blockquote><p><img src="http://cdn.leef.fun/typora/s3/img/142.png" alt="1035示例一的图片" style="zoom: 25%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> nums1.length, n2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：长度为i-1的nums1和长度为j-1的nums2的不相交线数为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：if nums[i-1]==nums[j-1]</span></span><br><span class="line"><span class="comment">                    dp[i][j] = dp[i-1][j-1] + 1 </span></span><br><span class="line"><span class="comment">             else</span></span><br><span class="line"><span class="comment">                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层nums1，内层nums2，反之亦行。</span></span><br><span class="line"><span class="comment">    5.举例：nums1 = [1,4,2], nums2 = [1,2,4]</span></span><br><span class="line"><span class="comment">            nums2   1 2 4</span></span><br><span class="line"><span class="comment">    nums1     0     0 0 0      </span></span><br><span class="line"><span class="comment">      1       0     1 1 1    </span></span><br><span class="line"><span class="comment">      4       0     1 1 2</span></span><br><span class="line"><span class="comment">      2       0     1 2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注：这道题代码和 <strong>1143.最长公共子序列 </strong>一模一样。</p></blockquote><h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p><p>示例1：</p><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p></blockquote><h5 id="DP解法-1"><a href="#DP解法-1" class="headerlink" title="DP解法"></a>DP解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(nums[i], dp[i-<span class="number">1</span>] + nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">            <span class="comment">// System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：以下标i为结尾的最大子数组和为dp[i]</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i] = max(nums[i], dp[i-1] + nums[i])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0] = nums[0]</span></span><br><span class="line"><span class="comment">    4.计算顺序：从小到大</span></span><br><span class="line"><span class="comment">    5.举例：nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span><br><span class="line"><span class="comment">        -2 1 -3 4 -1 2 1 -5 4</span></span><br><span class="line"><span class="comment">        -2 1 -2 4  3 5 6  1 5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="分治解法"><a href="#分治解法" class="headerlink" title="分治解法"></a>分治解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getMaxSubArray(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxSubArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l]; <span class="comment">// 退出条件：数组长度为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l_sum</span> <span class="operator">=</span> getMaxSubArray(nums, l, mid); <span class="comment">// 子问题nums[l...mid]的最大子数组和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r_sum</span> <span class="operator">=</span> getMaxSubArray(nums, mid + <span class="number">1</span>, r); <span class="comment">// 子问题nums[mid+1...r]的最大子数组和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m_sum</span> <span class="operator">=</span> merge(nums, l, mid, r); <span class="comment">// 两个子问题合并后可能的最大子数组和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求l_sum l_sum m_sum 三者中的最大值，即为将两个子问题合并后的答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(l_sum, r_sum);</span><br><span class="line">        res = Math.max(res, m_sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并nums[l...mid]和nums[mid+1...r]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left_sum</span> <span class="operator">=</span> <span class="number">0</span>, left_res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid; i &gt;= l; i--) &#123;</span><br><span class="line">            left_sum += nums[i];</span><br><span class="line">            left_res = Math.max(left_res, left_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right_sum</span> <span class="operator">=</span> <span class="number">0</span>, right_res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            right_sum += nums[i];</span><br><span class="line">            right_res = Math.max(right_res, right_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left_res + right_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编辑距离类问题"><a href="#编辑距离类问题" class="headerlink" title="编辑距离类问题"></a>编辑距离类问题</h2><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h4><blockquote><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p><p>示例1：</p><blockquote><p>输入：s = “abc”, t = “ahbgdc”</p><p>输出：true</p></blockquote></blockquote><h5 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (j &lt; t.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(j++) == cur) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    最差时间复杂度：O(n+m) 其中n = s.length, m = t.length</span></span><br><span class="line"><span class="comment">    空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="DP解法-2"><a href="#DP解法-2" class="headerlink" title="DP解法"></a>DP解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m] == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：s[0...i-1]和t[0...j-1]的最长公共子序列长度为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：if s[i-1] == s[j-1]</span></span><br><span class="line"><span class="comment">                dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment">             else</span></span><br><span class="line"><span class="comment">                dp[i][j] = dp[i][j-1]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层s，内层t</span></span><br><span class="line"><span class="comment">    5.举例：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span></span><br><span class="line"><span class="comment">        0 a h b g d c</span></span><br><span class="line"><span class="comment">    0   0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    a   0 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">    b   0 0 0 2 2 2 2</span></span><br><span class="line"><span class="comment">    c   0 0 0 0 0 0 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    6.最终返回结果：dp[n][m] == s.length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DP算法：</span></span><br><span class="line"><span class="comment">        时间复杂度：O(nm)</span></span><br><span class="line"><span class="comment">        空间复杂度：O(nm)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h4><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>示例1：</p><blockquote><p>输入：s = “rabbbit”, t = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br><u>rabb</u>b<u>it</u><br><u>ra</u>b<u>bbit</u><br><u>rab</u>b<u>bit</u></p></blockquote><p>示例2：</p><blockquote><p>输入：s = “babgbag”, t = “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br><strong>ba</strong>b<strong>g</strong>bag<br><strong>ba</strong>bgba<strong>g</strong><br><strong>b</strong>abgb<strong>ag</strong><br>ba<strong>b</strong>gb<strong>ag</strong><br>babg<strong>bag</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    “计算在 s 的子序列中 t 出现的个数。”这句话和下面一句话是等价的</span></span><br><span class="line"><span class="comment">    “在s中删除元素，使得他变成t，有几种删除的方式？”</span></span><br><span class="line"><span class="comment">    1.含义：s[0...i-1]的子序列中出现t[0...j-1]的个数为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：如果s[i-1] == t[j-1]: </span></span><br><span class="line"><span class="comment">                dp[i][j] =  dp[i-1][j-1] + dp[i-1][j]</span></span><br><span class="line"><span class="comment">             否则：</span></span><br><span class="line"><span class="comment">                dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment">    其中dp[i-1][j-1]是用s[i-1]来匹配，dp[i-1][j-1]是不用s[i-1]来匹配（即删除掉s[i-1]）</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0...n-1][0] = 1 表示只能删掉s的所有元素才能变成t，即包含1个t</span></span><br><span class="line"><span class="comment">                dp[0][1...m-1] = 0 表示s为空字符串，他不可能包含t</span></span><br><span class="line"><span class="comment">    4.计算顺序：由递推式可知，dp[i][j]是由左上边或者上边得来</span></span><br><span class="line"><span class="comment">                ，故计算顺序为外层遍历s内层遍历t，从小到大</span></span><br><span class="line"><span class="comment">    5.举例：</span></span><br><span class="line"><span class="comment">            0 r a b b i t</span></span><br><span class="line"><span class="comment">        0   1 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">        r   1 1 0 0 0 0 0</span></span><br><span class="line"><span class="comment">        a   1 1 1 0 0 0 0</span></span><br><span class="line"><span class="comment">        b   1 1 1 1 0 0 0</span></span><br><span class="line"><span class="comment">        b   1 1 1 2 1 0 0</span></span><br><span class="line"><span class="comment">        b   1 1 1 3 3 0 0</span></span><br><span class="line"><span class="comment">        i   1 1 1 3 3 3 0</span></span><br><span class="line"><span class="comment">        t   1 1 1 3 3 3 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><pre><code>“计算在 s 的子序列中 t 出现的个数。”这句话和下面一句话是等价的“在s中删除元素，使得他变成t，有几种删除的方式？”也可以理解为：之前都是求编辑距离的最小值，这次是求编辑的方式有多少种！</code></pre></blockquote><h4 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h4><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p><p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p><p>示例1：</p><blockquote><p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2<br>解释: 第一步将 “sea” 变为 “ea” ，第二步将 “eat “变为 “ea”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(), m = word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>, dp[i][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：使得word1[0...i-1]和word2[0...j-1]相同所需最小步数为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：  如果word1[i-1] == word1[j-1]：</span></span><br><span class="line"><span class="comment">                    dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">                否则：</span></span><br><span class="line"><span class="comment">                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1)</span></span><br><span class="line"><span class="comment">        其中dp[i-1][j-1]表示使用(不删除)word1[i-1]和word2[j-1]</span></span><br><span class="line"><span class="comment">        dp[i-1][j]表示不使用word1[i-1]，即需要删除word1[i-1]，所以步数+1</span></span><br><span class="line"><span class="comment">        dp[i][j-1]表示不使用word2[j-1]，即需要删除word2[j-1]，所以步数+1</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = j, dp[i][0] = i </span></span><br><span class="line"><span class="comment">        当有一个字符串为空串时，另一个字符串只能删掉他的所有的元素，所以最小步数为另一个字符串的长度</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层word1，内层wordw2，从小到大</span></span><br><span class="line"><span class="comment">    5.举例：word1 = &quot;sea&quot;, word2 = &quot;eat&quot;</span></span><br><span class="line"><span class="comment">        0 e a t</span></span><br><span class="line"><span class="comment">    0   0 1 2 3</span></span><br><span class="line"><span class="comment">    s   1 2 3 4</span></span><br><span class="line"><span class="comment">    e   2 1 2 3 </span></span><br><span class="line"><span class="comment">    a   3 2 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="72-编辑距离-研一算法考试的题目"><a href="#72-编辑距离-研一算法考试的题目" class="headerlink" title="72. 编辑距离(研一算法考试的题目)"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a>(研一算法考试的题目)</h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><pre><code>插入一个字符删除一个字符替换一个字符</code></pre><p>示例1：</p><blockquote><p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p></blockquote><p>示例2：</p><blockquote><p>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(), m = word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>, dp[i][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：word1[0...i-1]转换成word2[0...j-1]所使用的最少操作数为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：  如果word1[i-1]==word2[j-1]:</span></span><br><span class="line"><span class="comment">                    dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">                否则：</span></span><br><span class="line"><span class="comment">                    dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        其中dp[i-1][j-1]+1表示让word1[i-1]替换成word2[j-1]</span></span><br><span class="line"><span class="comment">        dp[i-1][j]+1表示把word1[i-1]删除掉</span></span><br><span class="line"><span class="comment">        dp[i][j-1]+1表示把word2[j-1]删除掉（等价于在word1[i-1]后面插入一个word2[j-1]）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = j, dp[i][0] = i </span></span><br><span class="line"><span class="comment">        当有一个字符串为空串时，另一个字符串只能删掉他的所有的元素，所以最小步数为另一个字符串的长度</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层word1，内层wordw2，从小到大</span></span><br><span class="line"><span class="comment">    5.举例：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span></span><br><span class="line"><span class="comment">        0 r o s</span></span><br><span class="line"><span class="comment">    0   0 1 2 3</span></span><br><span class="line"><span class="comment">    h   1 1 2 3</span></span><br><span class="line"><span class="comment">    o   2 2 1 2</span></span><br><span class="line"><span class="comment">    r   3 2 2 2</span></span><br><span class="line"><span class="comment">    s   4 3 3 2</span></span><br><span class="line"><span class="comment">    e   5 4 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h4><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p><p>示例1：</p><blockquote><p>输入：s = “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p></blockquote><p>示例2：</p><blockquote><p>输入：s = “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p></blockquote><p>DP解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j) &#123; <span class="comment">// &quot;a&quot;</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == j) &#123;<span class="comment">// &quot;aa&quot;</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) &#123;<span class="comment">// &quot;a回文串a&quot;</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：dp[i][j]=true表示s[i..j]是回文串，false表示不是回文串。</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">            if (s[i] == s[j]) </span></span><br><span class="line"><span class="comment">                if (i==j) dp[i][j] = true  这种情况是 单单一个字符</span></span><br><span class="line"><span class="comment">                else if (i+1==j) dp[i][j] = true 这种情况是 两个重复的字符</span></span><br><span class="line"><span class="comment">                else dp[i][j] = dp[i+1][j-1] 取决于着两个相同字符之间的字串是不是回文串</span></span><br><span class="line"><span class="comment">    3.初始化:dp[i][j] = false</span></span><br><span class="line"><span class="comment">    4.计算顺序：由递推式知，dp[i][j]是从左下方推出来的</span></span><br><span class="line"><span class="comment">            所以遍历顺序为，外层i 从n down to 0, 内层j 从0 up to n</span></span><br><span class="line"><span class="comment">    5.举例：(注：i &gt; j 是无意义的，全都为false)</span></span><br><span class="line"><span class="comment">    s = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">        a b c</span></span><br><span class="line"><span class="comment">    a   t f f</span></span><br><span class="line"><span class="comment">    b     t f</span></span><br><span class="line"><span class="comment">    c       t</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    s = &quot;aaa&quot;</span></span><br><span class="line"><span class="comment">        a a a</span></span><br><span class="line"><span class="comment">    a   t t t</span></span><br><span class="line"><span class="comment">    a   f t t</span></span><br><span class="line"><span class="comment">    a   f f t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dp解法的时间复杂度：O(n²)</span></span><br><span class="line"><span class="comment">        空间复杂度：O(n²)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p>示例1：</p><blockquote><p>输入：s = “bbbab”</p><p>输出：4</p><p>解释：一个可能的最长回文子序列为 “bbbb” 。</p></blockquote><p>DP解法1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == j) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：s[i..j]的最长回文子序列长度为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">        if (s[i] == s[j]) </span></span><br><span class="line"><span class="comment">            if (i==j)   dp[i][j] = 1</span></span><br><span class="line"><span class="comment">            elif (i+1==j) dp[i][j] = 2</span></span><br><span class="line"><span class="comment">            else dp[i][j] = dp[i+1][j-1]+2</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            dp[i][j] = max(dp[i][j-1], dp[i+1][j])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[i][j]] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：由递推式知，dp[i][j]由左下，左，下得来。</span></span><br><span class="line"><span class="comment">            所以计算顺序为：外层i from n down to 1</span></span><br><span class="line"><span class="comment">                            内层j from 0 up to n</span></span><br><span class="line"><span class="comment">    5.举例：s = &quot;bbbab&quot;</span></span><br><span class="line"><span class="comment">        b b b a b</span></span><br><span class="line"><span class="comment">    b   1 2 3 3 4</span></span><br><span class="line"><span class="comment">    b   0 1 2 2 3</span></span><br><span class="line"><span class="comment">    b   0 0 1 1 3</span></span><br><span class="line"><span class="comment">    a   0 0 0 1 1</span></span><br><span class="line"><span class="comment">    b   0 0 0 0 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>DP解法2：将原问题转换为了LCS问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> reverse(s);</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverse</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ch[i] = s.charAt(n-i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题转换：将s翻转得到t，求s和t的最长公共子序列</span></span><br><span class="line"><span class="comment">    如，s = &quot;bbbab&quot;, t = &quot;babbb&quot; 他们的LCS = &quot;bbb&quot;即为s的最长回文子序列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1.含义：s[0...i-1]和t[0...j-1]的LCS为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">        if (s[i-1]==t[j-1])</span></span><br><span class="line"><span class="comment">            dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">    3.初始化： dp[0][j] = 0, dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层s，内层t，都是从小到大</span></span><br><span class="line"><span class="comment">    5.举例：s = &quot;bbbab&quot;, t = &quot;babbb&quot; </span></span><br><span class="line"><span class="comment">        0 b a b b b</span></span><br><span class="line"><span class="comment">    0   0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    b   0 1 1 1 1 1</span></span><br><span class="line"><span class="comment">    b   0 1 1 2 2 2</span></span><br><span class="line"><span class="comment">    b   0 1 1 2 3 3</span></span><br><span class="line"><span class="comment">    a   0 1 2 2 3 3</span></span><br><span class="line"><span class="comment">    b   0 1 2 3 3 4</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/post/3.html"/>
      <url>/post/3.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-UDP"><a href="#1-UDP" class="headerlink" title="1.UDP"></a>1.UDP</h1><ol><li>UDP是==无连接==的，减少开销和发送数据之前的时延</li><li>UDP使用最大努力交付，即==不保证可靠交付==</li><li>UDP是==面向报文的==，适合一次性传输少量数据的网络应用<ul><li>（应用层给UDP多长的报文，UDP就发送多长的报文，即一次发一个完整报文）</li></ul></li><li>UDP==无拥塞控制==，适合很多实时应用。也==不提供流量控制。==</li><li>UDP首部开销小。8B。（TCP是20B）</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/UDP报文结构.png" alt="UDP报文结构"></p><h1 id="2-TCP"><a href="#2-TCP" class="headerlink" title="2.TCP"></a>2.TCP</h1><ol><li>TCP是==面向连接==的传输层协议</li><li>每一条TCP连接只能有两个端点，只能是==点对点的==</li><li>TCP提供==可靠==交付的服务。无差错、不丢失、不重复、按需到达。</li><li>TCP提供==全双工通信==</li><li>TCP==面向字节流==</li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/TCP报文段.png" alt="TCP报文段"></p><blockquote><p> 控制位依次是URG、ACK、PSH、RST、SYN、FIN</p><p>SYN只有在两种情况下置为1：①连接请求  ②连接请求的接受/确认</p></blockquote><p>TCP连接传输的三个阶段：连接建立 ——&gt; 数据传送 ——&gt; 连接释放</p><h2 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1.三次握手"></a>2.1.三次握手</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/TCP三次握手.png" alt="TCP三次握手"></p><blockquote><p>第一次和第二次不携带数据，第三次可以携带数据。</p><p>SYN洪范攻击：服务端的资源是在第二次握手时分配的，如果攻击者不断发送三次握手的第一个数据包，却不发送第三个确认包，那么服务端的资源就会被消耗占用。</p></blockquote><h2 id="2-2-四次挥手"><a href="#2-2-四次挥手" class="headerlink" title="2.2.四次挥手"></a>2.2.四次挥手</h2><p><img src="http://cdn.leesin.fun/typora/s3/img/TCP四次挥手.png" alt="TCP四次挥手"></p><h2 id="2-3-可靠传输"><a href="#2-3-可靠传输" class="headerlink" title="2.3.可靠传输"></a>2.3.可靠传输</h2><h3 id="2-3-1-序号"><a href="#2-3-1-序号" class="headerlink" title="2.3.1.序号"></a>2.3.1.序号</h3><p>​    TCP首部的<strong>序号字段</strong>用来==保证数据有序提交==给应用层，TCP把数据视为一个无结构但有序的字节流，将字节流上的每一个字节都编上一个序号，序号字段的值是指本报文段所发送的数据的第一个字节的序号。</p><p>​    如图所示，第一个报文包含第0~2个字节，则该TCP报文段的序号是0，第二个报文段的序号是3。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/A的发送缓存区中的数据划分成TCP段.png" alt="A的发送缓存区中的数据划分成TCP段"></p><h3 id="2-3-2-确认"><a href="#2-3-2-确认" class="headerlink" title="2.3.2.确认"></a>2.3.2.确认</h3><ul><li>TCP首部的<strong>确认号</strong>是期望收到对方的下一个报文段的数据的第一个字节的序号。<ul><li>如上图，如果接收方B已收到第一个报文段，此时B会发送给A的报文中的确认号字段为3。</li></ul></li><li>发送方会缓存那些已经已发送但未收到确认的报文段，以便在需要时重传。（滑动窗口）</li><li>TCP默认使用<strong>累积确认</strong>。</li></ul><h3 id="2-3-3-重传"><a href="#2-3-3-重传" class="headerlink" title="2.3.3.重传"></a>2.3.3.重传</h3><p>两种事件会导致TCP对报文段进行重传：==超时== 和 ==3个冗余ACK==</p><ol><li>超时</li></ol><p>多久超时重传？⭐⭐⭐TCP保留了RTT的一个加权平均往返时间RTTs，它会随新测量RTT样本值的变化而变化。超时计时器设置的超时重传时间应略大于RTTs，但也不能大太多，否则当报文段丢失时，TCP不能很快重传，导致数据传输时延大。</p><ol><li>冗余ACK</li></ol><p>超时重传存在的问题是超时周期往往太长了。    </p><p>比如A发送了序号为1、2、3、4、5的TCP报文段，其中2号丢失了，因此3、4、5号报文段对于B来说就是失序报文段。TCP规定时序报文段到达时，就发送一个冗余ACK，指明下一个期待字节的序号。在这个例子中，3、4、5号报文段到达B，那么B就会发送3个对2号报文段的冗余ACK，表明自己希望接收到2号报文段。然后A接收到了3个冗余ACK后，A会认为2号已经丢失了，会立即对2号报文执行重传，这种技术称为<strong>快重传</strong>。</p><h2 id="2-4-流量控制"><a href="#2-4-流量控制" class="headerlink" title="2.4.流量控制"></a>2.4.流量控制</h2><p>​        TCP提供流量控制服务来消除发送方（发送速率太快）使接收方缓存区溢出的可能性，因此可以说==流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的发送速率）==。</p><p>​        TCP提供一种基于 <strong>滑动窗口协议 </strong> 的流量控制机制。</p><p>​        在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为接收窗口rwnd，即调整TCP报文段首部的”窗口“字段值，来限制发送方向网格注入报文的速率。同时，发送方根据其对当前网络拥塞程度的估计而确定的窗口之，称为拥塞窗口cwnd。发送方的发送窗口=min(rwnd, cwnd)</p><p>​        举例，如图所示。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/TCP流量控制举例.png" alt="TCP流量控制举例"></p><h2 id="2-5-拥塞控制"><a href="#2-5-拥塞控制" class="headerlink" title="2.5.拥塞控制"></a>2.5.拥塞控制</h2><p>​        ==拥塞控制是防止过多的数据注入网络，保证网络中的路由器或链路不会过载。==</p><h3 id="2-5-1-慢开始和拥塞控制"><a href="#2-5-1-慢开始和拥塞控制" class="headerlink" title="2.5.1.慢开始和拥塞控制"></a>2.5.1.慢开始和拥塞控制</h3><ul><li>cwnd&lt;ssthresh：慢开始算法</li><li>cwnd&gt;ssthresh：拥塞避免算法</li></ul><p>网络拥塞的处理：把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半，然后将cwnd设置为1开始慢开始算法。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/慢开始和拥塞避免算法的实现过程.png" alt="慢开始和拥塞避免算法的实现过程"></p><h3 id="2-5-2-快重传和快恢复"><a href="#2-5-2-快重传和快恢复" class="headerlink" title="2.5.2.快重传和快恢复"></a>2.5.2.快重传和快恢复</h3><p>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p><ol><li>快重传</li></ol><p>​        在TCP的可靠传输机制中，快重传技术使用了冗余ACK来检测丢包的发生。同样，冗余ACK也用于网络拥塞的检测（丢包了当然意味着网络可能出现了拥塞）。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。</p><p>​        当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，<strong>而不必等待那个报文段设置的重传计时器超时。</strong></p><ol><li>快恢复</li></ol><p>​        原理如下：当发送方连续收到三个冗余ACK时，直接将慢开始门限ssthresh设置为此时发送方cwnd的一半。他与慢开始不同之处是它把cwnd也设置为当前cwnd的一半，而不是将cwnd设置为1，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。相当于是跳过了拥塞窗口cwnd从1开始的慢开始过程，所以被称为快恢复。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/快重传和快恢复算法的实现过程.png" alt="快重传和快恢复算法的实现过程"></p><h2 id="2-6-流量控制和拥塞控制"><a href="#2-6-流量控制和拥塞控制" class="headerlink" title="2.6.流量控制和拥塞控制"></a>2.6.流量控制和拥塞控制</h2><p>​        拥塞控制和流量控制的区别：拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是指点对点的通信量的控制，是个端到端的问题，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>​        当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。</p><h1 id="3-HTTP"><a href="#3-HTTP" class="headerlink" title="3.HTTP"></a>3.HTTP</h1><p><img src="http://cdn.leesin.fun/typora/s3/img/HTTP请求的完整过程.png" alt="HTTP请求的完整过程"></p><h2 id="3-1-HTTP-1-1的缺陷"><a href="#3-1-HTTP-1-1的缺陷" class="headerlink" title="3.1.HTTP/1.1的缺陷"></a>3.1.HTTP/1.1的缺陷</h2><h3 id="3-1-1-高延迟-带来页面加载速度的降低"><a href="#3-1-1-高延迟-带来页面加载速度的降低" class="headerlink" title="3.1.1.高延迟 - 带来页面加载速度的降低"></a>3.1.1.高延迟 - 带来页面加载速度的降低</h3><p>网络延迟问题主要由于队头阻塞 (Head-Of-Line Blocking)产生，导致带宽无法被充分利用。</p><p>针对对头阻塞，有尝试过以下解决方案：</p><ul><li>将同一页面的资源分散到不同域名下，提升连接上限。<strong>Chrome 有个机制，对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</strong>使用持久连接时，虽然能共用一个 TCP 管道，<strong>但是在一个管道中同一时刻只能处理一个请求</strong>，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。</li><li>Spriting 合并多张小图为一张大图, 再用 JavaScript 或者 CSS 将小图重新“切割”出来的技术。</li><li>等等</li></ul><h3 id="3-1-2-无状态特性-–-带来巨大的-HTTP-头部"><a href="#3-1-2-无状态特性-–-带来巨大的-HTTP-头部" class="headerlink" title="3.1.2.无状态特性 – 带来巨大的 HTTP 头部"></a>3.1.2.无状态特性 – 带来巨大的 HTTP 头部</h3><p>Header 里携带的内容过大，在一定程度上增加了传输成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费。</p><h3 id="3-1-3-明文传输-–-带来不安全性"><a href="#3-1-3-明文传输-–-带来不安全性" class="headerlink" title="3.1.3.明文传输 – 带来不安全性"></a>3.1.3.明文传输 – 带来不安全性</h3><p>HTTP/1.1 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</p><h3 id="3-1-4-不支持服务器推送消息"><a href="#3-1-4-不支持服务器推送消息" class="headerlink" title="3.1.4.不支持服务器推送消息"></a>3.1.4.不支持服务器推送消息</h3><p>服务器只能被动地响应消息</p><h3 id="3-1-5-总结"><a href="#3-1-5-总结" class="headerlink" title="3.1.5.总结"></a>3.1.5.总结</h3><p>安全不足和性能不高</p><h2 id="3-2-SPDY协议"><a href="#3-2-SPDY协议" class="headerlink" title="3.2.SPDY协议"></a>3.2.SPDY协议</h2><p>上面我们提到, 由于 HTTP/1.x 的缺陷，我们会引入雪碧图、将小图内联、使用多个域名等方式来提高性能，不过这些优化都绕开了协议。直到 2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。谷歌推出 SPDY，才算是正式改造 HTTP 协议本身。降低延迟，压缩 header 等等，SPDY 的实践证明了这些优化的效果，也最终带来 HTTP/2 的诞生。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/SPDY协议.png" alt="SPDY协议"></p><h2 id="3-3-HTTP-2新特性"><a href="#3-3-HTTP-2新特性" class="headerlink" title="3.3.HTTP/2新特性"></a>3.3.HTTP/2新特性</h2><p><strong>HTTP/2 基于 SPDY，专注于性能，最大的目标是在用户和网站间只用一个连接（connec-tion）</strong>。使用 HTTP/2 能带来 20%~60% 的效率提升。</p><h3 id="3-3-1-二进制传输"><a href="#3-3-1-二进制传输" class="headerlink" title="3.3.1.二进制传输"></a>3.3.1.二进制传输</h3><p><strong>HTTP/2 传输数据量的大幅减少, 主要有两个原因: 以二进制方式传输和 Header 压缩</strong>。我们先来介绍二进制传输，HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</strong>。</p><p>它把 TCP 协议的部分特性挪到了应用层，把原来的”Header+Body”的消息”打散”为数个小片的二进制”帧”(Frame), 用”HEADERS”帧存放头数据、”DATA”帧存放实体数据。HTTP/2 数据分帧后，“Header+Body”的报文结构就完全消失了，协议看到的只是一个个”碎片”。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/HTTP2的帧.jpg" alt="HTTP2的帧"></p><p>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。<strong>多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装</strong>。</p><h3 id="3-3-2-Header-压缩"><a href="#3-3-2-Header-压缩" class="headerlink" title="3.3.2.Header 压缩"></a>3.3.2.Header 压缩</h3><p>HTTP/2 并没有使用传统的压缩算法，而是开发了专门的”HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用<strong>哈夫曼编码</strong>来压缩整数和字符串，可以达到 50%~90% 的高压缩率。</p><p>具体来说：</p><ul><li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键 - 值对，<strong>对于相同的数据，不再通过每次请求和响应发送。</strong></li><li>首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新 。</li><li>每个新的首部键 - 值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销 。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/HTTP2的帧和头部压缩示例.jpg" alt="HTTP2的帧和头部压缩示例"></p><h3 id="3-3-3-多路复用"><a href="#3-3-3-多路复用" class="headerlink" title="3.3.3.多路复用"></a>3.3.3.多路复用</h3><p>在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2 中：</p><ul><li>同域名下所有通信都在单个连接上完成。</li><li>单个连接可以承载任意数量的双向数据流。</li><li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li></ul><p>这一特性使性能有了极大提升：</p><ul><li>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应, 这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</li><li>并行交错地发送多个请求 / 响应，请求 / 响应之间互不影响。</li><li>在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li></ul><p><img src="http://cdn.leesin.fun/typora/s3/img/http2的多路复用.png" alt="http2的多路复用"></p><p>如上图所示，多路复用的技术只通过一个 TCP 连接就可以传输所有的请求数据。</p><h3 id="3-3-4-Server-Push"><a href="#3-3-4-Server-Push" class="headerlink" title="3.3.4.Server Push"></a>3.3.4.Server Push</h3><p>HTTP2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再完全被动地响应请求，也可以新建“流”主动向客户端发送消息。</p><h3 id="3-3-5-提高安全性"><a href="#3-3-5-提高安全性" class="headerlink" title="3.3.5.提高安全性"></a>3.3.5.提高安全性</h3><p>出于兼容的考虑，HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p><p>但由于 HTTPS 已经是大势所趋，而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，<strong>所以“事实上”的 HTTP/2 是加密的</strong>。也就是说，互联网上通常所能见到的 HTTP/2 都是使用”https”协议名，跑在 TLS 上面。HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2。</p><h2 id="3-4-HTTP-2缺陷"><a href="#3-4-HTTP-2缺陷" class="headerlink" title="3.4.HTTP/2缺陷"></a>3.4.HTTP/2缺陷</h2><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，<strong>主要是底层支撑的 TCP 协议造成的</strong>。HTTP/2 的缺点主要有以下几点：</p><ul><li><p>TCP 和 TCP+TLS 建立连接的延时</p><p>HTTP/2 是使用 TCP 协议来传输的。如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，<strong>这样就需要有两个握手延迟过程</strong>：</p><p>​    ①在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</p><p>​    ②进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1~2 个 RTT。</p><p>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。</p></li></ul><ul><li><p>TCP 的队头阻塞并没有彻底解决</p><p>上文我们提到在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反倒只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/http2队头阻塞.png" alt="http2队头阻塞"></p></li></ul><h2 id="3-5-HTTP-3新特性"><a href="#3-5-HTTP-3新特性" class="headerlink" title="3.5.HTTP/3新特性"></a>3.5.HTTP/3新特性</h2><p>Google 在推 SPDY 的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本，HTTP/3。它在 HTTP/2 的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/http123协议.jpg" alt="http123协议"></p><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 QUIC 新功能。</p><p>上面我们提到 QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以就比 TCP 来得快。此外，QUIC 也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似 HTTP/2 的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说，QUIC 协议有以下特点：</p><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。</li></ul><p>虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</p><ul><li>实现了快速握手功能。</li></ul><p>由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong>。</p><ul><li>集成了 TLS 加密功能。</li></ul><p>目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</p><ul><li>多路复用，彻底解决 TCP 中队头阻塞的问题。</li></ul><p>和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/QUIC协议的多路复用.png" alt="QUIC协议的多路复用"></p><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6.总结"></a>3.6.总结</h2><ul><li>HTTP/1.1 有两个主要的缺点：安全不足和性能不高。</li><li>HTTP/2 完全兼容 HTTP/1，是“更安全的 HTTP、更快的 HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验。</li><li>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议。该协议基于 UDP，又汲取了 TCP 中的精华，实现了既快又可靠的协议。</li></ul><p>原文：<a href="https://www.infoq.cn/article/kU4OkqR8vH123a8dLCCJ">https://www.infoq.cn/article/kU4OkqR8vH123a8dLCCJ</a></p><h1 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4.HTTPS"></a>4.HTTPS</h1><h1 id="5-加密"><a href="#5-加密" class="headerlink" title="5.加密"></a>5.加密</h1><h2 id="5-1-摘要算法"><a href="#5-1-摘要算法" class="headerlink" title="5.1.摘要算法"></a>5.1.摘要算法</h2><p>摘要算法能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。任意微小的数据差异，都可以生成完全不同的摘要。所以可以通过把明文信息的摘要和明文一起加密进行传输，数据传输到对方之后再进行解密，重新对数据进行摘要，再比对就能发现数据有没有被算改。这样就保证了数据的完整性。</p><p>比如：md5</p><h2 id="5-2-对称加密"><a href="#5-2-对称加密" class="headerlink" title="5.2.对称加密"></a>5.2.对称加密</h2><p>对称密钥加密算法：编、解码使用相同密钥的算法，如 (AES，RC4，ChaCha20 )。</p><p>以xor为举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1110101010111010原文</span><br><span class="line">0101101101010101密钥</span><br><span class="line">1011000111101111原文xor密钥-&gt;密文</span><br><span class="line"></span><br><span class="line">1011000111101111密文</span><br><span class="line">0101101101010101密钥</span><br><span class="line">1110101010111010密文xor密钥-&gt;原文</span><br></pre></td></tr></table></figure><h2 id="5-3-非对称加密"><a href="#5-3-非对称加密" class="headerlink" title="5.3.非对称加密"></a>5.3.非对称加密</h2><p>公钥可以公开给任何人使用，而私钥必须严格保密。非对称加密可以解决“密钥交换”的问题。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。非对称密钥加密系统通常需要大量的数学运算，<strong>比较慢</strong>。如 （DH、DSA、RSA、ECC ）</p><blockquote><p>使用公钥加密，只能使用私钥解密</p><p>使用私钥加密，只能使用公钥解密</p></blockquote><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>TLS 里使用的混合加密方式，即把对称加密和非对称加密结合起来呢，两者互相取长补短，即能高效地加密解密，又能安全地密钥交换。大致流程如下：</p><ol><li><p>通信开始的时候使用非对称算法如 RSA，ECDHE先解决密钥交换的问题。<br><img src="http://cdn.leesin.fun/typora/s3/img/TLS流程1.png" alt="TLS流程1"></p></li><li><p>用随机数产生对称算法使用的”会话密钥”再用公钥加密。会话密钥很短，所以即便使用非对称加密算法也可以很快完成加解密。<br><img src="http://cdn.leesin.fun/typora/s3/img/TLS流程2.png" alt="TLS流程2"></p></li><li><p>对方拿到密文后用私钥解密，取出会话密钥。完成对称密钥的安全交换，后续就使用对称算法完成数据交换。<br><img src="http://cdn.leesin.fun/typora/s3/img/TLS流程3.png" alt="TLS流程3"></p></li></ol><p><img src="http://cdn.leesin.fun/typora/s3/img/https加解密完整过程.png" alt="https加解密完整过程"></p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><h5 id="数字证书组成"><a href="#数字证书组成" class="headerlink" title="数字证书组成"></a>数字证书组成</h5><p>CA信息，公钥用户信息，公钥，权威机构的签名，有效期</p><h5 id="数字证书作用"><a href="#数字证书作用" class="headerlink" title="数字证书作用"></a>数字证书作用</h5><ol><li>通过数字证书向浏览器证明身份</li><li>数字证书里面包含了公钥</li></ol><h5 id="数字证书的申请和验证"><a href="#数字证书的申请和验证" class="headerlink" title="数字证书的申请和验证"></a>数字证书的申请和验证</h5><p>如何申请：<br>1.生成自己的公钥和私钥，服务器自己保留私钥</p><p>2.向CA机构提交公钥，公司，域名信息等待认证</p><p>3.CA机构通过线上，线下多种途径验证你提交信息的真实性，合法性</p><p>4.信息审核通过，CA机构则会向你签发认证的数字证书，包含了公钥，组织信息，CA信息，有效时间，证书序列号，同时生成一个签名</p><p>签名步骤：hash（你用于申请证书所提交的明文信息）=信息摘要；CA再使用私</p><p>钥对信息摘要进行加密，密文就是证书的数字签名</p><p>浏览器如何验证呢?</p><p>有了CA签名过的数字证书，当浏览器访问服务器时，服务器会返回数字证书给浏览器。浏览器收到证书后会对数字证书进行验证。</p><p>首先浏览器读取证书中相关的明文信息，采用CA签名时相同的hash函数计算得到信息摘要A，再利用对应的CA公钥解密数字签名数据得到信息摘要B，如果摘要A和摘要B一致，则可以确认证书时合法的</p><h1 id="6-IO模型"><a href="#6-IO模型" class="headerlink" title="6.IO模型"></a>6.IO模型</h1><p><img src="http://cdn.leesin.fun/typora/s3/img/IO模型.png" alt="IO模型"></p><p>不同IO模型的差别就是在 ==1. 2. 两个阶段== 的处理方式的差别。</p><blockquote><p>在神作《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO （Blocking IO）</li><li>非阻塞IO (Nonblocking IO)</li><li>IO多路复用 （IO Multiplexing）</li><li>信号驱动IO （Signal Driver IO）</li><li>异步IO （Asynchronous IO）</li></ul></blockquote><h2 id="6-1-阻塞IO———BIO"><a href="#6-1-阻塞IO———BIO" class="headerlink" title="6.1.阻塞IO———BIO"></a>6.1.阻塞IO———BIO</h2><p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/阻塞IO.png" alt="阻塞IO"></p><p>在 IO 阻塞逻辑中，存在下面三个问题：</p><ol><li>进程在 recv 的时候大概率会被阻塞掉，导致一次进程切换；</li><li>当 TCP 连接上的数据到达服务端的网卡、并从网卡复制到内核空间 socket 的数据等待队列时，进程会被唤醒，又是一次进程切换；并且，在用户进程继续执行完 recvfrom() 函数系统调用，将内核空间的数据拷贝到了用户缓冲区后，用户进程才会真正拿到所需的数据进行处理；</li><li>一个进程同时只能等待一条连接，如果有很多并发，则需要很多进程；</li></ol><p>总结：一次数据到达会进行<strong>两次进程切换，</strong>一次数据读取有<strong>两处阻塞，单进程对单连接</strong>。</p><h2 id="6-2-非阻塞IO———-NIO"><a href="#6-2-非阻塞IO———-NIO" class="headerlink" title="6.2.非阻塞IO———-NIO"></a>6.2.非阻塞IO———-NIO</h2><p>非阻塞IO的 recvfrom 操作会立即返回结果而不是阻塞用户进程。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/非阻塞IO.png" alt="非阻塞IO"></p><p>可以看到，非阻塞 IO，是将等待数据从网卡到达 socket 内核空间这一部分变成了非阻塞的，第二个阶段仍是阻塞状态。虽然第一阶段是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p><p>非阻塞 IO 模型解决了“<strong>两次进程切换，两处阻塞，单进程对单连接</strong>”中的“<strong>两处阻塞</strong>”问题，将“<strong>两处阻塞</strong>”变成了“<strong>一处阻塞</strong>”，但依然存在“<strong>两次进程切换，一处阻塞，单进程对单连接</strong>”的问题。</p><h2 id="6-3-IO多路复用"><a href="#6-3-IO多路复用" class="headerlink" title="6.3.IO多路复用"></a>6.3.IO多路复用</h2><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p><ul><li>如果调用recvfrom时，恰好<strong>没有</strong>数据，阻塞IO会使进程阻塞，非阻塞IO使CPU空转，两者都不能充分发挥CPU的作用。</li><li>如果调用recvfrom时，恰好<strong>有</strong>数据，则用户进程可以直接进入第二阶段，读取并处理数据。</li></ul><p>比如服务端处理客户端Socket请求时，在单线程情况下，只能依次处理每一个socket，如果正在处理的socket恰好未就绪(数据不可读或不可写)，线程就会被阻塞，所有其它客户端socket都必须等待，性能自然会很差。</p><p>这就像服务员给顾客点餐，分两步:</p><p>①顾客思考要吃什么（等待数据就绪）</p><p>②顾客想好了，开始点餐（读取数据）</p><p><img src="http://cdn.leesin.fun/typora/s3/img/点餐例子.png" alt="点餐例子"></p><p>要提高效率有几种方法？</p><ul><li>方案一：增加更多服务员（多线程）     ——开销大</li><li>方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用于应用就去读取数据）</li></ul><p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？</p><blockquote><p>文件描述符(File Descriptor)：简称FD，是一个从0 开始递增的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字 (Socket)。</p></blockquote><p>有了文件描述符，用一个线程来监听多个客户端socket的方式就可以实现了。</p><p>IO多路复用：是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p><p>IO多路复用的基本思想：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/IO多路复用.png" alt="IO多路复用"></p><p>监听FD的方式、通知的方式又有多种落地实现，Linux常见的有：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p>差异：</p><ul><li><p>select和poll只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程逐个遍历FD来确认</p></li><li><p>epoll则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间</p></li></ul><h3 id="6-3-1-select"><a href="#6-3-1-select" class="headerlink" title="6.3.1.select"></a>6.3.1.select</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/select代码.png" alt="select代码"></p><p>下面演示一下流程：（可看<a href="https://www.bilibili.com/video/BV1cr4y1671t?t=221.8&amp;p=164）">https://www.bilibili.com/video/BV1cr4y1671t?t=221.8&amp;p=164）</a></p><p><img src="http://cdn.leesin.fun/typora/s3/img/select演示1.png" alt="select演示1"></p><p>如果此时，fd=1数据就绪了，修改位图，将就绪的fd保留值为1，未就绪的fd置0</p><p><img src="http://cdn.leesin.fun/typora/s3/img/select演示2.png" alt="select演示2"></p><p>然后，将就绪数作为select函数的返回值返回给调用者，告诉他有几个fd就绪了。并且将fd_set的结果拷贝回用户空间，覆盖掉原来的fd_set。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/select演示3.png" alt="select演示3"></p><p>此时，调用者已经知道就绪的fd有1个，但是并不知道是哪个fd就绪了，所以要对fd_set再进行一次遍历。</p><p><img src="http://cdn.leesin.fun/typora/s3/img/select演示4.png" alt="select演示4"></p><p>找到就绪fd之后执行相应逻辑操作，此轮算是结束了。然后第二轮操作从1.2.开始，再进行循环。</p><p>select模式存在的问题：</p><ul><li>需要将整个 fd_set 从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li><li>fd_set监听的fd数量不能超过1024（看结构体的定义得知）</li></ul><h3 id="6-3-2-poll"><a href="#6-3-2-poll" class="headerlink" title="6.3.2.poll"></a>6.3.2.poll</h3><p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p><p><img src="http://cdn.leesin.fun/typora/s3/img/poll代码.png" alt="poll代码"></p><p>IO流程：</p><p>① 创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</p><p>② 调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</p><p>③ 内核遍历fd，判断是否就绪</p><p>④ 数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</p><p>⑤ 用户进程判断n是否大于0</p><p>⑥ 大于0则遍历pollfd数组，找到就绪的fd</p><p>poll模式存在的问题：</p><ul><li>需要将整个 pollfd 从用户空间拷贝到内核空间，poll结束还要再次拷贝回用户空间</li><li>poll无法得知具体是哪个fd就绪，需要遍历整个 pollfd</li></ul><p>与select对比：</p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><h3 id="6-3-3-epoll"><a href="#6-3-3-epoll" class="headerlink" title="6.3.3.epoll"></a>6.3.3.epoll</h3><p><img src="http://cdn.leesin.fun/typora/s3/img/epoll代码.png" alt="epoll代码"></p><p>epoll模式中如何解决这些问题的?</p><ul><li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li><li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li><li>内核会将就绪的FD直接拷贝到用户空间的指定位置，用户进程无需遍历所有FD就能知道就绪的FD是谁</li></ul><h5 id="epoll的事件通知机制"><a href="#epoll的事件通知机制" class="headerlink" title="epoll的事件通知机制"></a>epoll的事件通知机制</h5><p>当FD有数据可读时，我们调用epoll_wait就可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT。当FD还有数据可读时，会重复通知多次，直至数据处理完成。是Epoll的默认模式</li><li>EdgeTriggered：简称ET。当FD有数据可读时，只会被通知一次，不管数据是否处理完成</li></ul><h5 id="web服务流程"><a href="#web服务流程" class="headerlink" title="web服务流程"></a>web服务流程</h5><p><img src="http://cdn.leesin.fun/typora/s3/img/基于epoll模式的web服务的基本流程.png" alt="基于epoll模式的web服务的基本流程"></p><h2 id="6-4-信号驱动IO"><a href="#6-4-信号驱动IO" class="headerlink" title="6.4.信号驱动IO"></a>6.4.信号驱动IO</h2><p>待学习</p><h2 id="6-5-异步IO"><a href="#6-5-异步IO" class="headerlink" title="6.5.异步IO"></a>6.5.异步IO</h2><p>待学习</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>感谢访问！</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>photo</title>
      <link href="/photo/index.html"/>
      <url>/photo/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="http://cdn.leesin.fun/hexo/photo/wallpaper/12.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁纸</div>  <p>收藏的一些壁纸</p>  <a href="/photo/wallpaper"></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src="http://cdn.leesin.fun/hexo/photo/wallpaper/14.jpg" alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">游戏</div>  <p>一些游戏战绩</p>  <a href="/photo/game"></a>  </figcaption>  </figure>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-hALHjZsY" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="8261498022" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="400px" data-preload="none" data-theme="#ad7a86"></div>    <div id="aplayer-kADPKvOm" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="6631116215" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="false" data-listmaxheight="400px" data-preload="none" data-theme="#ad7a86"></div>    <div id="aplayer-uJUgbsAI" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="5379001646" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="false" data-listmaxheight="400px" data-preload="none" data-theme="#ad7a86"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>wallpaper</title>
      <link href="/photo/wallpaper/index.html"/>
      <url>/photo/wallpaper/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery">    <div class="fj-gallery  data" data-rowheight="220" data-limit="10">    <span class="gallery-data">[{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/1.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/2.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/3.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/4.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/5.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/6.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/7.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/8.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/9.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/10.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/11.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/12.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/13.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/14.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/15.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/16.jpg","alt":""},{"url":"http://cdn.leesin.fun/hexo/photo/wallpaper/17.jpg","alt":""}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div>]]></content>
      
    </entry>
    
    
  
</search>
