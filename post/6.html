<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>dp | leesin</title><meta name="author" content="leesin"><meta name="copyright" content="leesin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="入门70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？  示例1：输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。  1 阶 + 1 阶 2 阶   1234567891011121314151617181920212223242526class Solution &amp;#123;    public int cl">
<meta property="og:type" content="article">
<meta property="og:title" content="dp">
<meta property="og:url" content="https://leesin9527.github.io/post/6.html">
<meta property="og:site_name" content="leesin">
<meta property="og:description" content="入门70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？  示例1：输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。  1 阶 + 1 阶 2 阶   1234567891011121314151617181920212223242526class Solution &amp;#123;    public int cl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://cdn.leesin.fun/hexo/article/6.jpg">
<meta property="article:published_time" content="2022-10-30T01:05:50.000Z">
<meta property="article:modified_time" content="2023-03-27T07:29:41.553Z">
<meta property="article:author" content="leesin">
<meta property="article:tag" content="dp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cdn.leesin.fun/hexo/article/6.jpg"><link rel="shortcut icon" href="https://cdn.leesin.fun/hexo/favicon.png"><link rel="canonical" href="https://leesin9527.github.io/post/6.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'dp',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-27 15:29:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/myStyle.css"><link rel="stylesheet" href="/css/frontSetting.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/universe.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.leesin.fun/hexo/avatar.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-video"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://cdn.leesin.fun/hexo/article/6.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="leesin"><span class="site-name">leesin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-video"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">dp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-30T01:05:50.000Z" title="发表于 2022-10-30 09:05:50">2022-10-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-27T07:29:41.553Z" title="更新于 2023-03-27 15:29:41">2023-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="dp"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<blockquote>
<p>示例1：<br>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：爬到i层有dp[i]种方法。</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i] =  dp[i-1] + dp[i-2]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0] = 1 dp[1] = 1 dp[2] = 2</span></span><br><span class="line"><span class="comment">    4.计算顺序：从前往后</span></span><br><span class="line"><span class="comment">    5.举例：n=5</span></span><br><span class="line"><span class="comment">      dp[i]</span></span><br><span class="line"><span class="comment">    1   1</span></span><br><span class="line"><span class="comment">    2   2</span></span><br><span class="line"><span class="comment">    3   3</span></span><br><span class="line"><span class="comment">    4   5</span></span><br><span class="line"><span class="comment">    5   8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h4><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<blockquote>
<p>示例1：</p>
<p>输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为 1 的台阶开始。</p>
<ul>
<li>支付 15 ，向上爬两个台阶，到达楼梯顶部。 </li>
</ul>
<p>总花费为 15 。</p>
<p>示例2：</p>
<p>输入：cost = [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为 0 的台阶开始。</p>
<ul>
<li>支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</li>
<li>支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</li>
<li>支付 1 ，向上爬一个台阶，到达楼梯顶部。<br>总花费为 6 。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i-<span class="number">1</span>] + cost[i-<span class="number">1</span>], dp[i-<span class="number">2</span>] + cost[i-<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：爬到第i层，最小花费是dp[i]</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0] = dp[1] = 0 表示不需要花费就能到达第0/1层</span></span><br><span class="line"><span class="comment">    4.计算顺序：从前往后</span></span><br><span class="line"><span class="comment">    5.举例：cost = [1,100,1,1,1,100,1,1,100,1]</span></span><br><span class="line"><span class="comment">                    dp[i]</span></span><br><span class="line"><span class="comment">    cost[0]=1         0</span></span><br><span class="line"><span class="comment">    cost[1]=100       0</span></span><br><span class="line"><span class="comment">    cost[2]=1         1</span></span><br><span class="line"><span class="comment">    cost[3]=1         2 </span></span><br><span class="line"><span class="comment">    cost[4]=1         2</span></span><br><span class="line"><span class="comment">    cost[5]=100       3</span></span><br><span class="line"><span class="comment">    cost[6]=1         3</span></span><br><span class="line"><span class="comment">    cost[7]=1         4</span></span><br><span class="line"><span class="comment">    cost[8]=100       4</span></span><br><span class="line"><span class="comment">    cost[9]=1         5</span></span><br><span class="line"><span class="comment">    n = 10            6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：到达坐标为(i,j)有dp[i][j]条不同路径</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][i] = dp[i][0] = 1</span></span><br><span class="line"><span class="comment">    4.计算顺序：内外层都顺序</span></span><br><span class="line"><span class="comment">    5.举例：m = 3, n = 7</span></span><br><span class="line"><span class="comment">        1  2  3  4  5  6  7</span></span><br><span class="line"><span class="comment">    1   1  1  1  1  1  1  1</span></span><br><span class="line"><span class="comment">    2   1  2  3  4  5  6  7 </span></span><br><span class="line"><span class="comment">    3   1  3  6  10 15 21 28</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid.length, m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：到达坐标为(i,j)有dp[i][j]条不同路径</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">        如果(i,j)不是障碍：dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="comment">        如果(i,j)是障碍： dp[i][j] = 0</span></span><br><span class="line"><span class="comment">    3.初始化：</span></span><br><span class="line"><span class="comment">        第一行：障碍左边的初始化为1，障碍右边的初始化为0</span></span><br><span class="line"><span class="comment">        第一列：障碍上边的初始化为1，障碍下边的初始化为0</span></span><br><span class="line"><span class="comment">    4.计算顺序：内外层都顺序</span></span><br><span class="line"><span class="comment">    5.举例：</span></span><br><span class="line"><span class="comment">    [0,0,0]</span></span><br><span class="line"><span class="comment">    [0,1,0]</span></span><br><span class="line"><span class="comment">    [0,0,0]</span></span><br><span class="line"><span class="comment">        1  2  3</span></span><br><span class="line"><span class="comment">    1   1  1  1</span></span><br><span class="line"><span class="comment">    2   1  0  1</span></span><br><span class="line"><span class="comment">    3   1  1  2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h4><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<blockquote>
<p>示例1：<br>输入: n = 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。</p>
<p>示例2：</p>
<p>输入: n = 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 完全背包问题</span><br><span class="line"></span><br><span class="line">#### <span class="number">518.</span>零钱兑换II</span><br><span class="line"></span><br><span class="line">[题目链接](https:<span class="comment">//leetcode-cn.com/problems/coin-change-2/)</span></span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j-coins[i]];</span><br><span class="line">                <span class="comment">// System.out.print(dp[j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.dp[j]含义：容量为j的背包，装满此背包的方式有dp[j]种</span></span><br><span class="line"><span class="comment">    2.递推式：dp[j] = dp[j] + dp[j-weight[i]]</span></span><br><span class="line"><span class="comment">    		dp[j]是不选物品j  dp[j-weight[i]]选物品j</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0]=1，表示装满容量0的背包，有一种方式，那就是什么也不装</span></span><br><span class="line"><span class="comment">    4.顺序：完全背包的组合问题，外层先遍历物品，内层遍历背包，内层循环从小到大，因为物品是可以添加多次的</span></span><br><span class="line"><span class="comment">    5.举例：amount=5，coins=[1,2,5]</span></span><br><span class="line"><span class="comment">    i  j 0 1 2 3 4 5</span></span><br><span class="line"><span class="comment">    0    1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">    1    1 1 2 2 3 3</span></span><br><span class="line"><span class="comment">    2    1 1 2 2 3 4</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    对于以上举例，程序运行的输出如下：</span></span><br><span class="line"><span class="comment">    1 1 1 1 1 </span></span><br><span class="line"><span class="comment">      2 2 3 3 </span></span><br><span class="line"><span class="comment">            4 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong></p>
<ul>
<li><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p>
</li>
<li><p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p>
<p>（本问题属于组合数问题）</p>
</li>
</ul>
</blockquote>
<h4 id="377-组合总和IV⭐⭐⭐"><a href="#377-组合总和IV⭐⭐⭐" class="headerlink" title="377.组合总和IV⭐⭐⭐"></a>377.组合总和IV⭐⭐⭐</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iv/">题目链接</a></p>
<blockquote>
<p>此题目名为组合，实则是排列问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j - nums[i]];</span><br><span class="line">                    <span class="comment">// System.out.print(dp[j] + &quot; &quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.dp[j]：表示凑成容量为j的背包的排列个数为dp[j]</span></span><br><span class="line"><span class="comment">    2.递推式：dp[j] = dp[j] + dp[j-nums[i]]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0] = 1</span></span><br><span class="line"><span class="comment">    4.遍历顺序：完全背包排列问题，外层先遍历背包，内层遍历物品，内层从小到大</span></span><br><span class="line"><span class="comment">    5.举例：nums = [1,2,3], target = 4</span></span><br><span class="line"><span class="comment">        j 0 1 2 3 4</span></span><br><span class="line"><span class="comment">    i</span></span><br><span class="line"><span class="comment">    0     1 1 1 2 4</span></span><br><span class="line"><span class="comment">    1         2 3 6 </span></span><br><span class="line"><span class="comment">    2           4 7</span></span><br><span class="line"><span class="comment">    对于以上举例，程序运行的输出如下：</span></span><br><span class="line"><span class="comment">    1 </span></span><br><span class="line"><span class="comment">    1 2 </span></span><br><span class="line"><span class="comment">    2 3 4 </span></span><br><span class="line"><span class="comment">    4 6 7 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果把题目改成组合问题，外层先遍历物品，内层遍历背包，举例如下：</span></span><br><span class="line"><span class="comment">        j 0 1 2 3 4</span></span><br><span class="line"><span class="comment">    i</span></span><br><span class="line"><span class="comment">    0     1 1 1 1 1</span></span><br><span class="line"><span class="comment">    1         2 2 3 </span></span><br><span class="line"><span class="comment">    2           3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.leef.fun/typora/s3/img/完全背包之排列-组合总和4.jpg" alt="完全背包之排列-组合总和4"></p>
<p><img src="http://cdn.leef.fun/typora/s3/img/完全背包之组合-组合总和4.jpg" alt="完全背包之组合-组合总和4"></p>
<blockquote>
<p>如果本题要把排列都列出来的话，只能使⽤回溯算法爆搜。</p>
</blockquote>
<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">题目链接</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j-coins[i]] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j-coins[i]] + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// System.out.print(dp[j] + &quot; &quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. dp[j]：装满容量为j的背包的最小硬币数为dp[j]</span></span><br><span class="line"><span class="comment">    2. 递推式：dp[j] = min(dp[j],dp[j-coins[i]+1])</span></span><br><span class="line"><span class="comment">    3. 初始化：dp[0] = 0 表示装满容量为0的背包的最小硬币数是0个硬币， 其他初始化为正无穷</span></span><br><span class="line"><span class="comment">    4. 遍历顺序：外层先遍历背包；内层遍历物品，从小到大</span></span><br><span class="line"><span class="comment">    5. 举例：coins = [1, 2, 5], amount = 11</span></span><br><span class="line"><span class="comment">            0 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">coins[0]=1  0 1 2 2 3 3 2 3 3 4 4  3 </span></span><br><span class="line"><span class="comment">coins[1]=2      1 2 2 3 2 2 3 3 4  3</span></span><br><span class="line"><span class="comment">coins[2]=5            1 2 2 3 3 2  3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">标准输出为：</span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">2 1 </span></span><br><span class="line"><span class="comment">2 2 </span></span><br><span class="line"><span class="comment">3 2 </span></span><br><span class="line"><span class="comment">3 3 1 </span></span><br><span class="line"><span class="comment">2 2 2 </span></span><br><span class="line"><span class="comment">3 2 2 </span></span><br><span class="line"><span class="comment">3 3 3 </span></span><br><span class="line"><span class="comment">4 3 3 </span></span><br><span class="line"><span class="comment">4 4 2 </span></span><br><span class="line"><span class="comment">3 3 3 </span></span><br><span class="line"><span class="comment">和预测的一模一样！！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举例2：coins = [2], amount = 3</span></span><br><span class="line"><span class="comment">            0 1         2   3 </span></span><br><span class="line"><span class="comment">coins[0]=2  0 maxvalue  1   maxvalue</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong></p>
<p><strong>518.零钱兑换II</strong> 中求的是组合数，<strong>377. 组合总和 Ⅳ</strong> 中求的是排列数。 </p>
<p>⽽本题是要求最少硬币数量，硬币是组合数还是排列数都⽆所谓！所以两个for循环先后顺序怎样都可以！</p>
</blockquote>
<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i * i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j - i * i] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// System.out.print(dp[j] + &quot; &quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">values[] = &#123;1², 2², 3², ... , x²&#125; x为n的开平方</span></span><br><span class="line"><span class="comment">背包总重量为n</span></span><br><span class="line"><span class="comment">本题和322.零钱兑换一致，五部曲就不再赘述了，只做出举例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举例：n = 13</span></span><br><span class="line"><span class="comment">        0 1 2 3 4 5 6 7 8 9 10 11 12 13</span></span><br><span class="line"><span class="comment">1²=1    0 1 2 3 4 5 6 7 8 9 10 11 12 13</span></span><br><span class="line"><span class="comment">2²=4    0 1 2 3 1 2 3 4 2 3 4  5  3  4</span></span><br><span class="line"><span class="comment">3²=9    0 1 2 3 1 2 3 4 2 1 2  3  3  2</span></span><br><span class="line"><span class="comment">程序输出为：</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7 8 9 10 11 12 13 </span></span><br><span class="line"><span class="comment">      1 2 3 4 2 3 4  5  3  4 </span></span><br><span class="line"><span class="comment">                1 2  3  3  2 </span></span><br><span class="line"><span class="comment">与预测的一致</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line"></span><br><span class="line"># 其他</span><br><span class="line"></span><br><span class="line">## 股票问题</span><br><span class="line"></span><br><span class="line">#### <span class="number">121.</span>买卖股票的最佳时机</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> -prices[<span class="number">0</span>], dp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dpi0</span> <span class="operator">=</span> Math.max(dp0, -prices[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> Math.max(dp1, prices[i] + dp0);</span><br><span class="line">            dp0 = dpi0;</span><br><span class="line">            dp1 = dpi1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1. dp[i][0]：持有股票之后的最大资产</span></span><br><span class="line"><span class="comment">       dp[i][1]: 不持有股票（卖掉股票）之后的最大资产</span></span><br><span class="line"><span class="comment">    2. 递推式：dp[i][0] = max(dp[i-1][0], -price[i])</span></span><br><span class="line"><span class="comment">              dp[i][1] = max(dp[i-1][1], price[i] + dp[i-1][0])</span></span><br><span class="line"><span class="comment">       注：假设这个人的初始资产为0，那么它入股第i个股票后，他持有股票之后的资产就是-price[i]</span></span><br><span class="line"><span class="comment">        在第一个递推式中：要么是保持前一天买的股票，要么是今天买入股票，取决于谁的绝对值最小，也就是谁的股票便宜</span></span><br><span class="line"><span class="comment">        在第二个递推式中：要么是前一天的结果，要么是今天卖出股票的利润，取决于谁的大，也就是谁的利润多</span></span><br><span class="line"><span class="comment">    3. 初始化：dp[i][0] = -prices[0] </span></span><br><span class="line"><span class="comment">              dp[i][1] = 0</span></span><br><span class="line"><span class="comment">    4. 计算顺序： 从前往后</span></span><br><span class="line"><span class="comment">    5. 举例：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">        dp[i][0]    dp[i][1]</span></span><br><span class="line"><span class="comment">    7   -7          0</span></span><br><span class="line"><span class="comment">    1   -1          0</span></span><br><span class="line"><span class="comment">    5   -1          4</span></span><br><span class="line"><span class="comment">    3   -1          4</span></span><br><span class="line"><span class="comment">    6   -1          5</span></span><br><span class="line"><span class="comment">    4   -1          5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> -prices[<span class="number">0</span>], dp1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(dp0 + &quot; &quot; + dp1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dpi0</span> <span class="operator">=</span> Math.max(dp0, dp1-prices[i]);</span><br><span class="line">            <span class="comment">// dp0是保持原有的股票，dp1-prices[i]是昨天卖掉股票，今天新买入股票</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">dpi1</span> <span class="operator">=</span> Math.max(dp1, prices[i] + dp0);</span><br><span class="line">            <span class="comment">// dp1是昨天不持股票的最大资产，prices[i]+dp0是今天卖出股票后的资产。</span></span><br><span class="line">            dp0 = dpi0;</span><br><span class="line">            dp1 = dpi1;</span><br><span class="line">            <span class="comment">//System.out.println(dp0 + &quot; &quot; + dp1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    5. 举例：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment">        dp[i][0]    dp[i][1]</span></span><br><span class="line"><span class="comment">    7   -7          0</span></span><br><span class="line"><span class="comment">    1   -1          0</span></span><br><span class="line"><span class="comment">    5   -1          4</span></span><br><span class="line"><span class="comment">    3   1           4</span></span><br><span class="line"><span class="comment">    6   1           7</span></span><br><span class="line"><span class="comment">    4   3           7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h4><blockquote>
<p>给定两个字符串 text1 和 text2，返回它们的最长公共子序列的长度。如果不存在公共子序列 ，返回 0。</p>
<p>（PS:这里的子序列<strong>不要求连续</strong>。）</p>
<p>示例1：</p>
<blockquote>
<p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length(), n2 = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：dp[i][j]表示text1[0...i-1]和text2[0...j-1]的最长公共子序列为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">        if text1[i]==text2[j] then dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment">        else then dp[i][j] = max(dp[i][j-1], dp[i-1][j])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = 0, dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层text1，内层text2。反之亦行</span></span><br><span class="line"><span class="comment">    5.举例：text1 = &quot;abcde&quot; text2 = &quot;ace&quot;</span></span><br><span class="line"><span class="comment">    dp[i][j]  0 a c e</span></span><br><span class="line"><span class="comment">        0     0 0 0 0</span></span><br><span class="line"><span class="comment">        a     0 1 1 1</span></span><br><span class="line"><span class="comment">       	b     0 1 1 1</span></span><br><span class="line"><span class="comment">        c     0 1 2 2</span></span><br><span class="line"><span class="comment">        d	  0 1 2 2</span></span><br><span class="line"><span class="comment">        e	  0 1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h4><blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>（PS:这里的子序列<strong>不要求连续</strong>。）</p>
<p>示例1：</p>
<blockquote>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">            <span class="comment">// System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：以nums[i]为结尾的最长严格递增子序列长度为dp[i]</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i] = max(dp[j] + 1) 其中0&lt;=j&lt;i且nums[i] &gt; nums[j]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0...i-1] = 1</span></span><br><span class="line"><span class="comment">    4.计算顺序：顺序，从小到大</span></span><br><span class="line"><span class="comment">    5.举例：nums = [10,9,2,5,3,7,101,18]</span></span><br><span class="line"><span class="comment">    nums[i]:    10 9 2 5 3 7 101 18</span></span><br><span class="line"><span class="comment">    dp[i]:      1  1 1 2 2 3 4   4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718.最长重复子数组"></a>718.最长重复子数组</h4><blockquote>
<p>给两个整数数组 nums1和 nums2 ，返回两个数组中公共的 、长度最长的子数组的长度。</p>
<p>（PS:子数组是<strong>要求连续</strong>的）</p>
<p>示例1：</p>
<blockquote>
<p>输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br>输出：3<br>解释：长度最长的公共子数组是 [3,2,1] 。</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> nums1.length, n2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = Math.max(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：以下标i-1为结尾的nums1和以下标j-1为结尾的nums2，最长重复子数组长度为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.dp[i][j] = dp[i-1][j-1] + 1 , if nums[i-1]==nums[j-1]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层nums1，内层nums2，反之亦行。</span></span><br><span class="line"><span class="comment">    5.举例：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span></span><br><span class="line"><span class="comment">        0 3 2 1 4 7</span></span><br><span class="line"><span class="comment">    0   0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    1   0 0 0 1 0 0</span></span><br><span class="line"><span class="comment">    2   0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">    3   0 1 0 0 0 0</span></span><br><span class="line"><span class="comment">    2   0 0 2 0 0 0</span></span><br><span class="line"><span class="comment">    1   0 0 0 3 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h4><blockquote>
<p>给定一个未经排序的整数数组，找到最长且<strong>连续</strong>递增的子序列，并返回该序列的长度。</p>
<p>（PS：<strong>要求连续</strong>）</p>
<p>示例1：</p>
<blockquote>
<p>输入：nums = [1,3,5,4,7]</p>
<p>输出：3</p>
<p>解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</p>
</blockquote>
</blockquote>
<h5 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1. dp[i]表示以nums[i]为结尾的最大连续递增子序列的长度</span></span><br><span class="line"><span class="comment">    2. 递推式：dp[i] = dp[i-1] + 1 （如果nums[i] &gt; nums[i-1]）</span></span><br><span class="line"><span class="comment">    3. 初始化：dp[0...n] = 1</span></span><br><span class="line"><span class="comment">    4. 计算顺序：从前往后</span></span><br><span class="line"><span class="comment">    5. 举例：nums = [1,3,5,4,7]</span></span><br><span class="line"><span class="comment">        nums[i] 1 3 5 4 7</span></span><br><span class="line"><span class="comment">        dp[i]   1 2 3 1 2  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DP算法</span></span><br><span class="line"><span class="comment">    时间复杂度O(n)</span></span><br><span class="line"><span class="comment">    空间复杂度O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                curLen++;</span><br><span class="line">                res = Math.max(res, curLen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curLen = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    贪心算法</span></span><br><span class="line"><span class="comment">    时间复杂度O(n)</span></span><br><span class="line"><span class="comment">    空间复杂度O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h4><blockquote>
<p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：</p>
<blockquote>
<p> nums1[i] == nums2[j]<br>且绘制的直线不与任何其他连线（非水平线）相交。</p>
</blockquote>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p>示例1：</p>
<blockquote>
<p>输入：nums1 = [1,4,2], nums2 = [1,2,4]<br>输出：2<br>解释：可以画出两条不交叉的线，如上图所示。<br>但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</p>
</blockquote>
</blockquote>
<p><img src="http://cdn.leef.fun/typora/s3/img/142.png" alt="1035示例一的图片" style="zoom: 25%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> nums1.length, n2 = nums2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：长度为i-1的nums1和长度为j-1的nums2的不相交线数为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：if nums[i-1]==nums[j-1]</span></span><br><span class="line"><span class="comment">                    dp[i][j] = dp[i-1][j-1] + 1 </span></span><br><span class="line"><span class="comment">             else</span></span><br><span class="line"><span class="comment">                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层nums1，内层nums2，反之亦行。</span></span><br><span class="line"><span class="comment">    5.举例：nums1 = [1,4,2], nums2 = [1,2,4]</span></span><br><span class="line"><span class="comment">            nums2   1 2 4</span></span><br><span class="line"><span class="comment">    nums1     0     0 0 0      </span></span><br><span class="line"><span class="comment">      1       0     1 1 1    </span></span><br><span class="line"><span class="comment">      4       0     1 1 2</span></span><br><span class="line"><span class="comment">      2       0     1 2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这道题代码和 <strong>1143.最长公共子序列 </strong>一模一样。</p>
</blockquote>
<h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h4><blockquote>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个连续部分。</p>
<p>示例1：</p>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
</blockquote>
<h5 id="DP解法-1"><a href="#DP解法-1" class="headerlink" title="DP解法"></a>DP解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(nums[i], dp[i-<span class="number">1</span>] + nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">            <span class="comment">// System.out.print(dp[i] + &quot; &quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：以下标i为结尾的最大子数组和为dp[i]</span></span><br><span class="line"><span class="comment">    2.递推式：dp[i] = max(nums[i], dp[i-1] + nums[i])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0] = nums[0]</span></span><br><span class="line"><span class="comment">    4.计算顺序：从小到大</span></span><br><span class="line"><span class="comment">    5.举例：nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span><br><span class="line"><span class="comment">        -2 1 -3 4 -1 2 1 -5 4</span></span><br><span class="line"><span class="comment">        -2 1 -2 4  3 5 6  1 5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="分治解法"><a href="#分治解法" class="headerlink" title="分治解法"></a>分治解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getMaxSubArray(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxSubArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l]; <span class="comment">// 退出条件：数组长度为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l_sum</span> <span class="operator">=</span> getMaxSubArray(nums, l, mid); <span class="comment">// 子问题nums[l...mid]的最大子数组和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r_sum</span> <span class="operator">=</span> getMaxSubArray(nums, mid + <span class="number">1</span>, r); <span class="comment">// 子问题nums[mid+1...r]的最大子数组和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m_sum</span> <span class="operator">=</span> merge(nums, l, mid, r); <span class="comment">// 两个子问题合并后可能的最大子数组和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求l_sum l_sum m_sum 三者中的最大值，即为将两个子问题合并后的答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(l_sum, r_sum);</span><br><span class="line">        res = Math.max(res, m_sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并nums[l...mid]和nums[mid+1...r]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left_sum</span> <span class="operator">=</span> <span class="number">0</span>, left_res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid; i &gt;= l; i--) &#123;</span><br><span class="line">            left_sum += nums[i];</span><br><span class="line">            left_res = Math.max(left_res, left_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right_sum</span> <span class="operator">=</span> <span class="number">0</span>, right_res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            right_sum += nums[i];</span><br><span class="line">            right_res = Math.max(right_res, right_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left_res + right_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编辑距离类问题"><a href="#编辑距离类问题" class="headerlink" title="编辑距离类问题"></a>编辑距离类问题</h2><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h4><blockquote>
<p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>示例1：</p>
<blockquote>
<p>输入：s = “abc”, t = “ahbgdc”</p>
<p>输出：true</p>
</blockquote>
</blockquote>
<h5 id="双指针解法"><a href="#双指针解法" class="headerlink" title="双指针解法"></a>双指针解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (j &lt; t.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(j++) == cur) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    最差时间复杂度：O(n+m) 其中n = s.length, m = t.length</span></span><br><span class="line"><span class="comment">    空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="DP解法-2"><a href="#DP解法-2" class="headerlink" title="DP解法"></a>DP解法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m] == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：s[0...i-1]和t[0...j-1]的最长公共子序列长度为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：if s[i-1] == s[j-1]</span></span><br><span class="line"><span class="comment">                dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment">             else</span></span><br><span class="line"><span class="comment">                dp[i][j] = dp[i][j-1]</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层s，内层t</span></span><br><span class="line"><span class="comment">    5.举例：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span></span><br><span class="line"><span class="comment">        0 a h b g d c</span></span><br><span class="line"><span class="comment">    0   0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    a   0 1 1 1 1 1 1</span></span><br><span class="line"><span class="comment">    b   0 0 0 2 2 2 2</span></span><br><span class="line"><span class="comment">    c   0 0 0 0 0 0 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    6.最终返回结果：dp[n][m] == s.length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DP算法：</span></span><br><span class="line"><span class="comment">        时间复杂度：O(nm)</span></span><br><span class="line"><span class="comment">        空间复杂度：O(nm)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h4><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p>示例1：</p>
<blockquote>
<p>输入：s = “rabbbit”, t = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br><u>rabb</u>b<u>it</u><br><u>ra</u>b<u>bbit</u><br><u>rab</u>b<u>bit</u></p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：s = “babgbag”, t = “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br><strong>ba</strong>b<strong>g</strong>bag<br><strong>ba</strong>bgba<strong>g</strong><br><strong>b</strong>abgb<strong>ag</strong><br>ba<strong>b</strong>gb<strong>ag</strong><br>babg<strong>bag</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    “计算在 s 的子序列中 t 出现的个数。”这句话和下面一句话是等价的</span></span><br><span class="line"><span class="comment">    “在s中删除元素，使得他变成t，有几种删除的方式？”</span></span><br><span class="line"><span class="comment">    1.含义：s[0...i-1]的子序列中出现t[0...j-1]的个数为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：如果s[i-1] == t[j-1]: </span></span><br><span class="line"><span class="comment">                dp[i][j] =  dp[i-1][j-1] + dp[i-1][j]</span></span><br><span class="line"><span class="comment">             否则：</span></span><br><span class="line"><span class="comment">                dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="comment">    其中dp[i-1][j-1]是用s[i-1]来匹配，dp[i-1][j-1]是不用s[i-1]来匹配（即删除掉s[i-1]）</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0...n-1][0] = 1 表示只能删掉s的所有元素才能变成t，即包含1个t</span></span><br><span class="line"><span class="comment">                dp[0][1...m-1] = 0 表示s为空字符串，他不可能包含t</span></span><br><span class="line"><span class="comment">    4.计算顺序：由递推式可知，dp[i][j]是由左上边或者上边得来</span></span><br><span class="line"><span class="comment">                ，故计算顺序为外层遍历s内层遍历t，从小到大</span></span><br><span class="line"><span class="comment">    5.举例：</span></span><br><span class="line"><span class="comment">            0 r a b b i t</span></span><br><span class="line"><span class="comment">        0   1 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">        r   1 1 0 0 0 0 0</span></span><br><span class="line"><span class="comment">        a   1 1 1 0 0 0 0</span></span><br><span class="line"><span class="comment">        b   1 1 1 1 0 0 0</span></span><br><span class="line"><span class="comment">        b   1 1 1 2 1 0 0</span></span><br><span class="line"><span class="comment">        b   1 1 1 3 3 0 0</span></span><br><span class="line"><span class="comment">        i   1 1 1 3 3 3 0</span></span><br><span class="line"><span class="comment">        t   1 1 1 3 3 3 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>“计算在 s 的子序列中 t 出现的个数。”这句话和下面一句话是等价的
“在s中删除元素，使得他变成t，有几种删除的方式？”

也可以理解为：之前都是求编辑距离的最小值，这次是求编辑的方式有多少种！
</code></pre></blockquote>
<h4 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h4><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
<p>示例1：</p>
<blockquote>
<p>输入: word1 = “sea”, word2 = “eat”<br>输出: 2<br>解释: 第一步将 “sea” 变为 “ea” ，第二步将 “eat “变为 “ea”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(), m = word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>, dp[i][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：使得word1[0...i-1]和word2[0...j-1]相同所需最小步数为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：  如果word1[i-1] == word1[j-1]：</span></span><br><span class="line"><span class="comment">                    dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">                否则：</span></span><br><span class="line"><span class="comment">                    dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1)</span></span><br><span class="line"><span class="comment">        其中dp[i-1][j-1]表示使用(不删除)word1[i-1]和word2[j-1]</span></span><br><span class="line"><span class="comment">        dp[i-1][j]表示不使用word1[i-1]，即需要删除word1[i-1]，所以步数+1</span></span><br><span class="line"><span class="comment">        dp[i][j-1]表示不使用word2[j-1]，即需要删除word2[j-1]，所以步数+1</span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = j, dp[i][0] = i </span></span><br><span class="line"><span class="comment">        当有一个字符串为空串时，另一个字符串只能删掉他的所有的元素，所以最小步数为另一个字符串的长度</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层word1，内层wordw2，从小到大</span></span><br><span class="line"><span class="comment">    5.举例：word1 = &quot;sea&quot;, word2 = &quot;eat&quot;</span></span><br><span class="line"><span class="comment">        0 e a t</span></span><br><span class="line"><span class="comment">    0   0 1 2 3</span></span><br><span class="line"><span class="comment">    s   1 2 3 4</span></span><br><span class="line"><span class="comment">    e   2 1 2 3 </span></span><br><span class="line"><span class="comment">    a   3 2 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="72-编辑距离-研一算法考试的题目"><a href="#72-编辑距离-研一算法考试的题目" class="headerlink" title="72. 编辑距离(研一算法考试的题目)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a>(研一算法考试的题目)</h4><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<pre><code>插入一个字符
删除一个字符
替换一个字符
</code></pre><p>示例1：</p>
<blockquote>
<p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：word1 = “intention”, word2 = “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word1.length(), m = word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>, dp[i][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：word1[0...i-1]转换成word2[0...j-1]所使用的最少操作数为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：  如果word1[i-1]==word2[j-1]:</span></span><br><span class="line"><span class="comment">                    dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">                否则：</span></span><br><span class="line"><span class="comment">                    dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        其中dp[i-1][j-1]+1表示让word1[i-1]替换成word2[j-1]</span></span><br><span class="line"><span class="comment">        dp[i-1][j]+1表示把word1[i-1]删除掉</span></span><br><span class="line"><span class="comment">        dp[i][j-1]+1表示把word2[j-1]删除掉（等价于在word1[i-1]后面插入一个word2[j-1]）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    3.初始化：dp[0][j] = j, dp[i][0] = i </span></span><br><span class="line"><span class="comment">        当有一个字符串为空串时，另一个字符串只能删掉他的所有的元素，所以最小步数为另一个字符串的长度</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层word1，内层wordw2，从小到大</span></span><br><span class="line"><span class="comment">    5.举例：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span></span><br><span class="line"><span class="comment">        0 r o s</span></span><br><span class="line"><span class="comment">    0   0 1 2 3</span></span><br><span class="line"><span class="comment">    h   1 1 2 3</span></span><br><span class="line"><span class="comment">    o   2 2 1 2</span></span><br><span class="line"><span class="comment">    r   3 2 2 2</span></span><br><span class="line"><span class="comment">    s   4 3 3 2</span></span><br><span class="line"><span class="comment">    e   5 4 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h4><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
<p>示例1：</p>
<blockquote>
<p>输入：s = “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：s = “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>
</blockquote>
<p>DP解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j) &#123; <span class="comment">// &quot;a&quot;</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == j) &#123;<span class="comment">// &quot;aa&quot;</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) &#123;<span class="comment">// &quot;a回文串a&quot;</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：dp[i][j]=true表示s[i..j]是回文串，false表示不是回文串。</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">            if (s[i] == s[j]) </span></span><br><span class="line"><span class="comment">                if (i==j) dp[i][j] = true  这种情况是 单单一个字符</span></span><br><span class="line"><span class="comment">                else if (i+1==j) dp[i][j] = true 这种情况是 两个重复的字符</span></span><br><span class="line"><span class="comment">                else dp[i][j] = dp[i+1][j-1] 取决于着两个相同字符之间的字串是不是回文串</span></span><br><span class="line"><span class="comment">    3.初始化:dp[i][j] = false</span></span><br><span class="line"><span class="comment">    4.计算顺序：由递推式知，dp[i][j]是从左下方推出来的</span></span><br><span class="line"><span class="comment">            所以遍历顺序为，外层i 从n down to 0, 内层j 从0 up to n</span></span><br><span class="line"><span class="comment">    5.举例：(注：i &gt; j 是无意义的，全都为false)</span></span><br><span class="line"><span class="comment">    s = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">        a b c</span></span><br><span class="line"><span class="comment">    a   t f f</span></span><br><span class="line"><span class="comment">    b     t f</span></span><br><span class="line"><span class="comment">    c       t</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    s = &quot;aaa&quot;</span></span><br><span class="line"><span class="comment">        a a a</span></span><br><span class="line"><span class="comment">    a   t t t</span></span><br><span class="line"><span class="comment">    a   f t t</span></span><br><span class="line"><span class="comment">    a   f f t</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dp解法的时间复杂度：O(n²)</span></span><br><span class="line"><span class="comment">        空间复杂度：O(n²)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p>示例1：</p>
<blockquote>
<p>输入：s = “bbbab”</p>
<p>输出：4</p>
<p>解释：一个可能的最长回文子序列为 “bbbb” 。</p>
</blockquote>
<p>DP解法1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> == j) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j-<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.含义：s[i..j]的最长回文子序列长度为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">        if (s[i] == s[j]) </span></span><br><span class="line"><span class="comment">            if (i==j)   dp[i][j] = 1</span></span><br><span class="line"><span class="comment">            elif (i+1==j) dp[i][j] = 2</span></span><br><span class="line"><span class="comment">            else dp[i][j] = dp[i+1][j-1]+2</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            dp[i][j] = max(dp[i][j-1], dp[i+1][j])</span></span><br><span class="line"><span class="comment">    3.初始化：dp[i][j]] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：由递推式知，dp[i][j]由左下，左，下得来。</span></span><br><span class="line"><span class="comment">            所以计算顺序为：外层i from n down to 1</span></span><br><span class="line"><span class="comment">                            内层j from 0 up to n</span></span><br><span class="line"><span class="comment">    5.举例：s = &quot;bbbab&quot;</span></span><br><span class="line"><span class="comment">        b b b a b</span></span><br><span class="line"><span class="comment">    b   1 2 3 3 4</span></span><br><span class="line"><span class="comment">    b   0 1 2 2 3</span></span><br><span class="line"><span class="comment">    b   0 0 1 1 3</span></span><br><span class="line"><span class="comment">    a   0 0 0 1 1</span></span><br><span class="line"><span class="comment">    b   0 0 0 0 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>DP解法2：将原问题转换为了LCS问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> reverse(s);</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>) == t.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.print(dp[i][j] + &quot; &quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverse</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ch[i] = s.charAt(n-i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    问题转换：将s翻转得到t，求s和t的最长公共子序列</span></span><br><span class="line"><span class="comment">    如，s = &quot;bbbab&quot;, t = &quot;babbb&quot; 他们的LCS = &quot;bbb&quot;即为s的最长回文子序列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1.含义：s[0...i-1]和t[0...j-1]的LCS为dp[i][j]</span></span><br><span class="line"><span class="comment">    2.递推式：</span></span><br><span class="line"><span class="comment">        if (s[i-1]==t[j-1])</span></span><br><span class="line"><span class="comment">            dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])</span></span><br><span class="line"><span class="comment">    3.初始化： dp[0][j] = 0, dp[i][0] = 0</span></span><br><span class="line"><span class="comment">    4.计算顺序：外层s，内层t，都是从小到大</span></span><br><span class="line"><span class="comment">    5.举例：s = &quot;bbbab&quot;, t = &quot;babbb&quot; </span></span><br><span class="line"><span class="comment">        0 b a b b b</span></span><br><span class="line"><span class="comment">    0   0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">    b   0 1 1 1 1 1</span></span><br><span class="line"><span class="comment">    b   0 1 1 2 2 2</span></span><br><span class="line"><span class="comment">    b   0 1 1 2 3 3</span></span><br><span class="line"><span class="comment">    a   0 1 2 2 3 3</span></span><br><span class="line"><span class="comment">    b   0 1 2 3 3 4</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://leesin9527.github.io">leesin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leesin9527.github.io/post/6.html">https://leesin9527.github.io/post/6.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://leesin9527.github.io" target="_blank">leesin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/dp/">dp</a></div><div class="post_share"><div class="social-share" data-image="http://cdn.leesin.fun/hexo/article/6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/1.html" title="MySQL高级"><img class="cover" src="http://cdn.leesin.fun/hexo/article/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL高级</div></div></a></div><div class="next-post pull-right"><a href="/post/3.html" title="计算机网络"><img class="cover" src="http://cdn.leesin.fun/hexo/article/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.leesin.fun/hexo/avatar.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="avatar"/></div><div class="author-info__name">leesin</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/leesin9527" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="mailto:uchihazed@qq.com" target="_blank" title="Email"><i class="iconfont icon-email"></i></a><a class="social-icon" href="tencent://message/?uin=2269196662&amp;Site=Sambow&amp;Menu=yes" target="_blank" title="QQ"><i class="iconfont icon-qq"></i></a><a class="social-icon" href="https://space.bilibili.com/350235279?spm_id_from=333.999.0.0" target="_blank" title="B站"><i class="iconfont icon-bilibili"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">70. 爬楼梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">62. 不同路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">343. 整数拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">377.组合总和IV⭐⭐⭐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">322.零钱兑换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">279.完全平方数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">139.单词拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">122.买卖股票的最佳时机II</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">1143.最长公共子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">300.最长递增子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">718.最长重复子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">674. 最长连续递增序列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DP%E8%A7%A3%E6%B3%95"><span class="toc-number">1.1.0.4.1.</span> <span class="toc-text">DP解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95"><span class="toc-number">1.1.0.4.2.</span> <span class="toc-text">贪心解法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">1035. 不相交的线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">1.1.0.6.</span> <span class="toc-text">53. 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DP%E8%A7%A3%E6%B3%95-1"><span class="toc-number">1.1.0.6.1.</span> <span class="toc-text">DP解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E8%A7%A3%E6%B3%95"><span class="toc-number">1.1.0.6.2.</span> <span class="toc-text">分治解法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">编辑距离类问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">392. 判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95"><span class="toc-number">1.2.0.1.1.</span> <span class="toc-text">双指针解法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DP%E8%A7%A3%E6%B3%95-2"><span class="toc-number">1.2.0.1.2.</span> <span class="toc-text">DP解法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">115. 不同的子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">583. 两个字符串的删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-%E7%A0%94%E4%B8%80%E7%AE%97%E6%B3%95%E8%80%83%E8%AF%95%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">72. 编辑距离(研一算法考试的题目)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.3.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">647. 回文子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">516. 最长回文子序列</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/30.html" title="AOP入门"><img src="http://cdn.leesin.fun/hexo/article/30.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AOP入门"/></a><div class="content"><a class="title" href="/post/30.html" title="AOP入门">AOP入门</a><time datetime="2023-05-08T02:38:00.000Z" title="发表于 2023-05-08 10:38:00">2023-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/29.html" title="Spring注解开发"><img src="http://cdn.leesin.fun/hexo/article/29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring注解开发"/></a><div class="content"><a class="title" href="/post/29.html" title="Spring注解开发">Spring注解开发</a><time datetime="2023-05-07T02:00:00.000Z" title="发表于 2023-05-07 10:00:00">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/28.html" title="【Spring基础】Spring Bean的生命周期"><img src="http://cdn.leesin.fun/hexo/article/28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Spring基础】Spring Bean的生命周期"/></a><div class="content"><a class="title" href="/post/28.html" title="【Spring基础】Spring Bean的生命周期">【Spring基础】Spring Bean的生命周期</a><time datetime="2023-05-05T06:03:00.000Z" title="发表于 2023-05-05 14:03:00">2023-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/27.html" title="【Spring基础】Spring后处理器"><img src="http://cdn.leesin.fun/hexo/article/27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Spring基础】Spring后处理器"/></a><div class="content"><a class="title" href="/post/27.html" title="【Spring基础】Spring后处理器">【Spring基础】Spring后处理器</a><time datetime="2023-05-01T10:10:00.000Z" title="发表于 2023-05-01 18:10:00">2023-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/26.html" title="【Spring基础】Bean实例化流程"><img src="http://cdn.leesin.fun/hexo/article/26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Spring基础】Bean实例化流程"/></a><div class="content"><a class="title" href="/post/26.html" title="【Spring基础】Bean实例化流程">【Spring基础】Bean实例化流程</a><time datetime="2023-04-29T14:59:00.000Z" title="发表于 2023-04-29 22:59:00">2023-04-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By leesin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/jquery.js"></script><script src="/js/foot.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="/js/sun_moon.js" async></script><div class="aplayer no-destroy" data-id="8261498022" data-server="netease" data-type="playlist"  data-mini="true" data-fixed="true" data-autoplay="false" data-listfolded="true" data-lrctype="0"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>